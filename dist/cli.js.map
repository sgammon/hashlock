{
  "version": 3,
  "sources": ["../node_modules/.pnpm/commander@12.0.0/node_modules/commander/lib/error.js", "../node_modules/.pnpm/commander@12.0.0/node_modules/commander/lib/argument.js", "../node_modules/.pnpm/commander@12.0.0/node_modules/commander/lib/help.js", "../node_modules/.pnpm/commander@12.0.0/node_modules/commander/lib/option.js", "../node_modules/.pnpm/commander@12.0.0/node_modules/commander/lib/suggestSimilar.js", "../node_modules/.pnpm/commander@12.0.0/node_modules/commander/lib/command.js", "../node_modules/.pnpm/commander@12.0.0/node_modules/commander/index.js", "../node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js", "../node_modules/.pnpm/brace-expansion@2.0.1/node_modules/brace-expansion/index.js", "../src/cli.ts", "../node_modules/.pnpm/commander@12.0.0/node_modules/commander/esm.mjs", "../src/tool.ts", "../src/model.ts", "../src/main.ts", "../src/generator.ts", "../node_modules/.pnpm/minimatch@9.0.3/node_modules/minimatch/src/index.ts", "../node_modules/.pnpm/minimatch@9.0.3/node_modules/minimatch/src/assert-valid-pattern.ts", "../node_modules/.pnpm/minimatch@9.0.3/node_modules/minimatch/src/brace-expressions.ts", "../node_modules/.pnpm/minimatch@9.0.3/node_modules/minimatch/src/unescape.ts", "../node_modules/.pnpm/minimatch@9.0.3/node_modules/minimatch/src/ast.ts", "../node_modules/.pnpm/minimatch@9.0.3/node_modules/minimatch/src/escape.ts", "../node_modules/.pnpm/lru-cache@10.2.0/node_modules/lru-cache/src/index.ts", "../node_modules/.pnpm/path-scurry@1.10.1/node_modules/path-scurry/src/index.ts", "../node_modules/.pnpm/minipass@7.0.4/node_modules/minipass/src/index.ts", "../node_modules/.pnpm/glob@10.3.10/node_modules/glob/src/glob.ts", "../node_modules/.pnpm/glob@10.3.10/node_modules/glob/src/pattern.ts", "../node_modules/.pnpm/glob@10.3.10/node_modules/glob/src/ignore.ts", "../node_modules/.pnpm/glob@10.3.10/node_modules/glob/src/processor.ts", "../node_modules/.pnpm/glob@10.3.10/node_modules/glob/src/walker.ts", "../node_modules/.pnpm/glob@10.3.10/node_modules/glob/src/has-magic.ts", "../node_modules/.pnpm/glob@10.3.10/node_modules/glob/src/index.ts", "../src/logger.ts", "../src/entry.ts"],
  "sourceRoot": "https://raw.githubusercontent.com/sgammon/verify-hashes/main/",
  "sourcesContent": ["/**\n * CommanderError class\n * @class\n */\nclass CommanderError extends Error {\n  /**\n   * Constructs the CommanderError class\n   * @param {number} exitCode suggested exit code which could be used with process.exit\n   * @param {string} code an id string representing the error\n   * @param {string} message human-readable description of the error\n   * @constructor\n   */\n  constructor(exitCode, code, message) {\n    super(message);\n    // properly capture stack trace in Node.js\n    Error.captureStackTrace(this, this.constructor);\n    this.name = this.constructor.name;\n    this.code = code;\n    this.exitCode = exitCode;\n    this.nestedError = undefined;\n  }\n}\n\n/**\n * InvalidArgumentError class\n * @class\n */\nclass InvalidArgumentError extends CommanderError {\n  /**\n   * Constructs the InvalidArgumentError class\n   * @param {string} [message] explanation of why argument is invalid\n   * @constructor\n   */\n  constructor(message) {\n    super(1, 'commander.invalidArgument', message);\n    // properly capture stack trace in Node.js\n    Error.captureStackTrace(this, this.constructor);\n    this.name = this.constructor.name;\n  }\n}\n\nexports.CommanderError = CommanderError;\nexports.InvalidArgumentError = InvalidArgumentError;\n", "const { InvalidArgumentError } = require('./error.js');\n\nclass Argument {\n  /**\n   * Initialize a new command argument with the given name and description.\n   * The default is that the argument is required, and you can explicitly\n   * indicate this with <> around the name. Put [] around the name for an optional argument.\n   *\n   * @param {string} name\n   * @param {string} [description]\n   */\n\n  constructor(name, description) {\n    this.description = description || '';\n    this.variadic = false;\n    this.parseArg = undefined;\n    this.defaultValue = undefined;\n    this.defaultValueDescription = undefined;\n    this.argChoices = undefined;\n\n    switch (name[0]) {\n      case '<': // e.g. <required>\n        this.required = true;\n        this._name = name.slice(1, -1);\n        break;\n      case '[': // e.g. [optional]\n        this.required = false;\n        this._name = name.slice(1, -1);\n        break;\n      default:\n        this.required = true;\n        this._name = name;\n        break;\n    }\n\n    if (this._name.length > 3 && this._name.slice(-3) === '...') {\n      this.variadic = true;\n      this._name = this._name.slice(0, -3);\n    }\n  }\n\n  /**\n   * Return argument name.\n   *\n   * @return {string}\n   */\n\n  name() {\n    return this._name;\n  }\n\n  /**\n   * @package internal use only\n   */\n\n  _concatValue(value, previous) {\n    if (previous === this.defaultValue || !Array.isArray(previous)) {\n      return [value];\n    }\n\n    return previous.concat(value);\n  }\n\n  /**\n   * Set the default value, and optionally supply the description to be displayed in the help.\n   *\n   * @param {*} value\n   * @param {string} [description]\n   * @return {Argument}\n   */\n\n  default(value, description) {\n    this.defaultValue = value;\n    this.defaultValueDescription = description;\n    return this;\n  }\n\n  /**\n   * Set the custom handler for processing CLI command arguments into argument values.\n   *\n   * @param {Function} [fn]\n   * @return {Argument}\n   */\n\n  argParser(fn) {\n    this.parseArg = fn;\n    return this;\n  }\n\n  /**\n   * Only allow argument value to be one of choices.\n   *\n   * @param {string[]} values\n   * @return {Argument}\n   */\n\n  choices(values) {\n    this.argChoices = values.slice();\n    this.parseArg = (arg, previous) => {\n      if (!this.argChoices.includes(arg)) {\n        throw new InvalidArgumentError(`Allowed choices are ${this.argChoices.join(', ')}.`);\n      }\n      if (this.variadic) {\n        return this._concatValue(arg, previous);\n      }\n      return arg;\n    };\n    return this;\n  }\n\n  /**\n   * Make argument required.\n   */\n  argRequired() {\n    this.required = true;\n    return this;\n  }\n\n  /**\n   * Make argument optional.\n   */\n  argOptional() {\n    this.required = false;\n    return this;\n  }\n}\n\n/**\n * Takes an argument and returns its human readable equivalent for help usage.\n *\n * @param {Argument} arg\n * @return {string}\n * @private\n */\n\nfunction humanReadableArgName(arg) {\n  const nameOutput = arg.name() + (arg.variadic === true ? '...' : '');\n\n  return arg.required\n    ? '<' + nameOutput + '>'\n    : '[' + nameOutput + ']';\n}\n\nexports.Argument = Argument;\nexports.humanReadableArgName = humanReadableArgName;\n", "const { humanReadableArgName } = require('./argument.js');\n\n/**\n * TypeScript import types for JSDoc, used by Visual Studio Code IntelliSense and `npm run typescript-checkJS`\n * https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#import-types\n * @typedef { import(\"./argument.js\").Argument } Argument\n * @typedef { import(\"./command.js\").Command } Command\n * @typedef { import(\"./option.js\").Option } Option\n */\n\n// Although this is a class, methods are static in style to allow override using subclass or just functions.\nclass Help {\n  constructor() {\n    this.helpWidth = undefined;\n    this.sortSubcommands = false;\n    this.sortOptions = false;\n    this.showGlobalOptions = false;\n  }\n\n  /**\n   * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.\n   *\n   * @param {Command} cmd\n   * @returns {Command[]}\n   */\n\n  visibleCommands(cmd) {\n    const visibleCommands = cmd.commands.filter(cmd => !cmd._hidden);\n    const helpCommand = cmd._getHelpCommand();\n    if (helpCommand && !helpCommand._hidden) {\n      visibleCommands.push(helpCommand);\n    }\n    if (this.sortSubcommands) {\n      visibleCommands.sort((a, b) => {\n        // @ts-ignore: overloaded return type\n        return a.name().localeCompare(b.name());\n      });\n    }\n    return visibleCommands;\n  }\n\n  /**\n   * Compare options for sort.\n   *\n   * @param {Option} a\n   * @param {Option} b\n   * @returns number\n   */\n  compareOptions(a, b) {\n    const getSortKey = (option) => {\n      // WYSIWYG for order displayed in help. Short used for comparison if present. No special handling for negated.\n      return option.short ? option.short.replace(/^-/, '') : option.long.replace(/^--/, '');\n    };\n    return getSortKey(a).localeCompare(getSortKey(b));\n  }\n\n  /**\n   * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.\n   *\n   * @param {Command} cmd\n   * @returns {Option[]}\n   */\n\n  visibleOptions(cmd) {\n    const visibleOptions = cmd.options.filter((option) => !option.hidden);\n    // Built-in help option.\n    const helpOption = cmd._getHelpOption();\n    if (helpOption && !helpOption.hidden) {\n      // Automatically hide conflicting flags. Bit dubious but a historical behaviour that is convenient for single-command programs.\n      const removeShort = helpOption.short && cmd._findOption(helpOption.short);\n      const removeLong = helpOption.long && cmd._findOption(helpOption.long);\n      if (!removeShort && !removeLong) {\n        visibleOptions.push(helpOption); // no changes needed\n      } else if (helpOption.long && !removeLong) {\n        visibleOptions.push(cmd.createOption(helpOption.long, helpOption.description));\n      } else if (helpOption.short && !removeShort) {\n        visibleOptions.push(cmd.createOption(helpOption.short, helpOption.description));\n      }\n    }\n    if (this.sortOptions) {\n      visibleOptions.sort(this.compareOptions);\n    }\n    return visibleOptions;\n  }\n\n  /**\n   * Get an array of the visible global options. (Not including help.)\n   *\n   * @param {Command} cmd\n   * @returns {Option[]}\n   */\n\n  visibleGlobalOptions(cmd) {\n    if (!this.showGlobalOptions) return [];\n\n    const globalOptions = [];\n    for (let ancestorCmd = cmd.parent; ancestorCmd; ancestorCmd = ancestorCmd.parent) {\n      const visibleOptions = ancestorCmd.options.filter((option) => !option.hidden);\n      globalOptions.push(...visibleOptions);\n    }\n    if (this.sortOptions) {\n      globalOptions.sort(this.compareOptions);\n    }\n    return globalOptions;\n  }\n\n  /**\n   * Get an array of the arguments if any have a description.\n   *\n   * @param {Command} cmd\n   * @returns {Argument[]}\n   */\n\n  visibleArguments(cmd) {\n    // Side effect! Apply the legacy descriptions before the arguments are displayed.\n    if (cmd._argsDescription) {\n      cmd.registeredArguments.forEach(argument => {\n        argument.description = argument.description || cmd._argsDescription[argument.name()] || '';\n      });\n    }\n\n    // If there are any arguments with a description then return all the arguments.\n    if (cmd.registeredArguments.find(argument => argument.description)) {\n      return cmd.registeredArguments;\n    }\n    return [];\n  }\n\n  /**\n   * Get the command term to show in the list of subcommands.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  subcommandTerm(cmd) {\n    // Legacy. Ignores custom usage string, and nested commands.\n    const args = cmd.registeredArguments.map(arg => humanReadableArgName(arg)).join(' ');\n    return cmd._name +\n      (cmd._aliases[0] ? '|' + cmd._aliases[0] : '') +\n      (cmd.options.length ? ' [options]' : '') + // simplistic check for non-help option\n      (args ? ' ' + args : '');\n  }\n\n  /**\n   * Get the option term to show in the list of options.\n   *\n   * @param {Option} option\n   * @returns {string}\n   */\n\n  optionTerm(option) {\n    return option.flags;\n  }\n\n  /**\n   * Get the argument term to show in the list of arguments.\n   *\n   * @param {Argument} argument\n   * @returns {string}\n   */\n\n  argumentTerm(argument) {\n    return argument.name();\n  }\n\n  /**\n   * Get the longest command term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestSubcommandTermLength(cmd, helper) {\n    return helper.visibleCommands(cmd).reduce((max, command) => {\n      return Math.max(max, helper.subcommandTerm(command).length);\n    }, 0);\n  }\n\n  /**\n   * Get the longest option term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestOptionTermLength(cmd, helper) {\n    return helper.visibleOptions(cmd).reduce((max, option) => {\n      return Math.max(max, helper.optionTerm(option).length);\n    }, 0);\n  }\n\n  /**\n   * Get the longest global option term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestGlobalOptionTermLength(cmd, helper) {\n    return helper.visibleGlobalOptions(cmd).reduce((max, option) => {\n      return Math.max(max, helper.optionTerm(option).length);\n    }, 0);\n  }\n\n  /**\n   * Get the longest argument term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestArgumentTermLength(cmd, helper) {\n    return helper.visibleArguments(cmd).reduce((max, argument) => {\n      return Math.max(max, helper.argumentTerm(argument).length);\n    }, 0);\n  }\n\n  /**\n   * Get the command usage to be displayed at the top of the built-in help.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  commandUsage(cmd) {\n    // Usage\n    let cmdName = cmd._name;\n    if (cmd._aliases[0]) {\n      cmdName = cmdName + '|' + cmd._aliases[0];\n    }\n    let ancestorCmdNames = '';\n    for (let ancestorCmd = cmd.parent; ancestorCmd; ancestorCmd = ancestorCmd.parent) {\n      ancestorCmdNames = ancestorCmd.name() + ' ' + ancestorCmdNames;\n    }\n    return ancestorCmdNames + cmdName + ' ' + cmd.usage();\n  }\n\n  /**\n   * Get the description for the command.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  commandDescription(cmd) {\n    // @ts-ignore: overloaded return type\n    return cmd.description();\n  }\n\n  /**\n   * Get the subcommand summary to show in the list of subcommands.\n   * (Fallback to description for backwards compatibility.)\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  subcommandDescription(cmd) {\n    // @ts-ignore: overloaded return type\n    return cmd.summary() || cmd.description();\n  }\n\n  /**\n   * Get the option description to show in the list of options.\n   *\n   * @param {Option} option\n   * @return {string}\n   */\n\n  optionDescription(option) {\n    const extraInfo = [];\n\n    if (option.argChoices) {\n      extraInfo.push(\n        // use stringify to match the display of the default value\n        `choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(', ')}`);\n    }\n    if (option.defaultValue !== undefined) {\n      // default for boolean and negated more for programmer than end user,\n      // but show true/false for boolean option as may be for hand-rolled env or config processing.\n      const showDefault = option.required || option.optional ||\n        (option.isBoolean() && typeof option.defaultValue === 'boolean');\n      if (showDefault) {\n        extraInfo.push(`default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`);\n      }\n    }\n    // preset for boolean and negated are more for programmer than end user\n    if (option.presetArg !== undefined && option.optional) {\n      extraInfo.push(`preset: ${JSON.stringify(option.presetArg)}`);\n    }\n    if (option.envVar !== undefined) {\n      extraInfo.push(`env: ${option.envVar}`);\n    }\n    if (extraInfo.length > 0) {\n      return `${option.description} (${extraInfo.join(', ')})`;\n    }\n\n    return option.description;\n  }\n\n  /**\n   * Get the argument description to show in the list of arguments.\n   *\n   * @param {Argument} argument\n   * @return {string}\n   */\n\n  argumentDescription(argument) {\n    const extraInfo = [];\n    if (argument.argChoices) {\n      extraInfo.push(\n        // use stringify to match the display of the default value\n        `choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(', ')}`);\n    }\n    if (argument.defaultValue !== undefined) {\n      extraInfo.push(`default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`);\n    }\n    if (extraInfo.length > 0) {\n      const extraDescripton = `(${extraInfo.join(', ')})`;\n      if (argument.description) {\n        return `${argument.description} ${extraDescripton}`;\n      }\n      return extraDescripton;\n    }\n    return argument.description;\n  }\n\n  /**\n   * Generate the built-in help text.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {string}\n   */\n\n  formatHelp(cmd, helper) {\n    const termWidth = helper.padWidth(cmd, helper);\n    const helpWidth = helper.helpWidth || 80;\n    const itemIndentWidth = 2;\n    const itemSeparatorWidth = 2; // between term and description\n    function formatItem(term, description) {\n      if (description) {\n        const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;\n        return helper.wrap(fullText, helpWidth - itemIndentWidth, termWidth + itemSeparatorWidth);\n      }\n      return term;\n    }\n    function formatList(textArray) {\n      return textArray.join('\\n').replace(/^/gm, ' '.repeat(itemIndentWidth));\n    }\n\n    // Usage\n    let output = [`Usage: ${helper.commandUsage(cmd)}`, ''];\n\n    // Description\n    const commandDescription = helper.commandDescription(cmd);\n    if (commandDescription.length > 0) {\n      output = output.concat([helper.wrap(commandDescription, helpWidth, 0), '']);\n    }\n\n    // Arguments\n    const argumentList = helper.visibleArguments(cmd).map((argument) => {\n      return formatItem(helper.argumentTerm(argument), helper.argumentDescription(argument));\n    });\n    if (argumentList.length > 0) {\n      output = output.concat(['Arguments:', formatList(argumentList), '']);\n    }\n\n    // Options\n    const optionList = helper.visibleOptions(cmd).map((option) => {\n      return formatItem(helper.optionTerm(option), helper.optionDescription(option));\n    });\n    if (optionList.length > 0) {\n      output = output.concat(['Options:', formatList(optionList), '']);\n    }\n\n    if (this.showGlobalOptions) {\n      const globalOptionList = helper.visibleGlobalOptions(cmd).map((option) => {\n        return formatItem(helper.optionTerm(option), helper.optionDescription(option));\n      });\n      if (globalOptionList.length > 0) {\n        output = output.concat(['Global Options:', formatList(globalOptionList), '']);\n      }\n    }\n\n    // Commands\n    const commandList = helper.visibleCommands(cmd).map((cmd) => {\n      return formatItem(helper.subcommandTerm(cmd), helper.subcommandDescription(cmd));\n    });\n    if (commandList.length > 0) {\n      output = output.concat(['Commands:', formatList(commandList), '']);\n    }\n\n    return output.join('\\n');\n  }\n\n  /**\n   * Calculate the pad width from the maximum term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  padWidth(cmd, helper) {\n    return Math.max(\n      helper.longestOptionTermLength(cmd, helper),\n      helper.longestGlobalOptionTermLength(cmd, helper),\n      helper.longestSubcommandTermLength(cmd, helper),\n      helper.longestArgumentTermLength(cmd, helper)\n    );\n  }\n\n  /**\n   * Wrap the given string to width characters per line, with lines after the first indented.\n   * Do not wrap if insufficient room for wrapping (minColumnWidth), or string is manually formatted.\n   *\n   * @param {string} str\n   * @param {number} width\n   * @param {number} indent\n   * @param {number} [minColumnWidth=40]\n   * @return {string}\n   *\n   */\n\n  wrap(str, width, indent, minColumnWidth = 40) {\n    // Full \\s characters, minus the linefeeds.\n    const indents = ' \\\\f\\\\t\\\\v\\u00a0\\u1680\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff';\n    // Detect manually wrapped and indented strings by searching for line break followed by spaces.\n    const manualIndent = new RegExp(`[\\\\n][${indents}]+`);\n    if (str.match(manualIndent)) return str;\n    // Do not wrap if not enough room for a wrapped column of text (as could end up with a word per line).\n    const columnWidth = width - indent;\n    if (columnWidth < minColumnWidth) return str;\n\n    const leadingStr = str.slice(0, indent);\n    const columnText = str.slice(indent).replace('\\r\\n', '\\n');\n    const indentString = ' '.repeat(indent);\n    const zeroWidthSpace = '\\u200B';\n    const breaks = `\\\\s${zeroWidthSpace}`;\n    // Match line end (so empty lines don't collapse),\n    // or as much text as will fit in column, or excess text up to first break.\n    const regex = new RegExp(`\\n|.{1,${columnWidth - 1}}([${breaks}]|$)|[^${breaks}]+?([${breaks}]|$)`, 'g');\n    const lines = columnText.match(regex) || [];\n    return leadingStr + lines.map((line, i) => {\n      if (line === '\\n') return ''; // preserve empty lines\n      return ((i > 0) ? indentString : '') + line.trimEnd();\n    }).join('\\n');\n  }\n}\n\nexports.Help = Help;\n", "const { InvalidArgumentError } = require('./error.js');\n\nclass Option {\n  /**\n   * Initialize a new `Option` with the given `flags` and `description`.\n   *\n   * @param {string} flags\n   * @param {string} [description]\n   */\n\n  constructor(flags, description) {\n    this.flags = flags;\n    this.description = description || '';\n\n    this.required = flags.includes('<'); // A value must be supplied when the option is specified.\n    this.optional = flags.includes('['); // A value is optional when the option is specified.\n    // variadic test ignores <value,...> et al which might be used to describe custom splitting of single argument\n    this.variadic = /\\w\\.\\.\\.[>\\]]$/.test(flags); // The option can take multiple values.\n    this.mandatory = false; // The option must have a value after parsing, which usually means it must be specified on command line.\n    const optionFlags = splitOptionFlags(flags);\n    this.short = optionFlags.shortFlag;\n    this.long = optionFlags.longFlag;\n    this.negate = false;\n    if (this.long) {\n      this.negate = this.long.startsWith('--no-');\n    }\n    this.defaultValue = undefined;\n    this.defaultValueDescription = undefined;\n    this.presetArg = undefined;\n    this.envVar = undefined;\n    this.parseArg = undefined;\n    this.hidden = false;\n    this.argChoices = undefined;\n    this.conflictsWith = [];\n    this.implied = undefined;\n  }\n\n  /**\n   * Set the default value, and optionally supply the description to be displayed in the help.\n   *\n   * @param {*} value\n   * @param {string} [description]\n   * @return {Option}\n   */\n\n  default(value, description) {\n    this.defaultValue = value;\n    this.defaultValueDescription = description;\n    return this;\n  }\n\n  /**\n   * Preset to use when option used without option-argument, especially optional but also boolean and negated.\n   * The custom processing (parseArg) is called.\n   *\n   * @example\n   * new Option('--color').default('GREYSCALE').preset('RGB');\n   * new Option('--donate [amount]').preset('20').argParser(parseFloat);\n   *\n   * @param {*} arg\n   * @return {Option}\n   */\n\n  preset(arg) {\n    this.presetArg = arg;\n    return this;\n  }\n\n  /**\n   * Add option name(s) that conflict with this option.\n   * An error will be displayed if conflicting options are found during parsing.\n   *\n   * @example\n   * new Option('--rgb').conflicts('cmyk');\n   * new Option('--js').conflicts(['ts', 'jsx']);\n   *\n   * @param {(string | string[])} names\n   * @return {Option}\n   */\n\n  conflicts(names) {\n    this.conflictsWith = this.conflictsWith.concat(names);\n    return this;\n  }\n\n  /**\n   * Specify implied option values for when this option is set and the implied options are not.\n   *\n   * The custom processing (parseArg) is not called on the implied values.\n   *\n   * @example\n   * program\n   *   .addOption(new Option('--log', 'write logging information to file'))\n   *   .addOption(new Option('--trace', 'log extra details').implies({ log: 'trace.txt' }));\n   *\n   * @param {Object} impliedOptionValues\n   * @return {Option}\n   */\n  implies(impliedOptionValues) {\n    let newImplied = impliedOptionValues;\n    if (typeof impliedOptionValues === 'string') {\n      // string is not documented, but easy mistake and we can do what user probably intended.\n      newImplied = { [impliedOptionValues]: true };\n    }\n    this.implied = Object.assign(this.implied || {}, newImplied);\n    return this;\n  }\n\n  /**\n   * Set environment variable to check for option value.\n   *\n   * An environment variable is only used if when processed the current option value is\n   * undefined, or the source of the current value is 'default' or 'config' or 'env'.\n   *\n   * @param {string} name\n   * @return {Option}\n   */\n\n  env(name) {\n    this.envVar = name;\n    return this;\n  }\n\n  /**\n   * Set the custom handler for processing CLI option arguments into option values.\n   *\n   * @param {Function} [fn]\n   * @return {Option}\n   */\n\n  argParser(fn) {\n    this.parseArg = fn;\n    return this;\n  }\n\n  /**\n   * Whether the option is mandatory and must have a value after parsing.\n   *\n   * @param {boolean} [mandatory=true]\n   * @return {Option}\n   */\n\n  makeOptionMandatory(mandatory = true) {\n    this.mandatory = !!mandatory;\n    return this;\n  }\n\n  /**\n   * Hide option in help.\n   *\n   * @param {boolean} [hide=true]\n   * @return {Option}\n   */\n\n  hideHelp(hide = true) {\n    this.hidden = !!hide;\n    return this;\n  }\n\n  /**\n   * @package internal use only\n   */\n\n  _concatValue(value, previous) {\n    if (previous === this.defaultValue || !Array.isArray(previous)) {\n      return [value];\n    }\n\n    return previous.concat(value);\n  }\n\n  /**\n   * Only allow option value to be one of choices.\n   *\n   * @param {string[]} values\n   * @return {Option}\n   */\n\n  choices(values) {\n    this.argChoices = values.slice();\n    this.parseArg = (arg, previous) => {\n      if (!this.argChoices.includes(arg)) {\n        throw new InvalidArgumentError(`Allowed choices are ${this.argChoices.join(', ')}.`);\n      }\n      if (this.variadic) {\n        return this._concatValue(arg, previous);\n      }\n      return arg;\n    };\n    return this;\n  }\n\n  /**\n   * Return option name.\n   *\n   * @return {string}\n   */\n\n  name() {\n    if (this.long) {\n      return this.long.replace(/^--/, '');\n    }\n    return this.short.replace(/^-/, '');\n  }\n\n  /**\n   * Return option name, in a camelcase format that can be used\n   * as a object attribute key.\n   *\n   * @return {string}\n   */\n\n  attributeName() {\n    return camelcase(this.name().replace(/^no-/, ''));\n  }\n\n  /**\n   * Check if `arg` matches the short or long flag.\n   *\n   * @param {string} arg\n   * @return {boolean}\n   * @package internal use only\n   */\n\n  is(arg) {\n    return this.short === arg || this.long === arg;\n  }\n\n  /**\n   * Return whether a boolean option.\n   *\n   * Options are one of boolean, negated, required argument, or optional argument.\n   *\n   * @return {boolean}\n   * @package internal use only\n   */\n\n  isBoolean() {\n    return !this.required && !this.optional && !this.negate;\n  }\n}\n\n/**\n * This class is to make it easier to work with dual options, without changing the existing\n * implementation. We support separate dual options for separate positive and negative options,\n * like `--build` and `--no-build`, which share a single option value. This works nicely for some\n * use cases, but is tricky for others where we want separate behaviours despite\n * the single shared option value.\n */\nclass DualOptions {\n  /**\n   * @param {Option[]} options\n   */\n  constructor(options) {\n    this.positiveOptions = new Map();\n    this.negativeOptions = new Map();\n    this.dualOptions = new Set();\n    options.forEach(option => {\n      if (option.negate) {\n        this.negativeOptions.set(option.attributeName(), option);\n      } else {\n        this.positiveOptions.set(option.attributeName(), option);\n      }\n    });\n    this.negativeOptions.forEach((value, key) => {\n      if (this.positiveOptions.has(key)) {\n        this.dualOptions.add(key);\n      }\n    });\n  }\n\n  /**\n   * Did the value come from the option, and not from possible matching dual option?\n   *\n   * @param {*} value\n   * @param {Option} option\n   * @returns {boolean}\n   */\n  valueFromOption(value, option) {\n    const optionKey = option.attributeName();\n    if (!this.dualOptions.has(optionKey)) return true;\n\n    // Use the value to deduce if (probably) came from the option.\n    const preset = this.negativeOptions.get(optionKey).presetArg;\n    const negativeValue = (preset !== undefined) ? preset : false;\n    return option.negate === (negativeValue === value);\n  }\n}\n\n/**\n * Convert string from kebab-case to camelCase.\n *\n * @param {string} str\n * @return {string}\n * @private\n */\n\nfunction camelcase(str) {\n  return str.split('-').reduce((str, word) => {\n    return str + word[0].toUpperCase() + word.slice(1);\n  });\n}\n\n/**\n * Split the short and long flag out of something like '-m,--mixed <value>'\n *\n * @private\n */\n\nfunction splitOptionFlags(flags) {\n  let shortFlag;\n  let longFlag;\n  // Use original very loose parsing to maintain backwards compatibility for now,\n  // which allowed for example unintended `-sw, --short-word` [sic].\n  const flagParts = flags.split(/[ |,]+/);\n  if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1])) shortFlag = flagParts.shift();\n  longFlag = flagParts.shift();\n  // Add support for lone short flag without significantly changing parsing!\n  if (!shortFlag && /^-[^-]$/.test(longFlag)) {\n    shortFlag = longFlag;\n    longFlag = undefined;\n  }\n  return { shortFlag, longFlag };\n}\n\nexports.Option = Option;\nexports.DualOptions = DualOptions;\n", "const maxDistance = 3;\n\nfunction editDistance(a, b) {\n  // https://en.wikipedia.org/wiki/Damerau\u2013Levenshtein_distance\n  // Calculating optimal string alignment distance, no substring is edited more than once.\n  // (Simple implementation.)\n\n  // Quick early exit, return worst case.\n  if (Math.abs(a.length - b.length) > maxDistance) return Math.max(a.length, b.length);\n\n  // distance between prefix substrings of a and b\n  const d = [];\n\n  // pure deletions turn a into empty string\n  for (let i = 0; i <= a.length; i++) {\n    d[i] = [i];\n  }\n  // pure insertions turn empty string into b\n  for (let j = 0; j <= b.length; j++) {\n    d[0][j] = j;\n  }\n\n  // fill matrix\n  for (let j = 1; j <= b.length; j++) {\n    for (let i = 1; i <= a.length; i++) {\n      let cost = 1;\n      if (a[i - 1] === b[j - 1]) {\n        cost = 0;\n      } else {\n        cost = 1;\n      }\n      d[i][j] = Math.min(\n        d[i - 1][j] + 1, // deletion\n        d[i][j - 1] + 1, // insertion\n        d[i - 1][j - 1] + cost // substitution\n      );\n      // transposition\n      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {\n        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + 1);\n      }\n    }\n  }\n\n  return d[a.length][b.length];\n}\n\n/**\n * Find close matches, restricted to same number of edits.\n *\n * @param {string} word\n * @param {string[]} candidates\n * @returns {string}\n */\n\nfunction suggestSimilar(word, candidates) {\n  if (!candidates || candidates.length === 0) return '';\n  // remove possible duplicates\n  candidates = Array.from(new Set(candidates));\n\n  const searchingOptions = word.startsWith('--');\n  if (searchingOptions) {\n    word = word.slice(2);\n    candidates = candidates.map(candidate => candidate.slice(2));\n  }\n\n  let similar = [];\n  let bestDistance = maxDistance;\n  const minSimilarity = 0.4;\n  candidates.forEach((candidate) => {\n    if (candidate.length <= 1) return; // no one character guesses\n\n    const distance = editDistance(word, candidate);\n    const length = Math.max(word.length, candidate.length);\n    const similarity = (length - distance) / length;\n    if (similarity > minSimilarity) {\n      if (distance < bestDistance) {\n        // better edit distance, throw away previous worse matches\n        bestDistance = distance;\n        similar = [candidate];\n      } else if (distance === bestDistance) {\n        similar.push(candidate);\n      }\n    }\n  });\n\n  similar.sort((a, b) => a.localeCompare(b));\n  if (searchingOptions) {\n    similar = similar.map(candidate => `--${candidate}`);\n  }\n\n  if (similar.length > 1) {\n    return `\\n(Did you mean one of ${similar.join(', ')}?)`;\n  }\n  if (similar.length === 1) {\n    return `\\n(Did you mean ${similar[0]}?)`;\n  }\n  return '';\n}\n\nexports.suggestSimilar = suggestSimilar;\n", "const EventEmitter = require('events').EventEmitter;\nconst childProcess = require('child_process');\nconst path = require('path');\nconst fs = require('fs');\nconst process = require('process');\n\nconst { Argument, humanReadableArgName } = require('./argument.js');\nconst { CommanderError } = require('./error.js');\nconst { Help } = require('./help.js');\nconst { Option, DualOptions } = require('./option.js');\nconst { suggestSimilar } = require('./suggestSimilar');\n\nclass Command extends EventEmitter {\n  /**\n   * Initialize a new `Command`.\n   *\n   * @param {string} [name]\n   */\n\n  constructor(name) {\n    super();\n    /** @type {Command[]} */\n    this.commands = [];\n    /** @type {Option[]} */\n    this.options = [];\n    this.parent = null;\n    this._allowUnknownOption = false;\n    this._allowExcessArguments = true;\n    /** @type {Argument[]} */\n    this.registeredArguments = [];\n    this._args = this.registeredArguments; // deprecated old name\n    /** @type {string[]} */\n    this.args = []; // cli args with options removed\n    this.rawArgs = [];\n    this.processedArgs = []; // like .args but after custom processing and collecting variadic\n    this._scriptPath = null;\n    this._name = name || '';\n    this._optionValues = {};\n    this._optionValueSources = {}; // default, env, cli etc\n    this._storeOptionsAsProperties = false;\n    this._actionHandler = null;\n    this._executableHandler = false;\n    this._executableFile = null; // custom name for executable\n    this._executableDir = null; // custom search directory for subcommands\n    this._defaultCommandName = null;\n    this._exitCallback = null;\n    this._aliases = [];\n    this._combineFlagAndOptionalValue = true;\n    this._description = '';\n    this._summary = '';\n    this._argsDescription = undefined; // legacy\n    this._enablePositionalOptions = false;\n    this._passThroughOptions = false;\n    this._lifeCycleHooks = {}; // a hash of arrays\n    /** @type {(boolean | string)} */\n    this._showHelpAfterError = false;\n    this._showSuggestionAfterError = true;\n\n    // see .configureOutput() for docs\n    this._outputConfiguration = {\n      writeOut: (str) => process.stdout.write(str),\n      writeErr: (str) => process.stderr.write(str),\n      getOutHelpWidth: () => process.stdout.isTTY ? process.stdout.columns : undefined,\n      getErrHelpWidth: () => process.stderr.isTTY ? process.stderr.columns : undefined,\n      outputError: (str, write) => write(str)\n    };\n\n    this._hidden = false;\n    /** @type {(Option | null | undefined)} */\n    this._helpOption = undefined; // Lazy created on demand. May be null if help option is disabled.\n    this._addImplicitHelpCommand = undefined; // undecided whether true or false yet, not inherited\n    /** @type {Command} */\n    this._helpCommand = undefined; // lazy initialised, inherited\n    this._helpConfiguration = {};\n  }\n\n  /**\n   * Copy settings that are useful to have in common across root command and subcommands.\n   *\n   * (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)\n   *\n   * @param {Command} sourceCommand\n   * @return {Command} `this` command for chaining\n   */\n  copyInheritedSettings(sourceCommand) {\n    this._outputConfiguration = sourceCommand._outputConfiguration;\n    this._helpOption = sourceCommand._helpOption;\n    this._helpCommand = sourceCommand._helpCommand;\n    this._helpConfiguration = sourceCommand._helpConfiguration;\n    this._exitCallback = sourceCommand._exitCallback;\n    this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;\n    this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;\n    this._allowExcessArguments = sourceCommand._allowExcessArguments;\n    this._enablePositionalOptions = sourceCommand._enablePositionalOptions;\n    this._showHelpAfterError = sourceCommand._showHelpAfterError;\n    this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;\n\n    return this;\n  }\n\n  /**\n   * @returns {Command[]}\n   * @private\n   */\n\n  _getCommandAndAncestors() {\n    const result = [];\n    for (let command = this; command; command = command.parent) {\n      result.push(command);\n    }\n    return result;\n  }\n\n  /**\n   * Define a command.\n   *\n   * There are two styles of command: pay attention to where to put the description.\n   *\n   * @example\n   * // Command implemented using action handler (description is supplied separately to `.command`)\n   * program\n   *   .command('clone <source> [destination]')\n   *   .description('clone a repository into a newly created directory')\n   *   .action((source, destination) => {\n   *     console.log('clone command called');\n   *   });\n   *\n   * // Command implemented using separate executable file (description is second parameter to `.command`)\n   * program\n   *   .command('start <service>', 'start named service')\n   *   .command('stop [service]', 'stop named service, or all if no name supplied');\n   *\n   * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`\n   * @param {(Object|string)} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)\n   * @param {Object} [execOpts] - configuration options (for executable)\n   * @return {Command} returns new command for action handler, or `this` for executable command\n   */\n\n  command(nameAndArgs, actionOptsOrExecDesc, execOpts) {\n    let desc = actionOptsOrExecDesc;\n    let opts = execOpts;\n    if (typeof desc === 'object' && desc !== null) {\n      opts = desc;\n      desc = null;\n    }\n    opts = opts || {};\n    const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);\n\n    const cmd = this.createCommand(name);\n    if (desc) {\n      cmd.description(desc);\n      cmd._executableHandler = true;\n    }\n    if (opts.isDefault) this._defaultCommandName = cmd._name;\n    cmd._hidden = !!(opts.noHelp || opts.hidden); // noHelp is deprecated old name for hidden\n    cmd._executableFile = opts.executableFile || null; // Custom name for executable file, set missing to null to match constructor\n    if (args) cmd.arguments(args);\n    this._registerCommand(cmd);\n    cmd.parent = this;\n    cmd.copyInheritedSettings(this);\n\n    if (desc) return this;\n    return cmd;\n  }\n\n  /**\n   * Factory routine to create a new unattached command.\n   *\n   * See .command() for creating an attached subcommand, which uses this routine to\n   * create the command. You can override createCommand to customise subcommands.\n   *\n   * @param {string} [name]\n   * @return {Command} new command\n   */\n\n  createCommand(name) {\n    return new Command(name);\n  }\n\n  /**\n   * You can customise the help with a subclass of Help by overriding createHelp,\n   * or by overriding Help properties using configureHelp().\n   *\n   * @return {Help}\n   */\n\n  createHelp() {\n    return Object.assign(new Help(), this.configureHelp());\n  }\n\n  /**\n   * You can customise the help by overriding Help properties using configureHelp(),\n   * or with a subclass of Help by overriding createHelp().\n   *\n   * @param {Object} [configuration] - configuration options\n   * @return {(Command|Object)} `this` command for chaining, or stored configuration\n   */\n\n  configureHelp(configuration) {\n    if (configuration === undefined) return this._helpConfiguration;\n\n    this._helpConfiguration = configuration;\n    return this;\n  }\n\n  /**\n   * The default output goes to stdout and stderr. You can customise this for special\n   * applications. You can also customise the display of errors by overriding outputError.\n   *\n   * The configuration properties are all functions:\n   *\n   *     // functions to change where being written, stdout and stderr\n   *     writeOut(str)\n   *     writeErr(str)\n   *     // matching functions to specify width for wrapping help\n   *     getOutHelpWidth()\n   *     getErrHelpWidth()\n   *     // functions based on what is being written out\n   *     outputError(str, write) // used for displaying errors, and not used for displaying help\n   *\n   * @param {Object} [configuration] - configuration options\n   * @return {(Command|Object)} `this` command for chaining, or stored configuration\n   */\n\n  configureOutput(configuration) {\n    if (configuration === undefined) return this._outputConfiguration;\n\n    Object.assign(this._outputConfiguration, configuration);\n    return this;\n  }\n\n  /**\n   * Display the help or a custom message after an error occurs.\n   *\n   * @param {(boolean|string)} [displayHelp]\n   * @return {Command} `this` command for chaining\n   */\n  showHelpAfterError(displayHelp = true) {\n    if (typeof displayHelp !== 'string') displayHelp = !!displayHelp;\n    this._showHelpAfterError = displayHelp;\n    return this;\n  }\n\n  /**\n   * Display suggestion of similar commands for unknown commands, or options for unknown options.\n   *\n   * @param {boolean} [displaySuggestion]\n   * @return {Command} `this` command for chaining\n   */\n  showSuggestionAfterError(displaySuggestion = true) {\n    this._showSuggestionAfterError = !!displaySuggestion;\n    return this;\n  }\n\n  /**\n   * Add a prepared subcommand.\n   *\n   * See .command() for creating an attached subcommand which inherits settings from its parent.\n   *\n   * @param {Command} cmd - new subcommand\n   * @param {Object} [opts] - configuration options\n   * @return {Command} `this` command for chaining\n   */\n\n  addCommand(cmd, opts) {\n    if (!cmd._name) {\n      throw new Error(`Command passed to .addCommand() must have a name\n- specify the name in Command constructor or using .name()`);\n    }\n\n    opts = opts || {};\n    if (opts.isDefault) this._defaultCommandName = cmd._name;\n    if (opts.noHelp || opts.hidden) cmd._hidden = true; // modifying passed command due to existing implementation\n\n    this._registerCommand(cmd);\n    cmd.parent = this;\n    cmd._checkForBrokenPassThrough();\n\n    return this;\n  }\n\n  /**\n   * Factory routine to create a new unattached argument.\n   *\n   * See .argument() for creating an attached argument, which uses this routine to\n   * create the argument. You can override createArgument to return a custom argument.\n   *\n   * @param {string} name\n   * @param {string} [description]\n   * @return {Argument} new argument\n   */\n\n  createArgument(name, description) {\n    return new Argument(name, description);\n  }\n\n  /**\n   * Define argument syntax for command.\n   *\n   * The default is that the argument is required, and you can explicitly\n   * indicate this with <> around the name. Put [] around the name for an optional argument.\n   *\n   * @example\n   * program.argument('<input-file>');\n   * program.argument('[output-file]');\n   *\n   * @param {string} name\n   * @param {string} [description]\n   * @param {(Function|*)} [fn] - custom argument processing function\n   * @param {*} [defaultValue]\n   * @return {Command} `this` command for chaining\n   */\n  argument(name, description, fn, defaultValue) {\n    const argument = this.createArgument(name, description);\n    if (typeof fn === 'function') {\n      argument.default(defaultValue).argParser(fn);\n    } else {\n      argument.default(fn);\n    }\n    this.addArgument(argument);\n    return this;\n  }\n\n  /**\n   * Define argument syntax for command, adding multiple at once (without descriptions).\n   *\n   * See also .argument().\n   *\n   * @example\n   * program.arguments('<cmd> [env]');\n   *\n   * @param {string} names\n   * @return {Command} `this` command for chaining\n   */\n\n  arguments(names) {\n    names.trim().split(/ +/).forEach((detail) => {\n      this.argument(detail);\n    });\n    return this;\n  }\n\n  /**\n   * Define argument syntax for command, adding a prepared argument.\n   *\n   * @param {Argument} argument\n   * @return {Command} `this` command for chaining\n   */\n  addArgument(argument) {\n    const previousArgument = this.registeredArguments.slice(-1)[0];\n    if (previousArgument && previousArgument.variadic) {\n      throw new Error(`only the last argument can be variadic '${previousArgument.name()}'`);\n    }\n    if (argument.required && argument.defaultValue !== undefined && argument.parseArg === undefined) {\n      throw new Error(`a default value for a required argument is never used: '${argument.name()}'`);\n    }\n    this.registeredArguments.push(argument);\n    return this;\n  }\n\n  /**\n   * Customise or override default help command. By default a help command is automatically added if your command has subcommands.\n   *\n   *    program.helpCommand('help [cmd]');\n   *    program.helpCommand('help [cmd]', 'show help');\n   *    program.helpCommand(false); // suppress default help command\n   *    program.helpCommand(true); // add help command even if no subcommands\n   *\n   * @param {string|boolean} enableOrNameAndArgs - enable with custom name and/or arguments, or boolean to override whether added\n   * @param {string} [description] - custom description\n   * @return {Command} `this` command for chaining\n   */\n\n  helpCommand(enableOrNameAndArgs, description) {\n    if (typeof enableOrNameAndArgs === 'boolean') {\n      this._addImplicitHelpCommand = enableOrNameAndArgs;\n      return this;\n    }\n\n    enableOrNameAndArgs = enableOrNameAndArgs ?? 'help [command]';\n    const [, helpName, helpArgs] = enableOrNameAndArgs.match(/([^ ]+) *(.*)/);\n    const helpDescription = description ?? 'display help for command';\n\n    const helpCommand = this.createCommand(helpName);\n    helpCommand.helpOption(false);\n    if (helpArgs) helpCommand.arguments(helpArgs);\n    if (helpDescription) helpCommand.description(helpDescription);\n\n    this._addImplicitHelpCommand = true;\n    this._helpCommand = helpCommand;\n\n    return this;\n  }\n\n  /**\n   * Add prepared custom help command.\n   *\n   * @param {(Command|string|boolean)} helpCommand - custom help command, or deprecated enableOrNameAndArgs as for `.helpCommand()`\n   * @param {string} [deprecatedDescription] - deprecated custom description used with custom name only\n   * @return {Command} `this` command for chaining\n   */\n  addHelpCommand(helpCommand, deprecatedDescription) {\n    // If not passed an object, call through to helpCommand for backwards compatibility,\n    // as addHelpCommand was originally used like helpCommand is now.\n    if (typeof helpCommand !== 'object') {\n      this.helpCommand(helpCommand, deprecatedDescription);\n      return this;\n    }\n\n    this._addImplicitHelpCommand = true;\n    this._helpCommand = helpCommand;\n    return this;\n  }\n\n  /**\n   * Lazy create help command.\n   *\n   * @return {(Command|null)}\n   * @package\n   */\n  _getHelpCommand() {\n    const hasImplicitHelpCommand = this._addImplicitHelpCommand ??\n      (this.commands.length && !this._actionHandler && !this._findCommand('help'));\n\n    if (hasImplicitHelpCommand) {\n      if (this._helpCommand === undefined) {\n        this.helpCommand(undefined, undefined); // use default name and description\n      }\n      return this._helpCommand;\n    }\n    return null;\n  }\n\n  /**\n   * Add hook for life cycle event.\n   *\n   * @param {string} event\n   * @param {Function} listener\n   * @return {Command} `this` command for chaining\n   */\n\n  hook(event, listener) {\n    const allowedValues = ['preSubcommand', 'preAction', 'postAction'];\n    if (!allowedValues.includes(event)) {\n      throw new Error(`Unexpected value for event passed to hook : '${event}'.\nExpecting one of '${allowedValues.join(\"', '\")}'`);\n    }\n    if (this._lifeCycleHooks[event]) {\n      this._lifeCycleHooks[event].push(listener);\n    } else {\n      this._lifeCycleHooks[event] = [listener];\n    }\n    return this;\n  }\n\n  /**\n   * Register callback to use as replacement for calling process.exit.\n   *\n   * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing\n   * @return {Command} `this` command for chaining\n   */\n\n  exitOverride(fn) {\n    if (fn) {\n      this._exitCallback = fn;\n    } else {\n      this._exitCallback = (err) => {\n        if (err.code !== 'commander.executeSubCommandAsync') {\n          throw err;\n        } else {\n          // Async callback from spawn events, not useful to throw.\n        }\n      };\n    }\n    return this;\n  }\n\n  /**\n   * Call process.exit, and _exitCallback if defined.\n   *\n   * @param {number} exitCode exit code for using with process.exit\n   * @param {string} code an id string representing the error\n   * @param {string} message human-readable description of the error\n   * @return never\n   * @private\n   */\n\n  _exit(exitCode, code, message) {\n    if (this._exitCallback) {\n      this._exitCallback(new CommanderError(exitCode, code, message));\n      // Expecting this line is not reached.\n    }\n    process.exit(exitCode);\n  }\n\n  /**\n   * Register callback `fn` for the command.\n   *\n   * @example\n   * program\n   *   .command('serve')\n   *   .description('start service')\n   *   .action(function() {\n   *      // do work here\n   *   });\n   *\n   * @param {Function} fn\n   * @return {Command} `this` command for chaining\n   */\n\n  action(fn) {\n    const listener = (args) => {\n      // The .action callback takes an extra parameter which is the command or options.\n      const expectedArgsCount = this.registeredArguments.length;\n      const actionArgs = args.slice(0, expectedArgsCount);\n      if (this._storeOptionsAsProperties) {\n        actionArgs[expectedArgsCount] = this; // backwards compatible \"options\"\n      } else {\n        actionArgs[expectedArgsCount] = this.opts();\n      }\n      actionArgs.push(this);\n\n      return fn.apply(this, actionArgs);\n    };\n    this._actionHandler = listener;\n    return this;\n  }\n\n  /**\n   * Factory routine to create a new unattached option.\n   *\n   * See .option() for creating an attached option, which uses this routine to\n   * create the option. You can override createOption to return a custom option.\n   *\n   * @param {string} flags\n   * @param {string} [description]\n   * @return {Option} new option\n   */\n\n  createOption(flags, description) {\n    return new Option(flags, description);\n  }\n\n  /**\n   * Wrap parseArgs to catch 'commander.invalidArgument'.\n   *\n   * @param {(Option | Argument)} target\n   * @param {string} value\n   * @param {*} previous\n   * @param {string} invalidArgumentMessage\n   * @private\n   */\n\n  _callParseArg(target, value, previous, invalidArgumentMessage) {\n    try {\n      return target.parseArg(value, previous);\n    } catch (err) {\n      if (err.code === 'commander.invalidArgument') {\n        const message = `${invalidArgumentMessage} ${err.message}`;\n        this.error(message, { exitCode: err.exitCode, code: err.code });\n      }\n      throw err;\n    }\n  }\n\n  /**\n   * Check for option flag conflicts.\n   * Register option if no conflicts found, or throw on conflict.\n   *\n   * @param {Option} option\n   * @api private\n   */\n\n  _registerOption(option) {\n    const matchingOption = (option.short && this._findOption(option.short)) ||\n      (option.long && this._findOption(option.long));\n    if (matchingOption) {\n      const matchingFlag = (option.long && this._findOption(option.long)) ? option.long : option.short;\n      throw new Error(`Cannot add option '${option.flags}'${this._name && ` to command '${this._name}'`} due to conflicting flag '${matchingFlag}'\n-  already used by option '${matchingOption.flags}'`);\n    }\n\n    this.options.push(option);\n  }\n\n  /**\n   * Check for command name and alias conflicts with existing commands.\n   * Register command if no conflicts found, or throw on conflict.\n   *\n   * @param {Command} command\n   * @api private\n   */\n\n  _registerCommand(command) {\n    const knownBy = (cmd) => {\n      return [cmd.name()].concat(cmd.aliases());\n    };\n\n    const alreadyUsed = knownBy(command).find((name) => this._findCommand(name));\n    if (alreadyUsed) {\n      const existingCmd = knownBy(this._findCommand(alreadyUsed)).join('|');\n      const newCmd = knownBy(command).join('|');\n      throw new Error(`cannot add command '${newCmd}' as already have command '${existingCmd}'`);\n    }\n\n    this.commands.push(command);\n  }\n\n  /**\n   * Add an option.\n   *\n   * @param {Option} option\n   * @return {Command} `this` command for chaining\n   */\n  addOption(option) {\n    this._registerOption(option);\n\n    const oname = option.name();\n    const name = option.attributeName();\n\n    // store default value\n    if (option.negate) {\n      // --no-foo is special and defaults foo to true, unless a --foo option is already defined\n      const positiveLongFlag = option.long.replace(/^--no-/, '--');\n      if (!this._findOption(positiveLongFlag)) {\n        this.setOptionValueWithSource(name, option.defaultValue === undefined ? true : option.defaultValue, 'default');\n      }\n    } else if (option.defaultValue !== undefined) {\n      this.setOptionValueWithSource(name, option.defaultValue, 'default');\n    }\n\n    // handler for cli and env supplied values\n    const handleOptionValue = (val, invalidValueMessage, valueSource) => {\n      // val is null for optional option used without an optional-argument.\n      // val is undefined for boolean and negated option.\n      if (val == null && option.presetArg !== undefined) {\n        val = option.presetArg;\n      }\n\n      // custom processing\n      const oldValue = this.getOptionValue(name);\n      if (val !== null && option.parseArg) {\n        val = this._callParseArg(option, val, oldValue, invalidValueMessage);\n      } else if (val !== null && option.variadic) {\n        val = option._concatValue(val, oldValue);\n      }\n\n      // Fill-in appropriate missing values. Long winded but easy to follow.\n      if (val == null) {\n        if (option.negate) {\n          val = false;\n        } else if (option.isBoolean() || option.optional) {\n          val = true;\n        } else {\n          val = ''; // not normal, parseArg might have failed or be a mock function for testing\n        }\n      }\n      this.setOptionValueWithSource(name, val, valueSource);\n    };\n\n    this.on('option:' + oname, (val) => {\n      const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;\n      handleOptionValue(val, invalidValueMessage, 'cli');\n    });\n\n    if (option.envVar) {\n      this.on('optionEnv:' + oname, (val) => {\n        const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;\n        handleOptionValue(val, invalidValueMessage, 'env');\n      });\n    }\n\n    return this;\n  }\n\n  /**\n   * Internal implementation shared by .option() and .requiredOption()\n   *\n   * @private\n   */\n  _optionEx(config, flags, description, fn, defaultValue) {\n    if (typeof flags === 'object' && flags instanceof Option) {\n      throw new Error('To add an Option object use addOption() instead of option() or requiredOption()');\n    }\n    const option = this.createOption(flags, description);\n    option.makeOptionMandatory(!!config.mandatory);\n    if (typeof fn === 'function') {\n      option.default(defaultValue).argParser(fn);\n    } else if (fn instanceof RegExp) {\n      // deprecated\n      const regex = fn;\n      fn = (val, def) => {\n        const m = regex.exec(val);\n        return m ? m[0] : def;\n      };\n      option.default(defaultValue).argParser(fn);\n    } else {\n      option.default(fn);\n    }\n\n    return this.addOption(option);\n  }\n\n  /**\n   * Define option with `flags`, `description`, and optional argument parsing function or `defaultValue` or both.\n   *\n   * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space. A required\n   * option-argument is indicated by `<>` and an optional option-argument by `[]`.\n   *\n   * See the README for more details, and see also addOption() and requiredOption().\n   *\n   * @example\n   * program\n   *     .option('-p, --pepper', 'add pepper')\n   *     .option('-p, --pizza-type <TYPE>', 'type of pizza') // required option-argument\n   *     .option('-c, --cheese [CHEESE]', 'add extra cheese', 'mozzarella') // optional option-argument with default\n   *     .option('-t, --tip <VALUE>', 'add tip to purchase cost', parseFloat) // custom parse function\n   *\n   * @param {string} flags\n   * @param {string} [description]\n   * @param {(Function|*)} [parseArg] - custom option processing function or default value\n   * @param {*} [defaultValue]\n   * @return {Command} `this` command for chaining\n   */\n\n  option(flags, description, parseArg, defaultValue) {\n    return this._optionEx({}, flags, description, parseArg, defaultValue);\n  }\n\n  /**\n  * Add a required option which must have a value after parsing. This usually means\n  * the option must be specified on the command line. (Otherwise the same as .option().)\n  *\n  * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.\n  *\n  * @param {string} flags\n  * @param {string} [description]\n  * @param {(Function|*)} [parseArg] - custom option processing function or default value\n  * @param {*} [defaultValue]\n  * @return {Command} `this` command for chaining\n  */\n\n  requiredOption(flags, description, parseArg, defaultValue) {\n    return this._optionEx({ mandatory: true }, flags, description, parseArg, defaultValue);\n  }\n\n  /**\n   * Alter parsing of short flags with optional values.\n   *\n   * @example\n   * // for `.option('-f,--flag [value]'):\n   * program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour\n   * program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`\n   *\n   * @param {boolean} [combine=true] - if `true` or omitted, an optional value can be specified directly after the flag.\n   */\n  combineFlagAndOptionalValue(combine = true) {\n    this._combineFlagAndOptionalValue = !!combine;\n    return this;\n  }\n\n  /**\n   * Allow unknown options on the command line.\n   *\n   * @param {boolean} [allowUnknown=true] - if `true` or omitted, no error will be thrown\n   * for unknown options.\n   */\n  allowUnknownOption(allowUnknown = true) {\n    this._allowUnknownOption = !!allowUnknown;\n    return this;\n  }\n\n  /**\n   * Allow excess command-arguments on the command line. Pass false to make excess arguments an error.\n   *\n   * @param {boolean} [allowExcess=true] - if `true` or omitted, no error will be thrown\n   * for excess arguments.\n   */\n  allowExcessArguments(allowExcess = true) {\n    this._allowExcessArguments = !!allowExcess;\n    return this;\n  }\n\n  /**\n   * Enable positional options. Positional means global options are specified before subcommands which lets\n   * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.\n   * The default behaviour is non-positional and global options may appear anywhere on the command line.\n   *\n   * @param {boolean} [positional=true]\n   */\n  enablePositionalOptions(positional = true) {\n    this._enablePositionalOptions = !!positional;\n    return this;\n  }\n\n  /**\n   * Pass through options that come after command-arguments rather than treat them as command-options,\n   * so actual command-options come before command-arguments. Turning this on for a subcommand requires\n   * positional options to have been enabled on the program (parent commands).\n   * The default behaviour is non-positional and options may appear before or after command-arguments.\n   *\n   * @param {boolean} [passThrough=true]\n   * for unknown options.\n   */\n  passThroughOptions(passThrough = true) {\n    this._passThroughOptions = !!passThrough;\n    this._checkForBrokenPassThrough();\n    return this;\n  }\n\n  /**\n   * @private\n   */\n\n  _checkForBrokenPassThrough() {\n    if (this.parent && this._passThroughOptions && !this.parent._enablePositionalOptions) {\n      throw new Error(`passThroughOptions cannot be used for '${this._name}' without turning on enablePositionalOptions for parent command(s)`);\n    }\n  }\n\n  /**\n    * Whether to store option values as properties on command object,\n    * or store separately (specify false). In both cases the option values can be accessed using .opts().\n    *\n    * @param {boolean} [storeAsProperties=true]\n    * @return {Command} `this` command for chaining\n    */\n\n  storeOptionsAsProperties(storeAsProperties = true) {\n    if (this.options.length) {\n      throw new Error('call .storeOptionsAsProperties() before adding options');\n    }\n    if (Object.keys(this._optionValues).length) {\n      throw new Error('call .storeOptionsAsProperties() before setting option values');\n    }\n    this._storeOptionsAsProperties = !!storeAsProperties;\n    return this;\n  }\n\n  /**\n   * Retrieve option value.\n   *\n   * @param {string} key\n   * @return {Object} value\n   */\n\n  getOptionValue(key) {\n    if (this._storeOptionsAsProperties) {\n      return this[key];\n    }\n    return this._optionValues[key];\n  }\n\n  /**\n   * Store option value.\n   *\n   * @param {string} key\n   * @param {Object} value\n   * @return {Command} `this` command for chaining\n   */\n\n  setOptionValue(key, value) {\n    return this.setOptionValueWithSource(key, value, undefined);\n  }\n\n  /**\n    * Store option value and where the value came from.\n    *\n    * @param {string} key\n    * @param {Object} value\n    * @param {string} source - expected values are default/config/env/cli/implied\n    * @return {Command} `this` command for chaining\n    */\n\n  setOptionValueWithSource(key, value, source) {\n    if (this._storeOptionsAsProperties) {\n      this[key] = value;\n    } else {\n      this._optionValues[key] = value;\n    }\n    this._optionValueSources[key] = source;\n    return this;\n  }\n\n  /**\n    * Get source of option value.\n    * Expected values are default | config | env | cli | implied\n    *\n    * @param {string} key\n    * @return {string}\n    */\n\n  getOptionValueSource(key) {\n    return this._optionValueSources[key];\n  }\n\n  /**\n    * Get source of option value. See also .optsWithGlobals().\n    * Expected values are default | config | env | cli | implied\n    *\n    * @param {string} key\n    * @return {string}\n    */\n\n  getOptionValueSourceWithGlobals(key) {\n    // global overwrites local, like optsWithGlobals\n    let source;\n    this._getCommandAndAncestors().forEach((cmd) => {\n      if (cmd.getOptionValueSource(key) !== undefined) {\n        source = cmd.getOptionValueSource(key);\n      }\n    });\n    return source;\n  }\n\n  /**\n   * Get user arguments from implied or explicit arguments.\n   * Side-effects: set _scriptPath if args included script. Used for default program name, and subcommand searches.\n   *\n   * @private\n   */\n\n  _prepareUserArgs(argv, parseOptions) {\n    if (argv !== undefined && !Array.isArray(argv)) {\n      throw new Error('first parameter to parse must be array or undefined');\n    }\n    parseOptions = parseOptions || {};\n\n    // Default to using process.argv\n    if (argv === undefined) {\n      argv = process.argv;\n      // @ts-ignore: unknown property\n      if (process.versions && process.versions.electron) {\n        parseOptions.from = 'electron';\n      }\n    }\n    this.rawArgs = argv.slice();\n\n    // make it a little easier for callers by supporting various argv conventions\n    let userArgs;\n    switch (parseOptions.from) {\n      case undefined:\n      case 'node':\n        this._scriptPath = argv[1];\n        userArgs = argv.slice(2);\n        break;\n      case 'electron':\n        // @ts-ignore: unknown property\n        if (process.defaultApp) {\n          this._scriptPath = argv[1];\n          userArgs = argv.slice(2);\n        } else {\n          userArgs = argv.slice(1);\n        }\n        break;\n      case 'user':\n        userArgs = argv.slice(0);\n        break;\n      default:\n        throw new Error(`unexpected parse option { from: '${parseOptions.from}' }`);\n    }\n\n    // Find default name for program from arguments.\n    if (!this._name && this._scriptPath) this.nameFromFilename(this._scriptPath);\n    this._name = this._name || 'program';\n\n    return userArgs;\n  }\n\n  /**\n   * Parse `argv`, setting options and invoking commands when defined.\n   *\n   * The default expectation is that the arguments are from node and have the application as argv[0]\n   * and the script being run in argv[1], with user parameters after that.\n   *\n   * @example\n   * program.parse(process.argv);\n   * program.parse(); // implicitly use process.argv and auto-detect node vs electron conventions\n   * program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]\n   *\n   * @param {string[]} [argv] - optional, defaults to process.argv\n   * @param {Object} [parseOptions] - optionally specify style of options with from: node/user/electron\n   * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'\n   * @return {Command} `this` command for chaining\n   */\n\n  parse(argv, parseOptions) {\n    const userArgs = this._prepareUserArgs(argv, parseOptions);\n    this._parseCommand([], userArgs);\n\n    return this;\n  }\n\n  /**\n   * Parse `argv`, setting options and invoking commands when defined.\n   *\n   * Use parseAsync instead of parse if any of your action handlers are async. Returns a Promise.\n   *\n   * The default expectation is that the arguments are from node and have the application as argv[0]\n   * and the script being run in argv[1], with user parameters after that.\n   *\n   * @example\n   * await program.parseAsync(process.argv);\n   * await program.parseAsync(); // implicitly use process.argv and auto-detect node vs electron conventions\n   * await program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]\n   *\n   * @param {string[]} [argv]\n   * @param {Object} [parseOptions]\n   * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'\n   * @return {Promise}\n   */\n\n  async parseAsync(argv, parseOptions) {\n    const userArgs = this._prepareUserArgs(argv, parseOptions);\n    await this._parseCommand([], userArgs);\n\n    return this;\n  }\n\n  /**\n   * Execute a sub-command executable.\n   *\n   * @private\n   */\n\n  _executeSubCommand(subcommand, args) {\n    args = args.slice();\n    let launchWithNode = false; // Use node for source targets so do not need to get permissions correct, and on Windows.\n    const sourceExt = ['.js', '.ts', '.tsx', '.mjs', '.cjs'];\n\n    function findFile(baseDir, baseName) {\n      // Look for specified file\n      const localBin = path.resolve(baseDir, baseName);\n      if (fs.existsSync(localBin)) return localBin;\n\n      // Stop looking if candidate already has an expected extension.\n      if (sourceExt.includes(path.extname(baseName))) return undefined;\n\n      // Try all the extensions.\n      const foundExt = sourceExt.find(ext => fs.existsSync(`${localBin}${ext}`));\n      if (foundExt) return `${localBin}${foundExt}`;\n\n      return undefined;\n    }\n\n    // Not checking for help first. Unlikely to have mandatory and executable, and can't robustly test for help flags in external command.\n    this._checkForMissingMandatoryOptions();\n    this._checkForConflictingOptions();\n\n    // executableFile and executableDir might be full path, or just a name\n    let executableFile = subcommand._executableFile || `${this._name}-${subcommand._name}`;\n    let executableDir = this._executableDir || '';\n    if (this._scriptPath) {\n      let resolvedScriptPath; // resolve possible symlink for installed npm binary\n      try {\n        resolvedScriptPath = fs.realpathSync(this._scriptPath);\n      } catch (err) {\n        resolvedScriptPath = this._scriptPath;\n      }\n      executableDir = path.resolve(path.dirname(resolvedScriptPath), executableDir);\n    }\n\n    // Look for a local file in preference to a command in PATH.\n    if (executableDir) {\n      let localFile = findFile(executableDir, executableFile);\n\n      // Legacy search using prefix of script name instead of command name\n      if (!localFile && !subcommand._executableFile && this._scriptPath) {\n        const legacyName = path.basename(this._scriptPath, path.extname(this._scriptPath));\n        if (legacyName !== this._name) {\n          localFile = findFile(executableDir, `${legacyName}-${subcommand._name}`);\n        }\n      }\n      executableFile = localFile || executableFile;\n    }\n\n    launchWithNode = sourceExt.includes(path.extname(executableFile));\n\n    let proc;\n    if (process.platform !== 'win32') {\n      if (launchWithNode) {\n        args.unshift(executableFile);\n        // add executable arguments to spawn\n        args = incrementNodeInspectorPort(process.execArgv).concat(args);\n\n        proc = childProcess.spawn(process.argv[0], args, { stdio: 'inherit' });\n      } else {\n        proc = childProcess.spawn(executableFile, args, { stdio: 'inherit' });\n      }\n    } else {\n      args.unshift(executableFile);\n      // add executable arguments to spawn\n      args = incrementNodeInspectorPort(process.execArgv).concat(args);\n      proc = childProcess.spawn(process.execPath, args, { stdio: 'inherit' });\n    }\n\n    if (!proc.killed) { // testing mainly to avoid leak warnings during unit tests with mocked spawn\n      const signals = ['SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGINT', 'SIGHUP'];\n      signals.forEach((signal) => {\n        // @ts-ignore\n        process.on(signal, () => {\n          if (proc.killed === false && proc.exitCode === null) {\n            proc.kill(signal);\n          }\n        });\n      });\n    }\n\n    // By default terminate process when spawned process terminates.\n    const exitCallback = this._exitCallback;\n    proc.on('close', (code, _signal) => {\n      code = code ?? 1; // code is null if spawned process terminated due to a signal\n      if (!exitCallback) {\n        process.exit(code);\n      } else {\n        exitCallback(new CommanderError(code, 'commander.executeSubCommandAsync', '(close)'));\n      }\n    });\n    proc.on('error', (err) => {\n      // @ts-ignore\n      if (err.code === 'ENOENT') {\n        const executableDirMessage = executableDir\n          ? `searched for local subcommand relative to directory '${executableDir}'`\n          : 'no directory for search for local subcommand, use .executableDir() to supply a custom directory';\n        const executableMissing = `'${executableFile}' does not exist\n - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead\n - if the default executable name is not suitable, use the executableFile option to supply a custom name or path\n - ${executableDirMessage}`;\n        throw new Error(executableMissing);\n      // @ts-ignore\n      } else if (err.code === 'EACCES') {\n        throw new Error(`'${executableFile}' not executable`);\n      }\n      if (!exitCallback) {\n        process.exit(1);\n      } else {\n        const wrappedError = new CommanderError(1, 'commander.executeSubCommandAsync', '(error)');\n        wrappedError.nestedError = err;\n        exitCallback(wrappedError);\n      }\n    });\n\n    // Store the reference to the child process\n    this.runningCommand = proc;\n  }\n\n  /**\n   * @private\n   */\n\n  _dispatchSubcommand(commandName, operands, unknown) {\n    const subCommand = this._findCommand(commandName);\n    if (!subCommand) this.help({ error: true });\n\n    let promiseChain;\n    promiseChain = this._chainOrCallSubCommandHook(promiseChain, subCommand, 'preSubcommand');\n    promiseChain = this._chainOrCall(promiseChain, () => {\n      if (subCommand._executableHandler) {\n        this._executeSubCommand(subCommand, operands.concat(unknown));\n      } else {\n        return subCommand._parseCommand(operands, unknown);\n      }\n    });\n    return promiseChain;\n  }\n\n  /**\n   * Invoke help directly if possible, or dispatch if necessary.\n   * e.g. help foo\n   *\n   * @private\n   */\n\n  _dispatchHelpCommand(subcommandName) {\n    if (!subcommandName) {\n      this.help();\n    }\n    const subCommand = this._findCommand(subcommandName);\n    if (subCommand && !subCommand._executableHandler) {\n      subCommand.help();\n    }\n\n    // Fallback to parsing the help flag to invoke the help.\n    return this._dispatchSubcommand(subcommandName, [], [\n      this._getHelpOption()?.long ?? this._getHelpOption()?.short ?? '--help'\n    ]);\n  }\n\n  /**\n   * Check this.args against expected this.registeredArguments.\n   *\n   * @private\n   */\n\n  _checkNumberOfArguments() {\n    // too few\n    this.registeredArguments.forEach((arg, i) => {\n      if (arg.required && this.args[i] == null) {\n        this.missingArgument(arg.name());\n      }\n    });\n    // too many\n    if (this.registeredArguments.length > 0 && this.registeredArguments[this.registeredArguments.length - 1].variadic) {\n      return;\n    }\n    if (this.args.length > this.registeredArguments.length) {\n      this._excessArguments(this.args);\n    }\n  }\n\n  /**\n   * Process this.args using this.registeredArguments and save as this.processedArgs!\n   *\n   * @private\n   */\n\n  _processArguments() {\n    const myParseArg = (argument, value, previous) => {\n      // Extra processing for nice error message on parsing failure.\n      let parsedValue = value;\n      if (value !== null && argument.parseArg) {\n        const invalidValueMessage = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'.`;\n        parsedValue = this._callParseArg(argument, value, previous, invalidValueMessage);\n      }\n      return parsedValue;\n    };\n\n    this._checkNumberOfArguments();\n\n    const processedArgs = [];\n    this.registeredArguments.forEach((declaredArg, index) => {\n      let value = declaredArg.defaultValue;\n      if (declaredArg.variadic) {\n        // Collect together remaining arguments for passing together as an array.\n        if (index < this.args.length) {\n          value = this.args.slice(index);\n          if (declaredArg.parseArg) {\n            value = value.reduce((processed, v) => {\n              return myParseArg(declaredArg, v, processed);\n            }, declaredArg.defaultValue);\n          }\n        } else if (value === undefined) {\n          value = [];\n        }\n      } else if (index < this.args.length) {\n        value = this.args[index];\n        if (declaredArg.parseArg) {\n          value = myParseArg(declaredArg, value, declaredArg.defaultValue);\n        }\n      }\n      processedArgs[index] = value;\n    });\n    this.processedArgs = processedArgs;\n  }\n\n  /**\n   * Once we have a promise we chain, but call synchronously until then.\n   *\n   * @param {(Promise|undefined)} promise\n   * @param {Function} fn\n   * @return {(Promise|undefined)}\n   * @private\n   */\n\n  _chainOrCall(promise, fn) {\n    // thenable\n    if (promise && promise.then && typeof promise.then === 'function') {\n      // already have a promise, chain callback\n      return promise.then(() => fn());\n    }\n    // callback might return a promise\n    return fn();\n  }\n\n  /**\n   *\n   * @param {(Promise|undefined)} promise\n   * @param {string} event\n   * @return {(Promise|undefined)}\n   * @private\n   */\n\n  _chainOrCallHooks(promise, event) {\n    let result = promise;\n    const hooks = [];\n    this._getCommandAndAncestors()\n      .reverse()\n      .filter(cmd => cmd._lifeCycleHooks[event] !== undefined)\n      .forEach(hookedCommand => {\n        hookedCommand._lifeCycleHooks[event].forEach((callback) => {\n          hooks.push({ hookedCommand, callback });\n        });\n      });\n    if (event === 'postAction') {\n      hooks.reverse();\n    }\n\n    hooks.forEach((hookDetail) => {\n      result = this._chainOrCall(result, () => {\n        return hookDetail.callback(hookDetail.hookedCommand, this);\n      });\n    });\n    return result;\n  }\n\n  /**\n   *\n   * @param {(Promise|undefined)} promise\n   * @param {Command} subCommand\n   * @param {string} event\n   * @return {(Promise|undefined)}\n   * @private\n   */\n\n  _chainOrCallSubCommandHook(promise, subCommand, event) {\n    let result = promise;\n    if (this._lifeCycleHooks[event] !== undefined) {\n      this._lifeCycleHooks[event].forEach((hook) => {\n        result = this._chainOrCall(result, () => {\n          return hook(this, subCommand);\n        });\n      });\n    }\n    return result;\n  }\n\n  /**\n   * Process arguments in context of this command.\n   * Returns action result, in case it is a promise.\n   *\n   * @private\n   */\n\n  _parseCommand(operands, unknown) {\n    const parsed = this.parseOptions(unknown);\n    this._parseOptionsEnv(); // after cli, so parseArg not called on both cli and env\n    this._parseOptionsImplied();\n    operands = operands.concat(parsed.operands);\n    unknown = parsed.unknown;\n    this.args = operands.concat(unknown);\n\n    if (operands && this._findCommand(operands[0])) {\n      return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);\n    }\n    if (this._getHelpCommand() && operands[0] === this._getHelpCommand().name()) {\n      return this._dispatchHelpCommand(operands[1]);\n    }\n    if (this._defaultCommandName) {\n      this._outputHelpIfRequested(unknown); // Run the help for default command from parent rather than passing to default command\n      return this._dispatchSubcommand(this._defaultCommandName, operands, unknown);\n    }\n    if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {\n      // probably missing subcommand and no handler, user needs help (and exit)\n      this.help({ error: true });\n    }\n\n    this._outputHelpIfRequested(parsed.unknown);\n    this._checkForMissingMandatoryOptions();\n    this._checkForConflictingOptions();\n\n    // We do not always call this check to avoid masking a \"better\" error, like unknown command.\n    const checkForUnknownOptions = () => {\n      if (parsed.unknown.length > 0) {\n        this.unknownOption(parsed.unknown[0]);\n      }\n    };\n\n    const commandEvent = `command:${this.name()}`;\n    if (this._actionHandler) {\n      checkForUnknownOptions();\n      this._processArguments();\n\n      let promiseChain;\n      promiseChain = this._chainOrCallHooks(promiseChain, 'preAction');\n      promiseChain = this._chainOrCall(promiseChain, () => this._actionHandler(this.processedArgs));\n      if (this.parent) {\n        promiseChain = this._chainOrCall(promiseChain, () => {\n          this.parent.emit(commandEvent, operands, unknown); // legacy\n        });\n      }\n      promiseChain = this._chainOrCallHooks(promiseChain, 'postAction');\n      return promiseChain;\n    }\n    if (this.parent && this.parent.listenerCount(commandEvent)) {\n      checkForUnknownOptions();\n      this._processArguments();\n      this.parent.emit(commandEvent, operands, unknown); // legacy\n    } else if (operands.length) {\n      if (this._findCommand('*')) { // legacy default command\n        return this._dispatchSubcommand('*', operands, unknown);\n      }\n      if (this.listenerCount('command:*')) {\n        // skip option check, emit event for possible misspelling suggestion\n        this.emit('command:*', operands, unknown);\n      } else if (this.commands.length) {\n        this.unknownCommand();\n      } else {\n        checkForUnknownOptions();\n        this._processArguments();\n      }\n    } else if (this.commands.length) {\n      checkForUnknownOptions();\n      // This command has subcommands and nothing hooked up at this level, so display help (and exit).\n      this.help({ error: true });\n    } else {\n      checkForUnknownOptions();\n      this._processArguments();\n      // fall through for caller to handle after calling .parse()\n    }\n  }\n\n  /**\n   * Find matching command.\n   *\n   * @private\n   */\n  _findCommand(name) {\n    if (!name) return undefined;\n    return this.commands.find(cmd => cmd._name === name || cmd._aliases.includes(name));\n  }\n\n  /**\n   * Return an option matching `arg` if any.\n   *\n   * @param {string} arg\n   * @return {Option}\n   * @package internal use only\n   */\n\n  _findOption(arg) {\n    return this.options.find(option => option.is(arg));\n  }\n\n  /**\n   * Display an error message if a mandatory option does not have a value.\n   * Called after checking for help flags in leaf subcommand.\n   *\n   * @private\n   */\n\n  _checkForMissingMandatoryOptions() {\n    // Walk up hierarchy so can call in subcommand after checking for displaying help.\n    this._getCommandAndAncestors().forEach((cmd) => {\n      cmd.options.forEach((anOption) => {\n        if (anOption.mandatory && (cmd.getOptionValue(anOption.attributeName()) === undefined)) {\n          cmd.missingMandatoryOptionValue(anOption);\n        }\n      });\n    });\n  }\n\n  /**\n   * Display an error message if conflicting options are used together in this.\n   *\n   * @private\n   */\n  _checkForConflictingLocalOptions() {\n    const definedNonDefaultOptions = this.options.filter(\n      (option) => {\n        const optionKey = option.attributeName();\n        if (this.getOptionValue(optionKey) === undefined) {\n          return false;\n        }\n        return this.getOptionValueSource(optionKey) !== 'default';\n      }\n    );\n\n    const optionsWithConflicting = definedNonDefaultOptions.filter(\n      (option) => option.conflictsWith.length > 0\n    );\n\n    optionsWithConflicting.forEach((option) => {\n      const conflictingAndDefined = definedNonDefaultOptions.find((defined) =>\n        option.conflictsWith.includes(defined.attributeName())\n      );\n      if (conflictingAndDefined) {\n        this._conflictingOption(option, conflictingAndDefined);\n      }\n    });\n  }\n\n  /**\n   * Display an error message if conflicting options are used together.\n   * Called after checking for help flags in leaf subcommand.\n   *\n   * @private\n   */\n  _checkForConflictingOptions() {\n    // Walk up hierarchy so can call in subcommand after checking for displaying help.\n    this._getCommandAndAncestors().forEach((cmd) => {\n      cmd._checkForConflictingLocalOptions();\n    });\n  }\n\n  /**\n   * Parse options from `argv` removing known options,\n   * and return argv split into operands and unknown arguments.\n   *\n   * Examples:\n   *\n   *     argv => operands, unknown\n   *     --known kkk op => [op], []\n   *     op --known kkk => [op], []\n   *     sub --unknown uuu op => [sub], [--unknown uuu op]\n   *     sub -- --unknown uuu op => [sub --unknown uuu op], []\n   *\n   * @param {string[]} argv\n   * @return {{operands: string[], unknown: string[]}}\n   */\n\n  parseOptions(argv) {\n    const operands = []; // operands, not options or values\n    const unknown = []; // first unknown option and remaining unknown args\n    let dest = operands;\n    const args = argv.slice();\n\n    function maybeOption(arg) {\n      return arg.length > 1 && arg[0] === '-';\n    }\n\n    // parse options\n    let activeVariadicOption = null;\n    while (args.length) {\n      const arg = args.shift();\n\n      // literal\n      if (arg === '--') {\n        if (dest === unknown) dest.push(arg);\n        dest.push(...args);\n        break;\n      }\n\n      if (activeVariadicOption && !maybeOption(arg)) {\n        this.emit(`option:${activeVariadicOption.name()}`, arg);\n        continue;\n      }\n      activeVariadicOption = null;\n\n      if (maybeOption(arg)) {\n        const option = this._findOption(arg);\n        // recognised option, call listener to assign value with possible custom processing\n        if (option) {\n          if (option.required) {\n            const value = args.shift();\n            if (value === undefined) this.optionMissingArgument(option);\n            this.emit(`option:${option.name()}`, value);\n          } else if (option.optional) {\n            let value = null;\n            // historical behaviour is optional value is following arg unless an option\n            if (args.length > 0 && !maybeOption(args[0])) {\n              value = args.shift();\n            }\n            this.emit(`option:${option.name()}`, value);\n          } else { // boolean flag\n            this.emit(`option:${option.name()}`);\n          }\n          activeVariadicOption = option.variadic ? option : null;\n          continue;\n        }\n      }\n\n      // Look for combo options following single dash, eat first one if known.\n      if (arg.length > 2 && arg[0] === '-' && arg[1] !== '-') {\n        const option = this._findOption(`-${arg[1]}`);\n        if (option) {\n          if (option.required || (option.optional && this._combineFlagAndOptionalValue)) {\n            // option with value following in same argument\n            this.emit(`option:${option.name()}`, arg.slice(2));\n          } else {\n            // boolean option, emit and put back remainder of arg for further processing\n            this.emit(`option:${option.name()}`);\n            args.unshift(`-${arg.slice(2)}`);\n          }\n          continue;\n        }\n      }\n\n      // Look for known long flag with value, like --foo=bar\n      if (/^--[^=]+=/.test(arg)) {\n        const index = arg.indexOf('=');\n        const option = this._findOption(arg.slice(0, index));\n        if (option && (option.required || option.optional)) {\n          this.emit(`option:${option.name()}`, arg.slice(index + 1));\n          continue;\n        }\n      }\n\n      // Not a recognised option by this command.\n      // Might be a command-argument, or subcommand option, or unknown option, or help command or option.\n\n      // An unknown option means further arguments also classified as unknown so can be reprocessed by subcommands.\n      if (maybeOption(arg)) {\n        dest = unknown;\n      }\n\n      // If using positionalOptions, stop processing our options at subcommand.\n      if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown.length === 0) {\n        if (this._findCommand(arg)) {\n          operands.push(arg);\n          if (args.length > 0) unknown.push(...args);\n          break;\n        } else if (this._getHelpCommand() && arg === this._getHelpCommand().name()) {\n          operands.push(arg);\n          if (args.length > 0) operands.push(...args);\n          break;\n        } else if (this._defaultCommandName) {\n          unknown.push(arg);\n          if (args.length > 0) unknown.push(...args);\n          break;\n        }\n      }\n\n      // If using passThroughOptions, stop processing options at first command-argument.\n      if (this._passThroughOptions) {\n        dest.push(arg);\n        if (args.length > 0) dest.push(...args);\n        break;\n      }\n\n      // add arg\n      dest.push(arg);\n    }\n\n    return { operands, unknown };\n  }\n\n  /**\n   * Return an object containing local option values as key-value pairs.\n   *\n   * @return {Object}\n   */\n  opts() {\n    if (this._storeOptionsAsProperties) {\n      // Preserve original behaviour so backwards compatible when still using properties\n      const result = {};\n      const len = this.options.length;\n\n      for (let i = 0; i < len; i++) {\n        const key = this.options[i].attributeName();\n        result[key] = key === this._versionOptionName ? this._version : this[key];\n      }\n      return result;\n    }\n\n    return this._optionValues;\n  }\n\n  /**\n   * Return an object containing merged local and global option values as key-value pairs.\n   *\n   * @return {Object}\n   */\n  optsWithGlobals() {\n    // globals overwrite locals\n    return this._getCommandAndAncestors().reduce(\n      (combinedOptions, cmd) => Object.assign(combinedOptions, cmd.opts()),\n      {}\n    );\n  }\n\n  /**\n   * Display error message and exit (or call exitOverride).\n   *\n   * @param {string} message\n   * @param {Object} [errorOptions]\n   * @param {string} [errorOptions.code] - an id string representing the error\n   * @param {number} [errorOptions.exitCode] - used with process.exit\n   */\n  error(message, errorOptions) {\n    // output handling\n    this._outputConfiguration.outputError(`${message}\\n`, this._outputConfiguration.writeErr);\n    if (typeof this._showHelpAfterError === 'string') {\n      this._outputConfiguration.writeErr(`${this._showHelpAfterError}\\n`);\n    } else if (this._showHelpAfterError) {\n      this._outputConfiguration.writeErr('\\n');\n      this.outputHelp({ error: true });\n    }\n\n    // exit handling\n    const config = errorOptions || {};\n    const exitCode = config.exitCode || 1;\n    const code = config.code || 'commander.error';\n    this._exit(exitCode, code, message);\n  }\n\n  /**\n   * Apply any option related environment variables, if option does\n   * not have a value from cli or client code.\n   *\n   * @private\n   */\n  _parseOptionsEnv() {\n    this.options.forEach((option) => {\n      if (option.envVar && option.envVar in process.env) {\n        const optionKey = option.attributeName();\n        // Priority check. Do not overwrite cli or options from unknown source (client-code).\n        if (this.getOptionValue(optionKey) === undefined || ['default', 'config', 'env'].includes(this.getOptionValueSource(optionKey))) {\n          if (option.required || option.optional) { // option can take a value\n            // keep very simple, optional always takes value\n            this.emit(`optionEnv:${option.name()}`, process.env[option.envVar]);\n          } else { // boolean\n            // keep very simple, only care that envVar defined and not the value\n            this.emit(`optionEnv:${option.name()}`);\n          }\n        }\n      }\n    });\n  }\n\n  /**\n   * Apply any implied option values, if option is undefined or default value.\n   *\n   * @private\n   */\n  _parseOptionsImplied() {\n    const dualHelper = new DualOptions(this.options);\n    const hasCustomOptionValue = (optionKey) => {\n      return this.getOptionValue(optionKey) !== undefined && !['default', 'implied'].includes(this.getOptionValueSource(optionKey));\n    };\n    this.options\n      .filter(option => (option.implied !== undefined) &&\n        hasCustomOptionValue(option.attributeName()) &&\n        dualHelper.valueFromOption(this.getOptionValue(option.attributeName()), option))\n      .forEach((option) => {\n        Object.keys(option.implied)\n          .filter(impliedKey => !hasCustomOptionValue(impliedKey))\n          .forEach(impliedKey => {\n            this.setOptionValueWithSource(impliedKey, option.implied[impliedKey], 'implied');\n          });\n      });\n  }\n\n  /**\n   * Argument `name` is missing.\n   *\n   * @param {string} name\n   * @private\n   */\n\n  missingArgument(name) {\n    const message = `error: missing required argument '${name}'`;\n    this.error(message, { code: 'commander.missingArgument' });\n  }\n\n  /**\n   * `Option` is missing an argument.\n   *\n   * @param {Option} option\n   * @private\n   */\n\n  optionMissingArgument(option) {\n    const message = `error: option '${option.flags}' argument missing`;\n    this.error(message, { code: 'commander.optionMissingArgument' });\n  }\n\n  /**\n   * `Option` does not have a value, and is a mandatory option.\n   *\n   * @param {Option} option\n   * @private\n   */\n\n  missingMandatoryOptionValue(option) {\n    const message = `error: required option '${option.flags}' not specified`;\n    this.error(message, { code: 'commander.missingMandatoryOptionValue' });\n  }\n\n  /**\n   * `Option` conflicts with another option.\n   *\n   * @param {Option} option\n   * @param {Option} conflictingOption\n   * @private\n   */\n  _conflictingOption(option, conflictingOption) {\n    // The calling code does not know whether a negated option is the source of the\n    // value, so do some work to take an educated guess.\n    const findBestOptionFromValue = (option) => {\n      const optionKey = option.attributeName();\n      const optionValue = this.getOptionValue(optionKey);\n      const negativeOption = this.options.find(target => target.negate && optionKey === target.attributeName());\n      const positiveOption = this.options.find(target => !target.negate && optionKey === target.attributeName());\n      if (negativeOption && (\n        (negativeOption.presetArg === undefined && optionValue === false) ||\n        (negativeOption.presetArg !== undefined && optionValue === negativeOption.presetArg)\n      )) {\n        return negativeOption;\n      }\n      return positiveOption || option;\n    };\n\n    const getErrorMessage = (option) => {\n      const bestOption = findBestOptionFromValue(option);\n      const optionKey = bestOption.attributeName();\n      const source = this.getOptionValueSource(optionKey);\n      if (source === 'env') {\n        return `environment variable '${bestOption.envVar}'`;\n      }\n      return `option '${bestOption.flags}'`;\n    };\n\n    const message = `error: ${getErrorMessage(option)} cannot be used with ${getErrorMessage(conflictingOption)}`;\n    this.error(message, { code: 'commander.conflictingOption' });\n  }\n\n  /**\n   * Unknown option `flag`.\n   *\n   * @param {string} flag\n   * @private\n   */\n\n  unknownOption(flag) {\n    if (this._allowUnknownOption) return;\n    let suggestion = '';\n\n    if (flag.startsWith('--') && this._showSuggestionAfterError) {\n      // Looping to pick up the global options too\n      let candidateFlags = [];\n      let command = this;\n      do {\n        const moreFlags = command.createHelp().visibleOptions(command)\n          .filter(option => option.long)\n          .map(option => option.long);\n        candidateFlags = candidateFlags.concat(moreFlags);\n        command = command.parent;\n      } while (command && !command._enablePositionalOptions);\n      suggestion = suggestSimilar(flag, candidateFlags);\n    }\n\n    const message = `error: unknown option '${flag}'${suggestion}`;\n    this.error(message, { code: 'commander.unknownOption' });\n  }\n\n  /**\n   * Excess arguments, more than expected.\n   *\n   * @param {string[]} receivedArgs\n   * @private\n   */\n\n  _excessArguments(receivedArgs) {\n    if (this._allowExcessArguments) return;\n\n    const expected = this.registeredArguments.length;\n    const s = (expected === 1) ? '' : 's';\n    const forSubcommand = this.parent ? ` for '${this.name()}'` : '';\n    const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;\n    this.error(message, { code: 'commander.excessArguments' });\n  }\n\n  /**\n   * Unknown command.\n   *\n   * @private\n   */\n\n  unknownCommand() {\n    const unknownName = this.args[0];\n    let suggestion = '';\n\n    if (this._showSuggestionAfterError) {\n      const candidateNames = [];\n      this.createHelp().visibleCommands(this).forEach((command) => {\n        candidateNames.push(command.name());\n        // just visible alias\n        if (command.alias()) candidateNames.push(command.alias());\n      });\n      suggestion = suggestSimilar(unknownName, candidateNames);\n    }\n\n    const message = `error: unknown command '${unknownName}'${suggestion}`;\n    this.error(message, { code: 'commander.unknownCommand' });\n  }\n\n  /**\n   * Get or set the program version.\n   *\n   * This method auto-registers the \"-V, --version\" option which will print the version number.\n   *\n   * You can optionally supply the flags and description to override the defaults.\n   *\n   * @param {string} [str]\n   * @param {string} [flags]\n   * @param {string} [description]\n   * @return {(this | string | undefined)} `this` command for chaining, or version string if no arguments\n   */\n\n  version(str, flags, description) {\n    if (str === undefined) return this._version;\n    this._version = str;\n    flags = flags || '-V, --version';\n    description = description || 'output the version number';\n    const versionOption = this.createOption(flags, description);\n    this._versionOptionName = versionOption.attributeName();\n    this._registerOption(versionOption);\n\n    this.on('option:' + versionOption.name(), () => {\n      this._outputConfiguration.writeOut(`${str}\\n`);\n      this._exit(0, 'commander.version', str);\n    });\n    return this;\n  }\n\n  /**\n   * Set the description.\n   *\n   * @param {string} [str]\n   * @param {Object} [argsDescription]\n   * @return {(string|Command)}\n   */\n  description(str, argsDescription) {\n    if (str === undefined && argsDescription === undefined) return this._description;\n    this._description = str;\n    if (argsDescription) {\n      this._argsDescription = argsDescription;\n    }\n    return this;\n  }\n\n  /**\n   * Set the summary. Used when listed as subcommand of parent.\n   *\n   * @param {string} [str]\n   * @return {(string|Command)}\n   */\n  summary(str) {\n    if (str === undefined) return this._summary;\n    this._summary = str;\n    return this;\n  }\n\n  /**\n   * Set an alias for the command.\n   *\n   * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.\n   *\n   * @param {string} [alias]\n   * @return {(string|Command)}\n   */\n\n  alias(alias) {\n    if (alias === undefined) return this._aliases[0]; // just return first, for backwards compatibility\n\n    /** @type {Command} */\n    let command = this;\n    if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {\n      // assume adding alias for last added executable subcommand, rather than this\n      command = this.commands[this.commands.length - 1];\n    }\n\n    if (alias === command._name) throw new Error('Command alias can\\'t be the same as its name');\n    const matchingCommand = this.parent?._findCommand(alias);\n    if (matchingCommand) {\n      // c.f. _registerCommand\n      const existingCmd = [matchingCommand.name()].concat(matchingCommand.aliases()).join('|');\n      throw new Error(`cannot add alias '${alias}' to command '${this.name()}' as already have command '${existingCmd}'`);\n    }\n\n    command._aliases.push(alias);\n    return this;\n  }\n\n  /**\n   * Set aliases for the command.\n   *\n   * Only the first alias is shown in the auto-generated help.\n   *\n   * @param {string[]} [aliases]\n   * @return {(string[]|Command)}\n   */\n\n  aliases(aliases) {\n    // Getter for the array of aliases is the main reason for having aliases() in addition to alias().\n    if (aliases === undefined) return this._aliases;\n\n    aliases.forEach((alias) => this.alias(alias));\n    return this;\n  }\n\n  /**\n   * Set / get the command usage `str`.\n   *\n   * @param {string} [str]\n   * @return {(string|Command)}\n   */\n\n  usage(str) {\n    if (str === undefined) {\n      if (this._usage) return this._usage;\n\n      const args = this.registeredArguments.map((arg) => {\n        return humanReadableArgName(arg);\n      });\n      return [].concat(\n        (this.options.length || (this._helpOption !== null) ? '[options]' : []),\n        (this.commands.length ? '[command]' : []),\n        (this.registeredArguments.length ? args : [])\n      ).join(' ');\n    }\n\n    this._usage = str;\n    return this;\n  }\n\n  /**\n   * Get or set the name of the command.\n   *\n   * @param {string} [str]\n   * @return {(string|Command)}\n   */\n\n  name(str) {\n    if (str === undefined) return this._name;\n    this._name = str;\n    return this;\n  }\n\n  /**\n   * Set the name of the command from script filename, such as process.argv[1],\n   * or require.main.filename, or __filename.\n   *\n   * (Used internally and public although not documented in README.)\n   *\n   * @example\n   * program.nameFromFilename(require.main.filename);\n   *\n   * @param {string} filename\n   * @return {Command}\n   */\n\n  nameFromFilename(filename) {\n    this._name = path.basename(filename, path.extname(filename));\n\n    return this;\n  }\n\n  /**\n   * Get or set the directory for searching for executable subcommands of this command.\n   *\n   * @example\n   * program.executableDir(__dirname);\n   * // or\n   * program.executableDir('subcommands');\n   *\n   * @param {string} [path]\n   * @return {(string|null|Command)}\n   */\n\n  executableDir(path) {\n    if (path === undefined) return this._executableDir;\n    this._executableDir = path;\n    return this;\n  }\n\n  /**\n   * Return program help documentation.\n   *\n   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout\n   * @return {string}\n   */\n\n  helpInformation(contextOptions) {\n    const helper = this.createHelp();\n    if (helper.helpWidth === undefined) {\n      helper.helpWidth = (contextOptions && contextOptions.error) ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth();\n    }\n    return helper.formatHelp(this, helper);\n  }\n\n  /**\n   * @private\n   */\n\n  _getHelpContext(contextOptions) {\n    contextOptions = contextOptions || {};\n    const context = { error: !!contextOptions.error };\n    let write;\n    if (context.error) {\n      write = (arg) => this._outputConfiguration.writeErr(arg);\n    } else {\n      write = (arg) => this._outputConfiguration.writeOut(arg);\n    }\n    context.write = contextOptions.write || write;\n    context.command = this;\n    return context;\n  }\n\n  /**\n   * Output help information for this command.\n   *\n   * Outputs built-in help, and custom text added using `.addHelpText()`.\n   *\n   * @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout\n   */\n\n  outputHelp(contextOptions) {\n    let deprecatedCallback;\n    if (typeof contextOptions === 'function') {\n      deprecatedCallback = contextOptions;\n      contextOptions = undefined;\n    }\n    const context = this._getHelpContext(contextOptions);\n\n    this._getCommandAndAncestors().reverse().forEach(command => command.emit('beforeAllHelp', context));\n    this.emit('beforeHelp', context);\n\n    let helpInformation = this.helpInformation(context);\n    if (deprecatedCallback) {\n      helpInformation = deprecatedCallback(helpInformation);\n      if (typeof helpInformation !== 'string' && !Buffer.isBuffer(helpInformation)) {\n        throw new Error('outputHelp callback must return a string or a Buffer');\n      }\n    }\n    context.write(helpInformation);\n\n    if (this._getHelpOption()?.long) {\n      this.emit(this._getHelpOption().long); // deprecated\n    }\n    this.emit('afterHelp', context);\n    this._getCommandAndAncestors().forEach(command => command.emit('afterAllHelp', context));\n  }\n\n  /**\n   * You can pass in flags and a description to customise the built-in help option.\n   * Pass in false to disable the built-in help option.\n   *\n   * @example\n   * program.helpOption('-?, --help' 'show help'); // customise\n   * program.helpOption(false); // disable\n   *\n   * @param {(string | boolean)} flags\n   * @param {string} [description]\n   * @return {Command} `this` command for chaining\n   */\n\n  helpOption(flags, description) {\n    // Support disabling built-in help option.\n    if (typeof flags === 'boolean') {\n      if (flags) {\n        this._helpOption = this._helpOption ?? undefined; // preserve existing option\n      } else {\n        this._helpOption = null; // disable\n      }\n      return this;\n    }\n\n    // Customise flags and description.\n    flags = flags ?? '-h, --help';\n    description = description ?? 'display help for command';\n    this._helpOption = this.createOption(flags, description);\n\n    return this;\n  }\n\n  /**\n   * Lazy create help option.\n   * Returns null if has been disabled with .helpOption(false).\n   *\n   * @returns {(Option | null)} the help option\n   * @package internal use only\n   */\n  _getHelpOption() {\n    // Lazy create help option on demand.\n    if (this._helpOption === undefined) {\n      this.helpOption(undefined, undefined);\n    }\n    return this._helpOption;\n  }\n\n  /**\n   * Supply your own option to use for the built-in help option.\n   * This is an alternative to using helpOption() to customise the flags and description etc.\n   *\n   * @param {Option} option\n   * @return {Command} `this` command for chaining\n   */\n  addHelpOption(option) {\n    this._helpOption = option;\n    return this;\n  }\n\n  /**\n   * Output help information and exit.\n   *\n   * Outputs built-in help, and custom text added using `.addHelpText()`.\n   *\n   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout\n   */\n\n  help(contextOptions) {\n    this.outputHelp(contextOptions);\n    let exitCode = process.exitCode || 0;\n    if (exitCode === 0 && contextOptions && typeof contextOptions !== 'function' && contextOptions.error) {\n      exitCode = 1;\n    }\n    // message: do not have all displayed text available so only passing placeholder.\n    this._exit(exitCode, 'commander.help', '(outputHelp)');\n  }\n\n  /**\n   * Add additional text to be displayed with the built-in help.\n   *\n   * Position is 'before' or 'after' to affect just this command,\n   * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.\n   *\n   * @param {string} position - before or after built-in help\n   * @param {(string | Function)} text - string to add, or a function returning a string\n   * @return {Command} `this` command for chaining\n   */\n  addHelpText(position, text) {\n    const allowedValues = ['beforeAll', 'before', 'after', 'afterAll'];\n    if (!allowedValues.includes(position)) {\n      throw new Error(`Unexpected value for position to addHelpText.\nExpecting one of '${allowedValues.join(\"', '\")}'`);\n    }\n    const helpEvent = `${position}Help`;\n    this.on(helpEvent, (context) => {\n      let helpStr;\n      if (typeof text === 'function') {\n        helpStr = text({ error: context.error, command: context.command });\n      } else {\n        helpStr = text;\n      }\n      // Ignore falsy value when nothing to output.\n      if (helpStr) {\n        context.write(`${helpStr}\\n`);\n      }\n    });\n    return this;\n  }\n\n  /**\n   * Output help information if help flags specified\n   *\n   * @param {Array} args - array of options to search for help flags\n   * @private\n   */\n\n  _outputHelpIfRequested(args) {\n    const helpOption = this._getHelpOption();\n    const helpRequested = helpOption && args.find(arg => helpOption.is(arg));\n    if (helpRequested) {\n      this.outputHelp();\n      // (Do not have all displayed text available so only passing placeholder.)\n      this._exit(0, 'commander.helpDisplayed', '(outputHelp)');\n    }\n  }\n}\n\n/**\n * Scan arguments and increment port number for inspect calls (to avoid conflicts when spawning new command).\n *\n * @param {string[]} args - array of arguments from node.execArgv\n * @returns {string[]}\n * @private\n */\n\nfunction incrementNodeInspectorPort(args) {\n  // Testing for these options:\n  //  --inspect[=[host:]port]\n  //  --inspect-brk[=[host:]port]\n  //  --inspect-port=[host:]port\n  return args.map((arg) => {\n    if (!arg.startsWith('--inspect')) {\n      return arg;\n    }\n    let debugOption;\n    let debugHost = '127.0.0.1';\n    let debugPort = '9229';\n    let match;\n    if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {\n      // e.g. --inspect\n      debugOption = match[1];\n    } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {\n      debugOption = match[1];\n      if (/^\\d+$/.test(match[3])) {\n        // e.g. --inspect=1234\n        debugPort = match[3];\n      } else {\n        // e.g. --inspect=localhost\n        debugHost = match[3];\n      }\n    } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\\d+)$/)) !== null) {\n      // e.g. --inspect=localhost:1234\n      debugOption = match[1];\n      debugHost = match[3];\n      debugPort = match[4];\n    }\n\n    if (debugOption && debugPort !== '0') {\n      return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;\n    }\n    return arg;\n  });\n}\n\nexports.Command = Command;\n", "const { Argument } = require('./lib/argument.js');\nconst { Command } = require('./lib/command.js');\nconst { CommanderError, InvalidArgumentError } = require('./lib/error.js');\nconst { Help } = require('./lib/help.js');\nconst { Option } = require('./lib/option.js');\n\nexports.program = new Command();\n\nexports.createCommand = (name) => new Command(name);\nexports.createOption = (flags, description) => new Option(flags, description);\nexports.createArgument = (name, description) => new Argument(name, description);\n\n/**\n * Expose classes\n */\n\nexports.Command = Command;\nexports.Option = Option;\nexports.Argument = Argument;\nexports.Help = Help;\n\nexports.CommanderError = CommanderError;\nexports.InvalidArgumentError = InvalidArgumentError;\nexports.InvalidOptionArgumentError = InvalidArgumentError; // Deprecated\n", "'use strict';\nmodule.exports = balanced;\nfunction balanced(a, b, str) {\n  if (a instanceof RegExp) a = maybeMatch(a, str);\n  if (b instanceof RegExp) b = maybeMatch(b, str);\n\n  var r = range(a, b, str);\n\n  return r && {\n    start: r[0],\n    end: r[1],\n    pre: str.slice(0, r[0]),\n    body: str.slice(r[0] + a.length, r[1]),\n    post: str.slice(r[1] + b.length)\n  };\n}\n\nfunction maybeMatch(reg, str) {\n  var m = str.match(reg);\n  return m ? m[0] : null;\n}\n\nbalanced.range = range;\nfunction range(a, b, str) {\n  var begs, beg, left, right, result;\n  var ai = str.indexOf(a);\n  var bi = str.indexOf(b, ai + 1);\n  var i = ai;\n\n  if (ai >= 0 && bi > 0) {\n    if(a===b) {\n      return [ai, bi];\n    }\n    begs = [];\n    left = str.length;\n\n    while (i >= 0 && !result) {\n      if (i == ai) {\n        begs.push(i);\n        ai = str.indexOf(a, i + 1);\n      } else if (begs.length == 1) {\n        result = [ begs.pop(), bi ];\n      } else {\n        beg = begs.pop();\n        if (beg < left) {\n          left = beg;\n          right = bi;\n        }\n\n        bi = str.indexOf(b, i + 1);\n      }\n\n      i = ai < bi && ai >= 0 ? ai : bi;\n    }\n\n    if (begs.length) {\n      result = [ left, right ];\n    }\n  }\n\n  return result;\n}\n", "var balanced = require('balanced-match');\n\nmodule.exports = expandTop;\n\nvar escSlash = '\\0SLASH'+Math.random()+'\\0';\nvar escOpen = '\\0OPEN'+Math.random()+'\\0';\nvar escClose = '\\0CLOSE'+Math.random()+'\\0';\nvar escComma = '\\0COMMA'+Math.random()+'\\0';\nvar escPeriod = '\\0PERIOD'+Math.random()+'\\0';\n\nfunction numeric(str) {\n  return parseInt(str, 10) == str\n    ? parseInt(str, 10)\n    : str.charCodeAt(0);\n}\n\nfunction escapeBraces(str) {\n  return str.split('\\\\\\\\').join(escSlash)\n            .split('\\\\{').join(escOpen)\n            .split('\\\\}').join(escClose)\n            .split('\\\\,').join(escComma)\n            .split('\\\\.').join(escPeriod);\n}\n\nfunction unescapeBraces(str) {\n  return str.split(escSlash).join('\\\\')\n            .split(escOpen).join('{')\n            .split(escClose).join('}')\n            .split(escComma).join(',')\n            .split(escPeriod).join('.');\n}\n\n\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n  if (!str)\n    return [''];\n\n  var parts = [];\n  var m = balanced('{', '}', str);\n\n  if (!m)\n    return str.split(',');\n\n  var pre = m.pre;\n  var body = m.body;\n  var post = m.post;\n  var p = pre.split(',');\n\n  p[p.length-1] += '{' + body + '}';\n  var postParts = parseCommaParts(post);\n  if (post.length) {\n    p[p.length-1] += postParts.shift();\n    p.push.apply(p, postParts);\n  }\n\n  parts.push.apply(parts, p);\n\n  return parts;\n}\n\nfunction expandTop(str) {\n  if (!str)\n    return [];\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.substr(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.substr(2);\n  }\n\n  return expand(escapeBraces(str), true).map(unescapeBraces);\n}\n\nfunction embrace(str) {\n  return '{' + str + '}';\n}\nfunction isPadded(el) {\n  return /^-?0\\d/.test(el);\n}\n\nfunction lte(i, y) {\n  return i <= y;\n}\nfunction gte(i, y) {\n  return i >= y;\n}\n\nfunction expand(str, isTop) {\n  var expansions = [];\n\n  var m = balanced('{', '}', str);\n  if (!m) return [str];\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  var pre = m.pre;\n  var post = m.post.length\n    ? expand(m.post, false)\n    : [''];\n\n  if (/\\$$/.test(m.pre)) {    \n    for (var k = 0; k < post.length; k++) {\n      var expansion = pre+ '{' + m.body + '}' + post[k];\n      expansions.push(expansion);\n    }\n  } else {\n    var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n    var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n    var isSequence = isNumericSequence || isAlphaSequence;\n    var isOptions = m.body.indexOf(',') >= 0;\n    if (!isSequence && !isOptions) {\n      // {a},b}\n      if (m.post.match(/,.*\\}/)) {\n        str = m.pre + '{' + m.body + escClose + m.post;\n        return expand(str);\n      }\n      return [str];\n    }\n\n    var n;\n    if (isSequence) {\n      n = m.body.split(/\\.\\./);\n    } else {\n      n = parseCommaParts(m.body);\n      if (n.length === 1) {\n        // x{{a,b}}y ==> x{a}y x{b}y\n        n = expand(n[0], false).map(embrace);\n        if (n.length === 1) {\n          return post.map(function(p) {\n            return m.pre + n[0] + p;\n          });\n        }\n      }\n    }\n\n    // at this point, n is the parts, and we know it's not a comma set\n    // with a single entry.\n    var N;\n\n    if (isSequence) {\n      var x = numeric(n[0]);\n      var y = numeric(n[1]);\n      var width = Math.max(n[0].length, n[1].length)\n      var incr = n.length == 3\n        ? Math.abs(numeric(n[2]))\n        : 1;\n      var test = lte;\n      var reverse = y < x;\n      if (reverse) {\n        incr *= -1;\n        test = gte;\n      }\n      var pad = n.some(isPadded);\n\n      N = [];\n\n      for (var i = x; test(i, y); i += incr) {\n        var c;\n        if (isAlphaSequence) {\n          c = String.fromCharCode(i);\n          if (c === '\\\\')\n            c = '';\n        } else {\n          c = String(i);\n          if (pad) {\n            var need = width - c.length;\n            if (need > 0) {\n              var z = new Array(need + 1).join('0');\n              if (i < 0)\n                c = '-' + z + c.slice(1);\n              else\n                c = z + c;\n            }\n          }\n        }\n        N.push(c);\n      }\n    } else {\n      N = [];\n\n      for (var j = 0; j < n.length; j++) {\n        N.push.apply(N, expand(n[j], false));\n      }\n    }\n\n    for (var j = 0; j < N.length; j++) {\n      for (var k = 0; k < post.length; k++) {\n        var expansion = pre + N[j] + post[k];\n        if (!isTop || isSequence || expansion)\n          expansions.push(expansion);\n      }\n    }\n  }\n\n  return expansions;\n}\n\n", "/*\n * Copyright (c) 2024 Elide Technologies, Inc.\n *\n * Licensed under the MIT license (the \"License\"); you may not use this file except in compliance\n *  with the License. You may obtain a copy of the License at\n *\n *     https://opensource.org/license/mit/\n *\n *  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n *  License for the specific language governing permissions and limitations under the License.\n */\n\nimport * as process from 'process'\nimport { Command } from 'commander'\nimport { createCliLogger, createCliReporter } from './tool'\nimport { HashAlgorithm, allAlgorithms } from './model'\nimport { HashVerifierLogger, HashVerifierResultsReceiver } from './logger'\nimport checkHashes from './main'\n\n/**\n * Name of the CLI tool.\n */\nexport const CLI_NAME = 'hashlock'\n\n/**\n * Version of the CLI tool.\n */\nexport const CLI_VERSION = '0.0.1'\n\n/**\n * Algorithms which are considered outdated.\n */\nexport const outdatedAlgorithms = [HashAlgorithm.MD5, HashAlgorithm.SHA1]\n\n/**\n * Default algorithms: All, minus outdated algorithms.\n */\nexport const defaultAlgorithms = allAlgorithms.filter(\n  i => !outdatedAlgorithms.includes(i)\n)\n\n/**\n * Enumerates CLI sub-commands.\n */\n/* eslint-disable-next-line no-shadow */\nexport enum CliCommand {\n  CHECK = 'check',\n  GENERATE = 'generate',\n  FRESHEN = 'freshen'\n}\n\n/**\n * Enumerates CLI exit codes.\n */\n/* eslint-disable-next-line no-shadow */\nexport enum CliExitCode {\n  SUCCESS = 0,\n  FAILURE = 1\n}\n\n/**\n * Setup CLI configuration, options, and parameters.\n */\nexport function setupCli(\n  program: Command,\n  entry: (action: CliCommand, cli: Command) => Promise<CliExitCode | number>\n): void {\n  // set version\n  program.version(CLI_VERSION)\n\n  const globJoiner = (value: string, previous: string[]): string[] =>\n    (previous || []).concat(value.split(','))\n  const entrySplitter = (value: string): string[] => value.split(',')\n\n  // command: check\n  program\n    .command(CliCommand.CHECK, { isDefault: true })\n    .option('--strict', 'activate strict matching mode')\n    .option('-i, --ignore <paths>', 'paths to ignore from matching')\n    .argument(\n      '[hashfiles...]',\n      'globs to check for hashfiles to check',\n      globJoiner,\n      []\n    )\n    .action(async function () {\n      // @ts-expect-error runs in the context of the command\n      await entry(CliCommand.CHECK, this as Command) // eslint-disable-line no-invalid-this\n    })\n\n  // command: generate\n  program\n    .command(CliCommand.GENERATE)\n    .option(\n      '-a, --algorithms <values>',\n      'comma-separated algorithms to use',\n      entrySplitter,\n      defaultAlgorithms\n    )\n    .option(\n      '-o, --out <path>',\n      'output file path; if not provided, only one subject path is allowed'\n    )\n    .argument('<subjects...>', 'globs or paths of subject files', globJoiner)\n    .action(async function () {\n      // @ts-expect-error runs in the context of the command\n      await entry(CliCommand.GENERATE, this as Command) // eslint-disable-line no-invalid-this\n    })\n\n  // command: freshen\n  program\n    .command(CliCommand.FRESHEN)\n    .option('-i, --ignore', 'paths to ignore from matching')\n    .option(\n      '-a, --algorithms <values>',\n      'comma-separated algorithms to consider eligible',\n      entrySplitter,\n      allAlgorithms\n    )\n    .argument(\n      '[hashfiles...]',\n      'globs or paths of hashfiles to update',\n      globJoiner,\n      ['.']\n    )\n    .action(async function () {\n      // @ts-expect-error runs in the context of the command\n      await entry(CliCommand.FRESHEN, this as Command) // eslint-disable-line no-invalid-this\n    })\n\n  // help text\n  program.addHelpText(\n    'after',\n    `\nExamples:\n  $ ${CLI_NAME} ${CliCommand.CHECK} .\n  $ ${CLI_NAME} ${CliCommand.CHECK} --strict --ignore ./some_root ./check-these ./also-these\n  $ ${CLI_NAME} ${CliCommand.GENERATE} subject.txt\n  $ ${CLI_NAME} ${CliCommand.GENERATE} -a sha256 -o ./hashfile.sha256 ./subject.txt\n  $ ${CLI_NAME} ${CliCommand.FRESHEN} .\n  $ ${CLI_NAME} ${CliCommand.FRESHEN} --ignore ./some_root ./freshen-these ./also-these`\n  )\n}\n\n/**\n * Initialize the CLI and run it with the provided arguments and entry action.\n *\n * @param program CLI program to run\n * @param args Arguments to parse for this CLI run\n * @param entry Entrypoint function to run; expected to produce an exit code\n */\nasync function initializeAndRunCli(\n  program: Command,\n  args: string[],\n  entry: (action: CliCommand, cli: Command) => Promise<CliExitCode | number>\n): Promise<void> {\n  setupCli(program, entry)\n  program.parse(args)\n}\n\nfunction processBlobOrPathList(\n  list: string[],\n  defaultValue: () => string[]\n): string[] {\n  return list.length > 0 ? list : defaultValue()\n}\n\nexport async function checkAction(\n  cli: Command,\n  logger: HashVerifierLogger,\n  reporter: HashVerifierResultsReceiver\n): Promise<CliExitCode> {\n  // grab options and parameters\n  const opts = cli.opts()\n  const paths = processBlobOrPathList(cli.args, () => ['.'])\n  const ignore = opts.ignore\n    ? processBlobOrPathList(opts.ignore || [], () => [])\n    : []\n  const strict = opts.strict === true\n  const results = await checkHashes(\n    paths,\n    strict,\n    ignore,\n    true, // always use globs from cli\n    reporter,\n    logger\n  )\n\n  return results.errors.length > 0 || results.failedVerifications.length > 0\n    ? 1\n    : 0\n}\n\nexport async function generateAction(\n  cli: Command,\n  logger: HashVerifierLogger\n): Promise<CliExitCode> {\n  console.log('would generate', cli, logger)\n  return 0\n}\n\nexport async function freshenAction(\n  cli: Command,\n  logger: HashVerifierLogger\n): Promise<CliExitCode> {\n  console.log('would freshen', cli, logger)\n  return 0\n}\n\n/**\n * Entrypoint for use of the `verify-hashes` project as a CLI tool; usually named `hashlock`.\n *\n * This entrypoint will prepare a CLI suite of parameters, parse them, and pass them to the underlying implementation,\n * mediating output along the way; several output options are available. Please consult program options for more info.\n *\n * @param args Arguments to run the tool with; defaults to `process.argv`\n * @param program Program implementation to use; defaults to a new `Command` with the name `hashlock`\n */\nexport function entrypoint(\n  args: string[] = process.argv,\n  program: Command = new Command(CLI_NAME)\n): void {\n  initializeAndRunCli(\n    program,\n    args,\n    async (action: CliCommand, cli: Command) => {\n      const logger = createCliLogger(cli)\n\n      switch (action) {\n        case CliCommand.CHECK:\n          return checkAction(cli, logger, createCliReporter(cli))\n        case CliCommand.GENERATE:\n          return generateAction(cli, logger)\n        case CliCommand.FRESHEN:\n          return freshenAction(cli, logger)\n      }\n    }\n  )\n}\n", "import commander from './index.js';\n\n// wrapper to provide named exports for ESM.\nexport const {\n  program,\n  createCommand,\n  createArgument,\n  createOption,\n  CommanderError,\n  InvalidArgumentError,\n  InvalidOptionArgumentError, // deprecated old name\n  Command,\n  Argument,\n  Option,\n  Help\n} = commander;\n", "/*\n * Copyright (c) 2024 Elide Technologies, Inc.\n *\n * Licensed under the MIT license (the \"License\"); you may not use this file except in compliance\n *  with the License. You may obtain a copy of the License at\n *\n *     https://opensource.org/license/mit/\n *\n *  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n *  License for the specific language governing permissions and limitations under the License.\n */\n\nimport { Command } from 'commander'\nimport { HashVerifierLogger, HashVerifierResultsReceiver } from './logger'\nimport { VerifyHashFileInfo } from './model'\n\nexport function createCliLogger(cli: Command): HashVerifierLogger {\n  return {\n    debug: (message: string) => {\n      if (cli.opts().debug) console.debug(message)\n    },\n    info: (message: string) => console.info(message),\n    warning: (message: string) => console.warn(message),\n    error: (message: string) => console.error(message),\n    setFailed: (message: string) => {\n      console.error(message)\n      process.exit(1)\n    }\n  }\n}\n\nexport function createCliReporter(cli: Command): HashVerifierResultsReceiver {\n  return {\n    eligible: () => {\n      /* nothing at this time @TODO */\n    },\n    result: (result: VerifyHashFileInfo) => {\n      /* nothing at this time @TODO */\n      if (result.valid === true) {\n        console.info(`Hash check passed: ${result.file}`)\n      } else {\n        const msg = `Hash check failed: ${result.file}; ${result.reason}`\n        if (cli.opts().strict) {\n          console.error(msg)\n        } else {\n          console.warn(msg)\n        }\n      }\n    },\n    failure: result => {\n      const msg = `Hash check failed: ${result.reason}; ${result.message}`\n      if (cli.opts().strict) {\n        console.error(msg)\n      } else {\n        console.warn(msg)\n      }\n    }\n  }\n}\n", "/*\n * Copyright (c) 2024 Elide Technologies, Inc.\n *\n * Licensed under the MIT license (the \"License\"); you may not use this file except in compliance\n *  with the License. You may obtain a copy of the License at\n *\n *     https://opensource.org/license/mit/\n *\n *  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n *  License for the specific language governing permissions and limitations under the License.\n */\n\n/**\n * Hash Algorithm\n *\n * Describes the hash algorithms recognized by this action.\n */\nexport enum HashAlgorithm {\n  MD5 = 'md5',\n  SHA1 = 'sha1',\n  SHA256 = 'sha256',\n  SHA512 = 'sha512'\n}\n\n/**\n * Encoded Hash Sizes by Algorithm (Hex)\n *\n * Maps the expected size of a hex-encoded hash for a given algorithm.\n */\nexport const expectedHexHashSize = {\n  [`${HashAlgorithm.MD5}`]: 32,\n  [`${HashAlgorithm.SHA1}`]: 40,\n  [`${HashAlgorithm.SHA256}`]: 64,\n  [`${HashAlgorithm.SHA512}`]: 128\n}\n\n/**\n * Algorithms by Encoded Hash Size (Hex)\n *\n * Maps the expected algorithm for a given hex-encoded hash size.\n */\nexport const encodedHashSizeHex: { [key: number]: string } = {\n  32: HashAlgorithm.MD5,\n  40: HashAlgorithm.SHA1,\n  64: HashAlgorithm.SHA256,\n  128: HashAlgorithm.SHA512\n}\n\n/**\n * Encoded Hash Sizes by Algorithm (Base64)\n *\n * Maps the expected size of a base64-encoded hash for a given algorithm.\n */\nexport const expectedBase64HashSize = {\n  [`${HashAlgorithm.MD5}`]: 24,\n  [`${HashAlgorithm.SHA1}`]: 28,\n  [`${HashAlgorithm.SHA256}`]: 44,\n  [`${HashAlgorithm.SHA512}`]: 88\n}\n\n/**\n * Algorithms by Encoded Hash Size (Base64)\n *\n * Maps the expected algorithm for a given base64-encoded hash size.\n */\nexport const encodedHashSizeBase64: { [key: number]: string } = {\n  24: HashAlgorithm.MD5,\n  28: HashAlgorithm.SHA1,\n  44: HashAlgorithm.SHA256,\n  88: HashAlgorithm.SHA512\n}\n\n/**\n * Expected Hex Characters Regex\n *\n * Regular expression that matches the expected characters in a hex-encoded hash.\n */\nexport const expectedHexCharactersRegex = /^[a-fA-F0-9]+$/\n\n/**\n * Expected Base64 Characters Regex\n *\n * Regular expression that matches the expected characters in a base64-encoded hash.\n */\nexport const expectedBase64CharactersRegex = /^[a-zA-Z0-9/+]+={0,2}$/\n\n/**\n * Extension Map\n *\n * Maps file extensions to hash algorithms.\n */\nexport const extensionMap: { [key: string]: HashAlgorithm } = {\n  [`${HashAlgorithm.MD5}`]: HashAlgorithm.MD5,\n  [`${HashAlgorithm.SHA1}`]: HashAlgorithm.SHA1,\n  [`${HashAlgorithm.SHA256}`]: HashAlgorithm.SHA256,\n  [`${HashAlgorithm.SHA512}`]: HashAlgorithm.SHA512,\n  sha: HashAlgorithm.SHA1\n}\n\n/**\n * All Algorithms\n *\n * All hash algorithms supported by the action.\n */\nexport const allAlgorithms: HashAlgorithm[] = [\n  HashAlgorithm.MD5,\n  HashAlgorithm.SHA1,\n  HashAlgorithm.SHA256,\n  HashAlgorithm.SHA512\n]\n\n/**\n * Hash Encoding\n *\n * Describes the hash encoding modes supported by the action.\n */\nexport enum HashEncoding {\n  HEX = 'hex',\n  BASE64 = 'base64'\n}\n\n/**\n * Verify Hash File Info\n *\n * Describes the result of verifying a hash file; this includes the file, the resolved subject, the detected algorithm,\n * and the result of the verification.\n */\nexport type VerifyHashFileInfo =\n  | {\n      err: true\n      file: string\n      valid?: false\n      reason?: VerifyFailedReason\n    }\n  | {\n      err: true\n      valid: false\n      found: true\n      file: string\n      peer: string\n      algorithm: HashAlgorithm\n      encoding: HashEncoding\n      reason: VerifyFailedReason\n      expected?: string\n      actual?: string\n    }\n  | {\n      err: false\n      file: string\n      peer: string\n      found: true\n      valid: true\n      algorithm: HashAlgorithm\n      encoding: HashEncoding\n    }\n\n/**\n * Hash File Content\n *\n * Describes the detected algorithm, hash value, hash-file path, subject file path, and encoding, as detected from the\n * hash in the file.\n */\nexport type HashFileContent = {\n  algorithm: HashAlgorithm\n  hash: string\n  hashfile: string\n  subject: string\n  encoding: HashEncoding\n}\n\n/**\n * Hash File\n *\n * Describes a hash file which can potentially include multiple subjects, each with a file and hash name; this\n * structure is used when generating hash files.\n */\nexport type HashFile = {\n  algorithm: HashAlgorithm\n  encoding: HashEncoding\n  subjects: { hash: string; subject: string }[]\n}\n\n/**\n * File Content\n *\n * Describes raw file content; this includes the subject file path and the file contents.\n */\nexport type FileContent = {\n  file: string\n  contents: Buffer\n}\n\n/**\n * Verify Failed Reason\n *\n * Enumerates reasons why hash verification can fail.\n */\nexport enum VerifyFailedReason {\n  /** A subject file declared in a hash file could not be located. */\n  SUBJECT_NOT_FOUND = 'subject-not-found',\n\n  /** No hash files match and strict mode was on. */\n  NO_HASH_FILES_FOUND = 'no-hash-files-found',\n\n  /** There was a hash file that mismatched its subject file. */\n  HASH_MISMATCH = 'hash-mismatch',\n\n  /** The hash listed in a hash file did not match the expected algorithm. */\n  HASH_TYPE_MISMATCH = 'hash-type-mismatch',\n\n  /** The hash value listed in a hash value was malformed for the expected algorithm or encoding. */\n  HASH_VALUE_INVALID = 'hash-value-invalid',\n\n  /** A generic error occurred while verifying: for example, a subject file exists but could not be read. */\n  ERROR_WHILE_VERIFYING = 'error-while-verifying'\n}\n\n/**\n * Verify Failed Info\n *\n * Describes a single hash verification check that failed during the course of action execution.\n */\nexport type VerifyFailedInfo = {\n  reason: VerifyFailedReason\n  message: string\n}\n", "/*\n * Copyright (c) 2024 Elide Technologies, Inc.\n *\n * Licensed under the MIT license (the \"License\"); you may not use this file except in compliance\n *  with the License. You may obtain a copy of the License at\n *\n *     https://opensource.org/license/mit/\n *\n *  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n *  License for the specific language governing permissions and limitations under the License.\n */\n\nimport { join, resolve, basename, dirname, normalize } from 'node:path'\nimport { existsSync } from 'node:fs'\nimport { readFile } from 'node:fs/promises'\nimport { generateHash } from './generator'\n\nimport { glob } from 'glob'\n\nimport {\n  HashVerifierLogger,\n  HashVerifierResultsReceiver,\n  createDefaultLogger,\n  createDefaultReporter\n} from './logger'\n\nimport {\n  HashAlgorithm,\n  HashEncoding,\n  VerifyFailedReason,\n  VerifyFailedInfo,\n  VerifyHashFileInfo,\n  HashFileContent,\n  FileContent,\n  expectedHexHashSize,\n  expectedBase64HashSize,\n  expectedHexCharactersRegex,\n  expectedBase64CharactersRegex,\n  encodedHashSizeHex,\n  encodedHashSizeBase64,\n  extensionMap,\n  allAlgorithms\n} from './model'\n\nlet logging: HashVerifierLogger = createDefaultLogger()\n\n/**\n * Hash Verify Error\n *\n * Error-extending class which describes the `VerifyFailedReason` for a failure.\n */\nexport class HashVerifyErr extends Error {\n  /**\n   * Primary constructor.\n   *\n   * @param reason Reason for the failed verification\n   * @param cause Cause (error), if any\n   * @param message Message to override/report with\n   */\n  private constructor(\n    readonly reason: VerifyFailedReason,\n    readonly cause?: Error,\n    message?: string\n  ) {\n    super(message)\n  }\n\n  /**\n   * Prepare a hash verification error for the provided reason.\n   *\n   * @param reason Reason for the failure\n   * @param message Message to show for the failure; optional\n   * @returns Hash verification error\n   */\n  static of(reason: VerifyFailedReason, message?: string): HashVerifyErr {\n    return new HashVerifyErr(reason, undefined, message)\n  }\n}\n\n/**\n * Detect the hash algorithm used to produce a hash file.\n *\n * Because this action is designed to only match algorithms which is understands, errors here are thrown; only eligible\n * files should be making it this far. We need to throw a regular error to escape our custom error catch logic.\n *\n * @param file File path to detect an algorithm for\n * @returns Algorithm detected\n * @throws Error if the algorithm cannot be detected\n */\nexport function detectAlgorithm(file: string): HashAlgorithm {\n  const split = file.split('.')\n  const ext = split[split.length - 1]\n  const algo = extensionMap[ext.trim().toLowerCase()]\n  if (!algo) throw new Error(`Unrecognized hash algorithm for file: ${file}`)\n  return algo\n}\n\n/**\n * Detect the encoding used for a hash value, based on the length and character set.\n *\n * @param hash Encoded hash value to detect the encoding for\n * @returns Detected encoding for the hash value, based on the length and character set\n */\nexport function detectEncodingForHash(hash: string): HashEncoding {\n  const validBase64 =\n    hash.match(expectedBase64CharactersRegex) != null &&\n    encodedHashSizeBase64[hash.length] != null\n  if (validBase64) {\n    return HashEncoding.BASE64\n  }\n  const validHex =\n    hash.match(expectedHexCharactersRegex) != null &&\n    encodedHashSizeHex[hash.length] != null\n  if (!validHex)\n    throw HashVerifyErr.of(\n      VerifyFailedReason.HASH_VALUE_INVALID,\n      `Invalid hash value: ${hash}`\n    )\n  return HashEncoding.HEX\n}\n\n/**\n * Detect the hash algorithm expected for a hash value.\n *\n * Based on the length of an encoded hash value and its encoding, detect the algorithm which is expected to have\n * produced the hash.\n *\n * @param encoding Encoding which is in use for the hash value\n * @param hash Hash value to detect the algorithm for\n * @return Detected algorithm\n */\nexport function detectAlgorithmForHash(\n  encoding: HashEncoding,\n  hash: string\n): HashAlgorithm {\n  const alg =\n    encoding === HashEncoding.BASE64\n      ? encodedHashSizeBase64[hash.length]\n      : encodedHashSizeHex[hash.length]\n  if (!alg) {\n    throw HashVerifyErr.of(\n      VerifyFailedReason.HASH_VALUE_INVALID,\n      `Invalid hash value: ${hash} (could not detect algorithm by length)`\n    )\n  }\n  return alg as HashAlgorithm\n}\n\n/**\n * Find the subject file described by a hash file, or fail.\n *\n * Given a hash file, guess the filename of the subject file it relates to; this method of guessing the subject is only\n * used when the subject is not listed within the hash file.\n *\n * This method of guessing is not always entirely safe: it assumes that the hash file is named after the subject file,\n * and that the hash file is in the same directory as the subject file. This is a common convention, but not a rule.\n *\n * @param file Filename for the hash file\n * @returns Guessed filename for the subject file\n */\nexport function findSubject(file: string): string {\n  // like: `some/file.txt.sha256`\n  const parent = dirname(file)\n  const filename = basename(file)\n  const split = filename.split('.')\n\n  // `subject.md5`\n  if (split.length < 3) {\n    // `subject`\n    return join(parent, split[0])\n  }\n\n  // `subject.txt.md5` \u2192 `subject.txt`\n  return join(parent, split.slice(0, split.length - 1).join('.'))\n}\n\n/**\n * Read the subject file described by a hash file, or fail.\n *\n * Given an absolute (resolved) path to a subject file, read it, returning a `FileContents` for it; if the file cannot\n * be safely read, throw hard. Errors here are considered verification failures (for example, a file which cannot be\n * read because of permissions).\n *\n * @param expected Expected file path where the file should be read from. Absolute.\n * @returns File contents\n * @throws HashVerifyErr if the file cannot be read.\n */\nexport async function readSubject(expected: string): Promise<FileContent> {\n  if (!existsSync(expected)) {\n    logging.warning(`Subject file not found at '${expected}'`)\n    throw HashVerifyErr.of(VerifyFailedReason.SUBJECT_NOT_FOUND)\n  }\n  return {\n    file: expected,\n    contents: await readFile(expected)\n  }\n}\n\n/**\n * Read a hash file and interpret it into a data structure suitable for comparison.\n *\n * Given the absolute and normalized path to a hash-file, resolve the path to an absolute normalized path, read it, and\n * interpret the file contents into one `HashFileContent` record per entry in the hash file. This method is designed to\n * tolerate errors while reading or decoding the hash file; these are propagated upward as `HashVerifyErr` exceptions.\n *\n * This method parses the hash file contents and will error aggressively if the contents do not match an expected\n * format. There are two supported variants of the format:\n *\n * 1) Hash files inline in the file, between 1 and N, like:\n *\n * **somefile.txt**:\n * ```text\n * (content)\n * ```\n *\n * **some-hash-file.txt.md5**:\n * ```text\n * 1234567890abcdef1234567890abcdef  somefile.txt\n * 1234567890abcdef1234567890abcdef  some/other/file.txt\n * ```\n *\n * In this mode, the hash file is expected to contain one hash per line, with the hash and the subject separated by\n * whitespace (any whitespace of any amount is fine). The subject is expected to be a relative path to the hash file, or\n * to be a peer file within the same directory if no path is present.\n *\n * The hash file filename does not need to match anything in particular in this mode. Mode 1 is the default mode; mode 2\n * (described below) only kicks in if no file is specified at all.\n *\n * 2) Hash files named alongside their subject, with no file specified, like:\n *\n * * **somefile.txt**:\n * ```text\n * (content)\n * ```\n *\n * **somefile.txt.md5**:\n * ```text\n * 1234567890abcdef1234567890abcdef\n * ```\n *\n * There are additional restrictions in this mode: (1) it only functions as a fallback to mode #1; (2) the hash file\n * can only list one hash (any additional non-blank lines cause an error), and (3) the hash file must be named after\n * the subject file, and must be in the same directory as the subject file.\n *\n * @param file Absolute and normalized path to a hash file\n * @returns Array of assertions specified within the hash file; one per subject/hash pair\n */\nexport async function readHashFile(file: string): Promise<HashFileContent[]> {\n  logging.debug(`- Reading hash file at '${file}'`)\n  const content = readFile(file, 'utf8')\n\n  // detect the expected algorithm\n  const algorithm = detectAlgorithm(file)\n  const lines = (await content)\n    .split('\\n') // split by line\n    .map(it => it.trim()) // trim each line\n    // must be non-empty, non-whitespace-only\n    .filter(it => it.length > 0 && it.replace(/\\s/g, '').length > 0)\n\n  const assertions = lines\n    .map(line => {\n      const split = line.split(/[ \\t]{1,3}/)\n      switch (split.length) {\n        case 1:\n          // special case: subject-less hashfiles can only have one non-blank line\n          // so if this is not the only line with content, we should fail.\n          if (lines.length > 1)\n            throw HashVerifyErr.of(\n              VerifyFailedReason.HASH_VALUE_INVALID,\n              `Invalid hash file format at '${file}': subject-less hash files can only have one hash`\n            )\n          return {\n            hash: split[0],\n            encoding: detectEncodingForHash(split[0]),\n            subject: resolve(\n              normalize(join(dirname(file), basename(findSubject(file))))\n            ),\n            hashfile: file,\n            algorithm\n          }\n        case 2:\n          return {\n            hash: split[0],\n            encoding: detectEncodingForHash(split[0]),\n            subject: resolve(\n              normalize(join(dirname(file), basename(split[1])))\n            ),\n            hashfile: file,\n            algorithm\n          }\n        default:\n          logging.warning(`Unrecognized hash file format at '${file}'`)\n          return\n      }\n    })\n    .filter(it => !!it) as HashFileContent[]\n\n  for (const assertion of assertions) {\n    // the assertion should match the expected algorithm\n    const expectedSizes =\n      assertion.encoding === HashEncoding.HEX\n        ? expectedHexHashSize\n        : expectedBase64HashSize\n\n    if (expectedSizes[algorithm] !== assertion.hash.length)\n      throw HashVerifyErr.of(\n        VerifyFailedReason.HASH_VALUE_INVALID,\n        `Invalid hash value for file at '${file}': ${assertion.hash}`\n      )\n  }\n  return assertions\n}\n\n/**\n * Compare the hashfile with the subject file, producing info about the result.\n *\n * This function performs the actual hashing and comparison for a given subject file content record; the content is\n * hashed as raw data, and then encoded according to the expected encoding from the hash file. The result is then\n * compared with the expected hash value.\n *\n * The results of this comparison are packaged up in full and returned to the caller for further processing. Errors\n * which escape this function are fatal and should be treated as such.\n *\n * @param hash Hashfile content (interpreted) to compare with the provided file contnt\n * @param subject Subject file content to hash and compare with the hashfile content\n * @returns Result of the comparison between the hash file and the hashed subject file content\n */\nexport async function compareHashWithSubject(\n  hash: HashFileContent,\n  subject: FileContent\n): Promise<VerifyHashFileInfo> {\n  const { algorithm, encoding, hash: expected } = hash\n  logging.debug(\n    `- Comparing hash for '${subject.file}' (algorithm: ${algorithm}, encoding: ${encoding}, expected: ${expected})`\n  )\n\n  const actual: string = await generateHash(\n    algorithm,\n    encoding,\n    subject.contents\n  )\n  const valid = actual === expected\n  logging.debug(\n    `- Hash comparison result for '${subject.file}': ${valid ? 'valid' : 'invalid'} (actual: ${actual})`\n  )\n  if (valid) {\n    return {\n      err: false,\n      file: subject.file,\n      peer: hash.subject,\n      found: true,\n      valid: true,\n      algorithm,\n      encoding\n    }\n  } else {\n    return {\n      err: true,\n      found: true,\n      valid: false,\n      file: subject.file,\n      peer: hash.subject,\n      reason: VerifyFailedReason.HASH_MISMATCH,\n      expected,\n      actual,\n      algorithm,\n      encoding\n    }\n  }\n}\n\n/**\n * Verify a hash file at the provided name.\n *\n * Given the relative path to a hash file, resolve the path to an absolute normalized path, read it, and interpret the\n * hash file contents. For each declared hash assertion within the file (either in the file name as one hash, or in the\n * file body as 1-N hashes), compare the hash with the subject file, and return the results of these comparisons.\n *\n * For details about the hash file format and the expected behavior of this function, see `readHashFile` and the method\n * `compareHashWithSubject`.\n *\n * @param file Path to the hash file to be verified; will be resolved and normalized\n * @returns Result of hash comparisons performed\n */\nexport async function verifyHashFile(\n  file: string\n): Promise<VerifyHashFileInfo[]> {\n  const abs = resolve(normalize(file))\n  try {\n    return Promise.all(\n      (await readHashFile(abs)).map(async hash => {\n        try {\n          return await compareHashWithSubject(\n            hash,\n            await readSubject(hash.subject)\n          )\n        } catch (err) {\n          if (err instanceof HashVerifyErr) {\n            return {\n              err: true,\n              file: abs,\n              valid: false,\n              reason: err.reason\n            }\n          }\n          /* c8 ignore next */\n          throw err\n          /* c8 ignore next */\n        }\n      })\n    )\n  } catch (err) {\n    if (err instanceof HashVerifyErr) {\n      return [\n        {\n          err: true,\n          file: abs,\n          valid: false,\n          reason: err.reason\n        }\n      ]\n    }\n    /* c8 ignore next */\n    throw err\n    /* c8 ignore next */\n  }\n}\n\n/**\n * Report hash-file verification results.\n *\n * @param eligible All eligible files which were scanned\n * @param verified Verified hash-file info records which matched\n * @param failures Hash files which did not match (but did not error)\n * @param err Hash file checks which failed because of errors\n * @param reporter Receiver for results\n */\nexport function reportResults(\n  eligible: string[],\n  verified: VerifyHashFileInfo[],\n  failures: VerifyHashFileInfo[],\n  err: VerifyFailedInfo[],\n  reporter: HashVerifierResultsReceiver\n): void {\n  // report all eligible files for missing file calculations\n  reporter.eligible(eligible)\n\n  // report all verified and error states\n  for (const result of verified.concat(failures)) {\n    reporter.result(result)\n  }\n  for (const error of err) {\n    reporter.failure(error)\n  }\n}\n\n/**\n * Check Hashes Result\n *\n * Packages up results of a call to `checkHashes`, with all verified files, failed verifications, and errors.\n */\nexport type CheckHashesResult = {\n  verifiedFiles: VerifyHashFileInfo[]\n  failedVerifications: VerifyHashFileInfo[]\n  errors: VerifyFailedInfo[]\n}\n\n/**\n * Check a specified set of globs or file paths for hash files; any hash files that are found are verified according to\n * the assertions they contain.\n *\n * The results of verifications are reported to the provided receiver, and then returned to the caller; the function\n * will fail if any verification fails and the `strict` flag is set, or if a fatal error or unexpected error occurs.\n * Otherwise, simple hash failures, missing subject files, etc., are all reported as results.\n *\n * @param paths Paths which are eligible for scanning\n * @param strict Whether to fail the action if any verification fails\n * @param ignored Paths to ignore\n * @param globs Whether to treat paths as globs\n * @param reporter Custom receiver for results; optional.\n * @param logger Custom logger for the action; optional.\n * @returns {Promise<void>} Resolves when the action is complete.\n */\nexport default async function checkHashes(\n  paths: string[],\n  strict: boolean,\n  ignored: string[],\n  globs: boolean,\n  reporter?: HashVerifierResultsReceiver,\n  logger?: HashVerifierLogger\n): Promise<CheckHashesResult> {\n  const reportTo = reporter || createDefaultReporter()\n  logging = logger || logging\n  let files: string[]\n\n  if (globs) {\n    const algorithmExts = allAlgorithms.join(',')\n\n    // start generating globs\n    const patterns = paths\n      .map(path => `${path}/**/*.{${algorithmExts}}`)\n      .concat(ignored.map(entry => `!${entry}`))\n\n    // prepare globber, start globbing\n    files = await glob(patterns)\n  } else {\n    files = paths.filter(path => {\n      return !ignored.includes(path)\n    })\n  }\n\n  if (files.length === 0) {\n    const msg = 'No hash files to verify.'\n    if (strict) {\n      logging.error(msg)\n    } else {\n      logging.info(msg)\n    }\n    return {\n      verifiedFiles: [],\n      failedVerifications: [],\n      errors: []\n    }\n  }\n\n  // begin verifying files\n  logging.debug(`Verifying ${files.length} hash files...`)\n  const promises = files.map(file => {\n    logging.debug(`- Verifying '${file}'`)\n    return {\n      file,\n      operation: verifyHashFile(file)\n    }\n  })\n\n  // verify matched files\n  const results: VerifyHashFileInfo[] = []\n  const errors: VerifyFailedInfo[] = []\n\n  for (const promise of promises) {\n    results.push(...(await promise.operation))\n  }\n\n  const verifiedFiles = results.filter(({ valid }) => valid)\n  const failedVerifications = results.filter(({ valid }) => !valid)\n  if (verifiedFiles.length > 0)\n    logging.info(`Verified ${verifiedFiles.length} hash files`)\n  reportResults(files, verifiedFiles, failedVerifications, errors, reportTo)\n  return {\n    verifiedFiles,\n    failedVerifications,\n    errors\n  }\n}\n", "/*\n * Copyright (c) 2024 Elide Technologies, Inc.\n *\n * Licensed under the MIT license (the \"License\"); you may not use this file except in compliance\n *  with the License. You may obtain a copy of the License at\n *\n *     https://opensource.org/license/mit/\n *\n *  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n *  License for the specific language governing permissions and limitations under the License.\n */\n\n//\n// Note: While these tools are exposed for packages downstream, they are considered low-level (no error handling, etc.)\n// and use outside of this package does not guarantee API stability.\n//\n\nimport { existsSync } from 'node:fs'\nimport { readFile, writeFile } from 'node:fs/promises'\nimport { normalize, resolve, join, dirname, basename } from 'node:path'\nimport { HashAlgorithm, HashEncoding, HashFile } from './model'\nimport { createHash } from 'node:crypto' // @TODO(sgammon): streaming?\n\n/**\n * Generate an encoded hash for the provided content\n *\n * @param algo Algorithm to use when generating the hash\n * @param encoding Encoding to use to encode the hash\n * @param content Content to hash as a raw buffer or string\n * @return Encoded hash value\n */\nexport async function generateHash(\n  algo: HashAlgorithm,\n  encoding: HashEncoding,\n  content: Buffer | string\n): Promise<string> {\n  return createHash(algo).update(content).digest(encoding)\n}\n\n/**\n * Generate a hash file with one or more subjects; each subject is a file with its content\n *\n * @param algo Algorithm to use when generating the hashes\n * @param encoding Encoding to use to encode the hashes\n * @param subjects Subject files with their paths and content\n * @return Hash file content structure\n */\nexport async function generateHashfile(\n  algo: HashAlgorithm,\n  encoding: HashEncoding,\n  subjects: { file: string; content: Buffer | string }[]\n): Promise<HashFile> {\n  const targets: { hash: string; subject: string }[] = []\n  for (const subject of subjects) {\n    const hash = await generateHash(algo, encoding, subject.content)\n    targets.push({ hash, subject: subject.file })\n  }\n  return {\n    algorithm: algo,\n    subjects: targets,\n    encoding\n  }\n}\n\n/**\n * Generate a hash file as a peer to the specified `file`; the hash file content is not written, it is returned\n *\n * If the file cannot be located or cannot be read, an error is thrown. The provided file path is resolved, normalized,\n * and otherwise cleaned up before reading.\n *\n * @param file Subject filepath; can be relative or absolute\n * @param algo Algorithm to use when generating the hashes\n * @param encoding Encoding to use to encode the hashes\n * @return Hash file content structure\n */\nexport async function generateHashfileForFile(\n  file: string,\n  algo: HashAlgorithm,\n  encoding: HashEncoding\n): Promise<HashFile> {\n  const path = resolve(normalize(file))\n  if (!existsSync(path)) throw new Error(`could not locate file at ${path}`)\n\n  const hashValue = generateHash(algo, encoding, await readFile(path))\n  return {\n    algorithm: algo,\n    encoding,\n    subjects: [\n      {\n        hash: await hashValue,\n        subject: basename(file)\n      }\n    ]\n  }\n}\n\n/**\n * Generate a hash file from multiple input `files`; the hash file content is not written, it is returned\n *\n * If any specified file cannot be located or cannot be read, an error is thrown. The provided file paths are resolved,\n * normalized, and otherwise cleaned up before reading.\n *\n * @param algo Algorithm to use when generating the hashes\n * @param encoding Encoding to use to encode the hashes\n * @param file Subject file paths; each can be relative or absolute\n * @return Hash file content structure\n */\nexport async function generateHashfileForFiles(\n  algo: HashAlgorithm,\n  encoding: HashEncoding,\n  files: string[]\n): Promise<HashFile> {\n  const subjects: { subject: string; hash: string }[] = []\n  const promises: Promise<HashFile>[] = []\n  for (const file of files) {\n    const path = resolve(normalize(file))\n    promises.push(generateHashfileForFile(path, algo, encoding))\n  }\n  for (const result of promises) {\n    subjects.push(...(await result).subjects)\n  }\n  return {\n    algorithm: algo,\n    subjects,\n    encoding\n  }\n}\n\n/**\n * Options to apply when formatting a hash file\n */\nexport type HashfileFormatOptions = {\n  /**\n   * Whether to include subject file paths; defaults to `true` and should usually be left on.\n   */\n  subjects: boolean\n\n  /**\n   * Whether to express paths in the hashfile (subject file paths) as absolute paths. Defaults to `false` and should\n   * usually be left off.\n   */\n  absolute: boolean\n\n  /**\n   * Separator string to use between the hash value and subject file path; defaults to a double-space for compatibility\n   * with existing tools.\n   */\n  separator: string\n}\n\n/**\n * Default options for hashfile formatting.\n */\nexport const defaultFormatOptions: HashfileFormatOptions = {\n  subjects: true,\n  absolute: false,\n  separator: '  '\n}\n\n/**\n * Format the provided hash-file content as a well-formed mapping of hashes to their subject paths.\n *\n * The format is as follows:\n *\n * ```text\n * <hash>  <subject>\n * ```\n *\n * For example:\n * ```text\n * 3e25960a79dbc69b674cd4ec67a72c62  /path/to/file\n * ```\n *\n * If multiple subjects are present in the hash file structure, all are written to the string. It is expected that all\n * provided hashes are of the same algorithm and encoding. Each subject/hash pair is written to a new line.\n *\n * This function produces identical output to the `shasum` series of command line tools for nix-like operating systems,\n * and is tested against these tools for compatibility.\n *\n * @param file File content to format as a hash-file\n * @param options Options which govern the formatting of the file\n * @return Formatted hash-file content\n */\nexport function formatHashfileContent(\n  file: HashFile,\n  options?: Partial<HashfileFormatOptions>\n): string {\n  const lines: string[] = []\n  const opts = {\n    ...defaultFormatOptions,\n    ...(options || {})\n  }\n  for (const subject of file.subjects) {\n    let path\n    if (opts.absolute) {\n      path = resolve(normalize(subject.subject))\n    } else {\n      path = subject.subject\n    }\n    lines.push(`${subject.hash}${opts.separator}${path}`)\n  }\n  return lines.join('\\n')\n}\n\n/**\n * Generate a hash file for the specified `file`, and then write it as a peer, unless `name` is provided, in which case\n * it is used.\n *\n * @param file File to hash as the subject file\n * @param algo Algorithm to use for the hashing\n * @param encoding Encoding to use for encoding the hash value\n * @param path Path to write the hash file name at; can be a name, which is resolved against the subject file\n * @param options Options to apply when formatting the hash file\n * @return Object with the written hashfile path and generated hashfile content\n */\nexport async function writeHashfileForFile(\n  file: string,\n  algo: HashAlgorithm,\n  encoding: HashEncoding,\n  path?: string,\n  options?: Partial<HashfileFormatOptions>\n): Promise<{ path: string; content: HashFile }> {\n  const filename = basename(file)\n  const generated = generateHashfile(algo, encoding, [\n    { file: filename, content: await readFile(file) }\n  ])\n  const outpath = path\n    ? resolve(normalize(path))\n    : join(dirname(file), `${filename}.${algo}`)\n  const content = await generated\n  const formatted = formatHashfileContent(content, options)\n  await writeFile(outpath, formatted)\n  return { path: outpath, content }\n}\n\n/**\n * Generate a hash file for the specified `files`, and then write it as a peer at `name`.\n *\n * @param algo Algorithm to use for the hashing\n * @param encoding Encoding to use for encoding the hash value\n * @param path Path of the hash file to write\n * @param files Files to hash as the subject file\n * @param options Options to apply when formatting the file\n * @return Object with the written hashfile path and generated hashfile content\n */\nexport async function writeHashfileForFiles(\n  algo: HashAlgorithm,\n  encoding: HashEncoding,\n  path: string,\n  files: string[],\n  options?: Partial<HashfileFormatOptions>\n): Promise<{ path: string; content: HashFile }> {\n  const generated = generateHashfileForFiles(algo, encoding, files)\n  const outpath = resolve(normalize(path))\n  const content = await generated\n  const formatted = formatHashfileContent(content, options)\n  await writeFile(outpath, formatted)\n  return { path: outpath, content }\n}\n", "import expand from 'brace-expansion'\nimport { assertValidPattern } from './assert-valid-pattern.js'\nimport { AST, ExtglobType } from './ast.js'\nimport { escape } from './escape.js'\nimport { unescape } from './unescape.js'\n\ntype Platform =\n  | 'aix'\n  | 'android'\n  | 'darwin'\n  | 'freebsd'\n  | 'haiku'\n  | 'linux'\n  | 'openbsd'\n  | 'sunos'\n  | 'win32'\n  | 'cygwin'\n  | 'netbsd'\n\nexport interface MinimatchOptions {\n  nobrace?: boolean\n  nocomment?: boolean\n  nonegate?: boolean\n  debug?: boolean\n  noglobstar?: boolean\n  noext?: boolean\n  nonull?: boolean\n  windowsPathsNoEscape?: boolean\n  allowWindowsEscape?: boolean\n  partial?: boolean\n  dot?: boolean\n  nocase?: boolean\n  nocaseMagicOnly?: boolean\n  magicalBraces?: boolean\n  matchBase?: boolean\n  flipNegate?: boolean\n  preserveMultipleSlashes?: boolean\n  optimizationLevel?: number\n  platform?: Platform\n  windowsNoMagicRoot?: boolean\n}\n\nexport const minimatch = (\n  p: string,\n  pattern: string,\n  options: MinimatchOptions = {}\n) => {\n  assertValidPattern(pattern)\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  return new Minimatch(pattern, options).match(p)\n}\n\n// Optimized checking for the most common glob patterns.\nconst starDotExtRE = /^\\*+([^+@!?\\*\\[\\(]*)$/\nconst starDotExtTest = (ext: string) => (f: string) =>\n  !f.startsWith('.') && f.endsWith(ext)\nconst starDotExtTestDot = (ext: string) => (f: string) => f.endsWith(ext)\nconst starDotExtTestNocase = (ext: string) => {\n  ext = ext.toLowerCase()\n  return (f: string) => !f.startsWith('.') && f.toLowerCase().endsWith(ext)\n}\nconst starDotExtTestNocaseDot = (ext: string) => {\n  ext = ext.toLowerCase()\n  return (f: string) => f.toLowerCase().endsWith(ext)\n}\nconst starDotStarRE = /^\\*+\\.\\*+$/\nconst starDotStarTest = (f: string) => !f.startsWith('.') && f.includes('.')\nconst starDotStarTestDot = (f: string) =>\n  f !== '.' && f !== '..' && f.includes('.')\nconst dotStarRE = /^\\.\\*+$/\nconst dotStarTest = (f: string) => f !== '.' && f !== '..' && f.startsWith('.')\nconst starRE = /^\\*+$/\nconst starTest = (f: string) => f.length !== 0 && !f.startsWith('.')\nconst starTestDot = (f: string) => f.length !== 0 && f !== '.' && f !== '..'\nconst qmarksRE = /^\\?+([^+@!?\\*\\[\\(]*)?$/\nconst qmarksTestNocase = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExt([$0])\n  if (!ext) return noext\n  ext = ext.toLowerCase()\n  return (f: string) => noext(f) && f.toLowerCase().endsWith(ext)\n}\nconst qmarksTestNocaseDot = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExtDot([$0])\n  if (!ext) return noext\n  ext = ext.toLowerCase()\n  return (f: string) => noext(f) && f.toLowerCase().endsWith(ext)\n}\nconst qmarksTestDot = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExtDot([$0])\n  return !ext ? noext : (f: string) => noext(f) && f.endsWith(ext)\n}\nconst qmarksTest = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExt([$0])\n  return !ext ? noext : (f: string) => noext(f) && f.endsWith(ext)\n}\nconst qmarksTestNoExt = ([$0]: RegExpMatchArray) => {\n  const len = $0.length\n  return (f: string) => f.length === len && !f.startsWith('.')\n}\nconst qmarksTestNoExtDot = ([$0]: RegExpMatchArray) => {\n  const len = $0.length\n  return (f: string) => f.length === len && f !== '.' && f !== '..'\n}\n\n/* c8 ignore start */\nconst defaultPlatform: Platform = (\n  typeof process === 'object' && process\n    ? (typeof process.env === 'object' &&\n        process.env &&\n        process.env.__MINIMATCH_TESTING_PLATFORM__) ||\n      process.platform\n    : 'posix'\n) as Platform\ntype Sep = '\\\\' | '/'\nconst path: { [k: string]: { sep: Sep } } = {\n  win32: { sep: '\\\\' },\n  posix: { sep: '/' },\n}\n/* c8 ignore stop */\n\nexport const sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep\nminimatch.sep = sep\n\nexport const GLOBSTAR = Symbol('globstar **')\nminimatch.GLOBSTAR = GLOBSTAR\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]'\n\n// * => any number of characters\nconst star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = '(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = '(?:(?!(?:\\\\/|^)\\\\.).)*?'\n\nexport const filter =\n  (pattern: string, options: MinimatchOptions = {}) =>\n  (p: string) =>\n    minimatch(p, pattern, options)\nminimatch.filter = filter\n\nconst ext = (a: MinimatchOptions, b: MinimatchOptions = {}) =>\n  Object.assign({}, a, b)\n\nexport const defaults = (def: MinimatchOptions): typeof minimatch => {\n  if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n    return minimatch\n  }\n\n  const orig = minimatch\n\n  const m = (p: string, pattern: string, options: MinimatchOptions = {}) =>\n    orig(p, pattern, ext(def, options))\n\n  return Object.assign(m, {\n    Minimatch: class Minimatch extends orig.Minimatch {\n      constructor(pattern: string, options: MinimatchOptions = {}) {\n        super(pattern, ext(def, options))\n      }\n      static defaults(options: MinimatchOptions) {\n        return orig.defaults(ext(def, options)).Minimatch\n      }\n    },\n\n    AST: class AST extends orig.AST {\n      /* c8 ignore start */\n      constructor(\n        type: ExtglobType | null,\n        parent?: AST,\n        options: MinimatchOptions = {}\n      ) {\n        super(type, parent, ext(def, options))\n      }\n      /* c8 ignore stop */\n\n      static fromGlob(pattern: string, options: MinimatchOptions = {}) {\n        return orig.AST.fromGlob(pattern, ext(def, options))\n      }\n    },\n\n    unescape: (\n      s: string,\n      options: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n    ) => orig.unescape(s, ext(def, options)),\n\n    escape: (\n      s: string,\n      options: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n    ) => orig.escape(s, ext(def, options)),\n\n    filter: (pattern: string, options: MinimatchOptions = {}) =>\n      orig.filter(pattern, ext(def, options)),\n\n    defaults: (options: MinimatchOptions) => orig.defaults(ext(def, options)),\n\n    makeRe: (pattern: string, options: MinimatchOptions = {}) =>\n      orig.makeRe(pattern, ext(def, options)),\n\n    braceExpand: (pattern: string, options: MinimatchOptions = {}) =>\n      orig.braceExpand(pattern, ext(def, options)),\n\n    match: (list: string[], pattern: string, options: MinimatchOptions = {}) =>\n      orig.match(list, pattern, ext(def, options)),\n\n    sep: orig.sep,\n    GLOBSTAR: GLOBSTAR as typeof GLOBSTAR,\n  })\n}\nminimatch.defaults = defaults\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nexport const braceExpand = (\n  pattern: string,\n  options: MinimatchOptions = {}\n) => {\n  assertValidPattern(pattern)\n\n  // Thanks to Yeting Li <https://github.com/yetingli> for\n  // improving this regexp to avoid a ReDOS vulnerability.\n  if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\nminimatch.braceExpand = braceExpand\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\n\nexport const makeRe = (pattern: string, options: MinimatchOptions = {}) =>\n  new Minimatch(pattern, options).makeRe()\nminimatch.makeRe = makeRe\n\nexport const match = (\n  list: string[],\n  pattern: string,\n  options: MinimatchOptions = {}\n) => {\n  const mm = new Minimatch(pattern, options)\n  list = list.filter(f => mm.match(f))\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\nminimatch.match = match\n\n// replace stuff like \\* with *\nconst globMagic = /[?*]|[+@!]\\(.*?\\)|\\[|\\]/\nconst regExpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\nexport type MMRegExp = RegExp & {\n  _src?: string\n  _glob?: string\n}\n\nexport type ParseReturnFiltered = string | MMRegExp | typeof GLOBSTAR\nexport type ParseReturn = ParseReturnFiltered | false\n\nexport class Minimatch {\n  options: MinimatchOptions\n  set: ParseReturnFiltered[][]\n  pattern: string\n\n  windowsPathsNoEscape: boolean\n  nonegate: boolean\n  negate: boolean\n  comment: boolean\n  empty: boolean\n  preserveMultipleSlashes: boolean\n  partial: boolean\n  globSet: string[]\n  globParts: string[][]\n  nocase: boolean\n\n  isWindows: boolean\n  platform: Platform\n  windowsNoMagicRoot: boolean\n\n  regexp: false | null | MMRegExp\n  constructor(pattern: string, options: MinimatchOptions = {}) {\n    assertValidPattern(pattern)\n\n    options = options || {}\n    this.options = options\n    this.pattern = pattern\n    this.platform = options.platform || defaultPlatform\n    this.isWindows = this.platform === 'win32'\n    this.windowsPathsNoEscape =\n      !!options.windowsPathsNoEscape || options.allowWindowsEscape === false\n    if (this.windowsPathsNoEscape) {\n      this.pattern = this.pattern.replace(/\\\\/g, '/')\n    }\n    this.preserveMultipleSlashes = !!options.preserveMultipleSlashes\n    this.regexp = null\n    this.negate = false\n    this.nonegate = !!options.nonegate\n    this.comment = false\n    this.empty = false\n    this.partial = !!options.partial\n    this.nocase = !!this.options.nocase\n    this.windowsNoMagicRoot =\n      options.windowsNoMagicRoot !== undefined\n        ? options.windowsNoMagicRoot\n        : !!(this.isWindows && this.nocase)\n\n    this.globSet = []\n    this.globParts = []\n    this.set = []\n\n    // make the set of regexps etc.\n    this.make()\n  }\n\n  hasMagic(): boolean {\n    if (this.options.magicalBraces && this.set.length > 1) {\n      return true\n    }\n    for (const pattern of this.set) {\n      for (const part of pattern) {\n        if (typeof part !== 'string') return true\n      }\n    }\n    return false\n  }\n\n  debug(..._: any[]) {}\n\n  make() {\n    const pattern = this.pattern\n    const options = this.options\n\n    // empty patterns and comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n      this.comment = true\n      return\n    }\n\n    if (!pattern) {\n      this.empty = true\n      return\n    }\n\n    // step 1: figure out negation, etc.\n    this.parseNegate()\n\n    // step 2: expand braces\n    this.globSet = [...new Set(this.braceExpand())]\n\n    if (options.debug) {\n      this.debug = (...args: any[]) => console.error(...args)\n    }\n\n    this.debug(this.pattern, this.globSet)\n\n    // step 3: now we have a set, so turn each one into a series of\n    // path-portion matching patterns.\n    // These will be regexps, except in the case of \"**\", which is\n    // set to the GLOBSTAR object for globstar behavior,\n    // and will not contain any / characters\n    //\n    // First, we preprocess to make the glob pattern sets a bit simpler\n    // and deduped.  There are some perf-killing patterns that can cause\n    // problems with a glob walk, but we can simplify them down a bit.\n    const rawGlobParts = this.globSet.map(s => this.slashSplit(s))\n    this.globParts = this.preprocess(rawGlobParts)\n    this.debug(this.pattern, this.globParts)\n\n    // glob --> regexps\n    let set = this.globParts.map((s, _, __) => {\n      if (this.isWindows && this.windowsNoMagicRoot) {\n        // check if it's a drive or unc path.\n        const isUNC =\n          s[0] === '' &&\n          s[1] === '' &&\n          (s[2] === '?' || !globMagic.test(s[2])) &&\n          !globMagic.test(s[3])\n        const isDrive = /^[a-z]:/i.test(s[0])\n        if (isUNC) {\n          return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))]\n        } else if (isDrive) {\n          return [s[0], ...s.slice(1).map(ss => this.parse(ss))]\n        }\n      }\n      return s.map(ss => this.parse(ss))\n    })\n\n    this.debug(this.pattern, set)\n\n    // filter out everything that didn't compile properly.\n    this.set = set.filter(\n      s => s.indexOf(false) === -1\n    ) as ParseReturnFiltered[][]\n\n    // do not treat the ? in UNC paths as magic\n    if (this.isWindows) {\n      for (let i = 0; i < this.set.length; i++) {\n        const p = this.set[i]\n        if (\n          p[0] === '' &&\n          p[1] === '' &&\n          this.globParts[i][2] === '?' &&\n          typeof p[3] === 'string' &&\n          /^[a-z]:$/i.test(p[3])\n        ) {\n          p[2] = '?'\n        }\n      }\n    }\n\n    this.debug(this.pattern, this.set)\n  }\n\n  // various transforms to equivalent pattern sets that are\n  // faster to process in a filesystem walk.  The goal is to\n  // eliminate what we can, and push all ** patterns as far\n  // to the right as possible, even if it increases the number\n  // of patterns that we have to process.\n  preprocess(globParts: string[][]) {\n    // if we're not in globstar mode, then turn all ** into *\n    if (this.options.noglobstar) {\n      for (let i = 0; i < globParts.length; i++) {\n        for (let j = 0; j < globParts[i].length; j++) {\n          if (globParts[i][j] === '**') {\n            globParts[i][j] = '*'\n          }\n        }\n      }\n    }\n\n    const { optimizationLevel = 1 } = this.options\n\n    if (optimizationLevel >= 2) {\n      // aggressive optimization for the purpose of fs walking\n      globParts = this.firstPhasePreProcess(globParts)\n      globParts = this.secondPhasePreProcess(globParts)\n    } else if (optimizationLevel >= 1) {\n      // just basic optimizations to remove some .. parts\n      globParts = this.levelOneOptimize(globParts)\n    } else {\n      globParts = this.adjascentGlobstarOptimize(globParts)\n    }\n\n    return globParts\n  }\n\n  // just get rid of adjascent ** portions\n  adjascentGlobstarOptimize(globParts: string[][]) {\n    return globParts.map(parts => {\n      let gs: number = -1\n      while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n        let i = gs\n        while (parts[i + 1] === '**') {\n          i++\n        }\n        if (i !== gs) {\n          parts.splice(gs, i - gs)\n        }\n      }\n      return parts\n    })\n  }\n\n  // get rid of adjascent ** and resolve .. portions\n  levelOneOptimize(globParts: string[][]) {\n    return globParts.map(parts => {\n      parts = parts.reduce((set: string[], part) => {\n        const prev = set[set.length - 1]\n        if (part === '**' && prev === '**') {\n          return set\n        }\n        if (part === '..') {\n          if (prev && prev !== '..' && prev !== '.' && prev !== '**') {\n            set.pop()\n            return set\n          }\n        }\n        set.push(part)\n        return set\n      }, [])\n      return parts.length === 0 ? [''] : parts\n    })\n  }\n\n  levelTwoFileOptimize(parts: string | string[]) {\n    if (!Array.isArray(parts)) {\n      parts = this.slashSplit(parts)\n    }\n    let didSomething: boolean = false\n    do {\n      didSomething = false\n      // <pre>/<e>/<rest> -> <pre>/<rest>\n      if (!this.preserveMultipleSlashes) {\n        for (let i = 1; i < parts.length - 1; i++) {\n          const p = parts[i]\n          // don't squeeze out UNC patterns\n          if (i === 1 && p === '' && parts[0] === '') continue\n          if (p === '.' || p === '') {\n            didSomething = true\n            parts.splice(i, 1)\n            i--\n          }\n        }\n        if (\n          parts[0] === '.' &&\n          parts.length === 2 &&\n          (parts[1] === '.' || parts[1] === '')\n        ) {\n          didSomething = true\n          parts.pop()\n        }\n      }\n\n      // <pre>/<p>/../<rest> -> <pre>/<rest>\n      let dd: number = 0\n      while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n        const p = parts[dd - 1]\n        if (p && p !== '.' && p !== '..' && p !== '**') {\n          didSomething = true\n          parts.splice(dd - 1, 2)\n          dd -= 2\n        }\n      }\n    } while (didSomething)\n    return parts.length === 0 ? [''] : parts\n  }\n\n  // First phase: single-pattern processing\n  // <pre> is 1 or more portions\n  // <rest> is 1 or more portions\n  // <p> is any portion other than ., .., '', or **\n  // <e> is . or ''\n  //\n  // **/.. is *brutal* for filesystem walking performance, because\n  // it effectively resets the recursive walk each time it occurs,\n  // and ** cannot be reduced out by a .. pattern part like a regexp\n  // or most strings (other than .., ., and '') can be.\n  //\n  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n  // <pre>/<e>/<rest> -> <pre>/<rest>\n  // <pre>/<p>/../<rest> -> <pre>/<rest>\n  // **/**/<rest> -> **/<rest>\n  //\n  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow\n  // this WOULD be allowed if ** did follow symlinks, or * didn't\n  firstPhasePreProcess(globParts: string[][]) {\n    let didSomething = false\n    do {\n      didSomething = false\n      // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n      for (let parts of globParts) {\n        let gs: number = -1\n        while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n          let gss: number = gs\n          while (parts[gss + 1] === '**') {\n            // <pre>/**/**/<rest> -> <pre>/**/<rest>\n            gss++\n          }\n          // eg, if gs is 2 and gss is 4, that means we have 3 **\n          // parts, and can remove 2 of them.\n          if (gss > gs) {\n            parts.splice(gs + 1, gss - gs)\n          }\n\n          let next = parts[gs + 1]\n          const p = parts[gs + 2]\n          const p2 = parts[gs + 3]\n          if (next !== '..') continue\n          if (\n            !p ||\n            p === '.' ||\n            p === '..' ||\n            !p2 ||\n            p2 === '.' ||\n            p2 === '..'\n          ) {\n            continue\n          }\n          didSomething = true\n          // edit parts in place, and push the new one\n          parts.splice(gs, 1)\n          const other = parts.slice(0)\n          other[gs] = '**'\n          globParts.push(other)\n          gs--\n        }\n\n        // <pre>/<e>/<rest> -> <pre>/<rest>\n        if (!this.preserveMultipleSlashes) {\n          for (let i = 1; i < parts.length - 1; i++) {\n            const p = parts[i]\n            // don't squeeze out UNC patterns\n            if (i === 1 && p === '' && parts[0] === '') continue\n            if (p === '.' || p === '') {\n              didSomething = true\n              parts.splice(i, 1)\n              i--\n            }\n          }\n          if (\n            parts[0] === '.' &&\n            parts.length === 2 &&\n            (parts[1] === '.' || parts[1] === '')\n          ) {\n            didSomething = true\n            parts.pop()\n          }\n        }\n\n        // <pre>/<p>/../<rest> -> <pre>/<rest>\n        let dd: number = 0\n        while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n          const p = parts[dd - 1]\n          if (p && p !== '.' && p !== '..' && p !== '**') {\n            didSomething = true\n            const needDot = dd === 1 && parts[dd + 1] === '**'\n            const splin = needDot ? ['.'] : []\n            parts.splice(dd - 1, 2, ...splin)\n            if (parts.length === 0) parts.push('')\n            dd -= 2\n          }\n        }\n      }\n    } while (didSomething)\n\n    return globParts\n  }\n\n  // second phase: multi-pattern dedupes\n  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>\n  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>\n  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>\n  //\n  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>\n  // ^-- not valid because ** doens't follow symlinks\n  secondPhasePreProcess(globParts: string[][]): string[][] {\n    for (let i = 0; i < globParts.length - 1; i++) {\n      for (let j = i + 1; j < globParts.length; j++) {\n        const matched = this.partsMatch(\n          globParts[i],\n          globParts[j],\n          !this.preserveMultipleSlashes\n        )\n        if (!matched) continue\n        globParts[i] = matched\n        globParts[j] = []\n      }\n    }\n    return globParts.filter(gs => gs.length)\n  }\n\n  partsMatch(\n    a: string[],\n    b: string[],\n    emptyGSMatch: boolean = false\n  ): false | string[] {\n    let ai = 0\n    let bi = 0\n    let result: string[] = []\n    let which: string = ''\n    while (ai < a.length && bi < b.length) {\n      if (a[ai] === b[bi]) {\n        result.push(which === 'b' ? b[bi] : a[ai])\n        ai++\n        bi++\n      } else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {\n        result.push(a[ai])\n        ai++\n      } else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {\n        result.push(b[bi])\n        bi++\n      } else if (\n        a[ai] === '*' &&\n        b[bi] &&\n        (this.options.dot || !b[bi].startsWith('.')) &&\n        b[bi] !== '**'\n      ) {\n        if (which === 'b') return false\n        which = 'a'\n        result.push(a[ai])\n        ai++\n        bi++\n      } else if (\n        b[bi] === '*' &&\n        a[ai] &&\n        (this.options.dot || !a[ai].startsWith('.')) &&\n        a[ai] !== '**'\n      ) {\n        if (which === 'a') return false\n        which = 'b'\n        result.push(b[bi])\n        ai++\n        bi++\n      } else {\n        return false\n      }\n    }\n    // if we fall out of the loop, it means they two are identical\n    // as long as their lengths match\n    return a.length === b.length && result\n  }\n\n  parseNegate() {\n    if (this.nonegate) return\n\n    const pattern = this.pattern\n    let negate = false\n    let negateOffset = 0\n\n    for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {\n      negate = !negate\n      negateOffset++\n    }\n\n    if (negateOffset) this.pattern = pattern.slice(negateOffset)\n    this.negate = negate\n  }\n\n  // set partial to true to test if, for example,\n  // \"/a/b\" matches the start of \"/*/b/*/d\"\n  // Partial means, if you run out of file before you run\n  // out of pattern, then that's fine, as long as all\n  // the parts match.\n  matchOne(file: string[], pattern: ParseReturn[], partial: boolean = false) {\n    const options = this.options\n\n    // UNC paths like //?/X:/... can match X:/... and vice versa\n    // Drive letters in absolute drive or unc paths are always compared\n    // case-insensitively.\n    if (this.isWindows) {\n      const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0])\n      const fileUNC =\n        !fileDrive &&\n        file[0] === '' &&\n        file[1] === '' &&\n        file[2] === '?' &&\n        /^[a-z]:$/i.test(file[3])\n\n      const patternDrive =\n        typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0])\n      const patternUNC =\n        !patternDrive &&\n        pattern[0] === '' &&\n        pattern[1] === '' &&\n        pattern[2] === '?' &&\n        typeof pattern[3] === 'string' &&\n        /^[a-z]:$/i.test(pattern[3])\n\n      const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined\n      const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined\n      if (typeof fdi === 'number' && typeof pdi === 'number') {\n        const [fd, pd]: [string, string] = [file[fdi], pattern[pdi] as string]\n        if (fd.toLowerCase() === pd.toLowerCase()) {\n          pattern[pdi] = fd\n          if (pdi > fdi) {\n            pattern = pattern.slice( pdi)\n          } else if (fdi > pdi) {\n            file = file.slice(fdi)\n          }\n        }\n      }\n    }\n\n    // resolve and reduce . and .. portions in the file as well.\n    // dont' need to do the second phase, because it's only one string[]\n    const { optimizationLevel = 1 } = this.options\n    if (optimizationLevel >= 2) {\n      file = this.levelTwoFileOptimize(file)\n    }\n\n    this.debug('matchOne', this, { file, pattern })\n    this.debug('matchOne', file.length, pattern.length)\n\n    for (\n      var fi = 0, pi = 0, fl = file.length, pl = pattern.length;\n      fi < fl && pi < pl;\n      fi++, pi++\n    ) {\n      this.debug('matchOne loop')\n      var p = pattern[pi]\n      var f = file[fi]\n\n      this.debug(pattern, p, f)\n\n      // should be impossible.\n      // some invalid regexp stuff in the set.\n      /* c8 ignore start */\n      if (p === false) {\n        return false\n      }\n      /* c8 ignore stop */\n\n      if (p === GLOBSTAR) {\n        this.debug('GLOBSTAR', [pattern, p, f])\n\n        // \"**\"\n        // a/**/b/**/c would match the following:\n        // a/b/x/y/z/c\n        // a/x/y/z/b/c\n        // a/b/x/b/x/c\n        // a/b/c\n        // To do this, take the rest of the pattern after\n        // the **, and see if it would match the file remainder.\n        // If so, return success.\n        // If not, the ** \"swallows\" a segment, and try again.\n        // This is recursively awful.\n        //\n        // a/**/b/**/c matching a/b/x/y/z/c\n        // - a matches a\n        // - doublestar\n        //   - matchOne(b/x/y/z/c, b/**/c)\n        //     - b matches b\n        //     - doublestar\n        //       - matchOne(x/y/z/c, c) -> no\n        //       - matchOne(y/z/c, c) -> no\n        //       - matchOne(z/c, c) -> no\n        //       - matchOne(c, c) yes, hit\n        var fr = fi\n        var pr = pi + 1\n        if (pr === pl) {\n          this.debug('** at the end')\n          // a ** at the end will just swallow the rest.\n          // We have found a match.\n          // however, it will not swallow /.x, unless\n          // options.dot is set.\n          // . and .. are *never* matched by **, for explosively\n          // exponential reasons.\n          for (; fi < fl; fi++) {\n            if (\n              file[fi] === '.' ||\n              file[fi] === '..' ||\n              (!options.dot && file[fi].charAt(0) === '.')\n            )\n              return false\n          }\n          return true\n        }\n\n        // ok, let's see if we can swallow whatever we can.\n        while (fr < fl) {\n          var swallowee = file[fr]\n\n          this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n          // XXX remove this slice.  Just pass the start index.\n          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n            this.debug('globstar found match!', fr, fl, swallowee)\n            // found a match.\n            return true\n          } else {\n            // can't swallow \".\" or \"..\" ever.\n            // can only swallow \".foo\" when explicitly asked.\n            if (\n              swallowee === '.' ||\n              swallowee === '..' ||\n              (!options.dot && swallowee.charAt(0) === '.')\n            ) {\n              this.debug('dot detected!', file, fr, pattern, pr)\n              break\n            }\n\n            // ** swallows a segment, and continue.\n            this.debug('globstar swallow a segment, and continue')\n            fr++\n          }\n        }\n\n        // no match was found.\n        // However, in partial mode, we can't say this is necessarily over.\n        /* c8 ignore start */\n        if (partial) {\n          // ran out of file\n          this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n          if (fr === fl) {\n            return true\n          }\n        }\n        /* c8 ignore stop */\n        return false\n      }\n\n      // something other than **\n      // non-magic patterns just have to match exactly\n      // patterns with magic have been turned into regexps.\n      let hit: boolean\n      if (typeof p === 'string') {\n        hit = f === p\n        this.debug('string match', p, f, hit)\n      } else {\n        hit = p.test(f)\n        this.debug('pattern match', p, f, hit)\n      }\n\n      if (!hit) return false\n    }\n\n    // Note: ending in / means that we'll get a final \"\"\n    // at the end of the pattern.  This can only match a\n    // corresponding \"\" at the end of the file.\n    // If the file ends in /, then it can only match a\n    // a pattern that ends in /, unless the pattern just\n    // doesn't have any more for it. But, a/b/ should *not*\n    // match \"a/b/*\", even though \"\" matches against the\n    // [^/]*? pattern, except in partial mode, where it might\n    // simply not be reached yet.\n    // However, a/b/ should still satisfy a/*\n\n    // now either we fell off the end of the pattern, or we're done.\n    if (fi === fl && pi === pl) {\n      // ran out of pattern and filename at the same time.\n      // an exact hit!\n      return true\n    } else if (fi === fl) {\n      // ran out of file, but still had pattern left.\n      // this is ok if we're doing the match as part of\n      // a glob fs traversal.\n      return partial\n    } else if (pi === pl) {\n      // ran out of pattern, still have file left.\n      // this is only acceptable if we're on the very last\n      // empty segment of a file with a trailing slash.\n      // a/* should match a/b/\n      return fi === fl - 1 && file[fi] === ''\n\n      /* c8 ignore start */\n    } else {\n      // should be unreachable.\n      throw new Error('wtf?')\n    }\n    /* c8 ignore stop */\n  }\n\n  braceExpand() {\n    return braceExpand(this.pattern, this.options)\n  }\n\n  parse(pattern: string): ParseReturn {\n    assertValidPattern(pattern)\n\n    const options = this.options\n\n    // shortcuts\n    if (pattern === '**') return GLOBSTAR\n    if (pattern === '') return ''\n\n    // far and away, the most common glob pattern parts are\n    // *, *.*, and *.<ext>  Add a fast check method for those.\n    let m: RegExpMatchArray | null\n    let fastTest: null | ((f: string) => boolean) = null\n    if ((m = pattern.match(starRE))) {\n      fastTest = options.dot ? starTestDot : starTest\n    } else if ((m = pattern.match(starDotExtRE))) {\n      fastTest = (\n        options.nocase\n          ? options.dot\n            ? starDotExtTestNocaseDot\n            : starDotExtTestNocase\n          : options.dot\n          ? starDotExtTestDot\n          : starDotExtTest\n      )(m[1])\n    } else if ((m = pattern.match(qmarksRE))) {\n      fastTest = (\n        options.nocase\n          ? options.dot\n            ? qmarksTestNocaseDot\n            : qmarksTestNocase\n          : options.dot\n          ? qmarksTestDot\n          : qmarksTest\n      )(m)\n    } else if ((m = pattern.match(starDotStarRE))) {\n      fastTest = options.dot ? starDotStarTestDot : starDotStarTest\n    } else if ((m = pattern.match(dotStarRE))) {\n      fastTest = dotStarTest\n    }\n\n    const re = AST.fromGlob(pattern, this.options).toMMPattern()\n    return fastTest ? Object.assign(re, { test: fastTest }) : re\n  }\n\n  makeRe() {\n    if (this.regexp || this.regexp === false) return this.regexp\n\n    // at this point, this.set is a 2d array of partial\n    // pattern strings, or \"**\".\n    //\n    // It's better to use .match().  This function shouldn't\n    // be used, really, but it's pretty convenient sometimes,\n    // when you just want to work with a regex.\n    const set = this.set\n\n    if (!set.length) {\n      this.regexp = false\n      return this.regexp\n    }\n    const options = this.options\n\n    const twoStar = options.noglobstar\n      ? star\n      : options.dot\n      ? twoStarDot\n      : twoStarNoDot\n    const flags = new Set(options.nocase ? ['i'] : [])\n\n    // regexpify non-globstar patterns\n    // if ** is only item, then we just do one twoStar\n    // if ** is first, and there are more, prepend (\\/|twoStar\\/)? to next\n    // if ** is last, append (\\/twoStar|) to previous\n    // if ** is in the middle, append (\\/|\\/twoStar\\/) to previous\n    // then filter out GLOBSTAR symbols\n    let re = set\n      .map(pattern => {\n        const pp: (string | typeof GLOBSTAR)[] = pattern.map(p => {\n          if (p instanceof RegExp) {\n            for (const f of p.flags.split('')) flags.add(f)\n          }\n          return typeof p === 'string'\n            ? regExpEscape(p)\n            : p === GLOBSTAR\n            ? GLOBSTAR\n            : p._src\n        }) as (string | typeof GLOBSTAR)[]\n        pp.forEach((p, i) => {\n          const next = pp[i + 1]\n          const prev = pp[i - 1]\n          if (p !== GLOBSTAR || prev === GLOBSTAR) {\n            return\n          }\n          if (prev === undefined) {\n            if (next !== undefined && next !== GLOBSTAR) {\n              pp[i + 1] = '(?:\\\\/|' + twoStar + '\\\\/)?' + next\n            } else {\n              pp[i] = twoStar\n            }\n          } else if (next === undefined) {\n            pp[i - 1] = prev + '(?:\\\\/|' + twoStar + ')?'\n          } else if (next !== GLOBSTAR) {\n            pp[i - 1] = prev + '(?:\\\\/|\\\\/' + twoStar + '\\\\/)' + next\n            pp[i + 1] = GLOBSTAR\n          }\n        })\n        return pp.filter(p => p !== GLOBSTAR).join('/')\n      })\n      .join('|')\n\n    // need to wrap in parens if we had more than one thing with |,\n    // otherwise only the first will be anchored to ^ and the last to $\n    const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', '']\n    // must match entire pattern\n    // ending in a * or ** will make it less strict.\n    re = '^' + open + re + close + '$'\n\n    // can match anything, as long as it's not this.\n    if (this.negate) re = '^(?!' + re + ').+$'\n\n    try {\n      this.regexp = new RegExp(re, [...flags].join(''))\n      /* c8 ignore start */\n    } catch (ex) {\n      // should be impossible\n      this.regexp = false\n    }\n    /* c8 ignore stop */\n    return this.regexp\n  }\n\n  slashSplit(p: string) {\n    // if p starts with // on windows, we preserve that\n    // so that UNC paths aren't broken.  Otherwise, any number of\n    // / characters are coalesced into one, unless\n    // preserveMultipleSlashes is set to true.\n    if (this.preserveMultipleSlashes) {\n      return p.split('/')\n    } else if (this.isWindows && /^\\/\\/[^\\/]+/.test(p)) {\n      // add an extra '' for the one we lose\n      return ['', ...p.split(/\\/+/)]\n    } else {\n      return p.split(/\\/+/)\n    }\n  }\n\n  match(f: string, partial = this.partial) {\n    this.debug('match', f, this.pattern)\n    // short-circuit in the case of busted things.\n    // comments, etc.\n    if (this.comment) {\n      return false\n    }\n    if (this.empty) {\n      return f === ''\n    }\n\n    if (f === '/' && partial) {\n      return true\n    }\n\n    const options = this.options\n\n    // windows: need to use /, not \\\n    if (this.isWindows) {\n      f = f.split('\\\\').join('/')\n    }\n\n    // treat the test path as a set of pathparts.\n    const ff = this.slashSplit(f)\n    this.debug(this.pattern, 'split', ff)\n\n    // just ONE of the pattern sets in this.set needs to match\n    // in order for it to be valid.  If negating, then just one\n    // match means that we have failed.\n    // Either way, return on the first hit.\n\n    const set = this.set\n    this.debug(this.pattern, 'set', set)\n\n    // Find the basename of the path by looking for the last non-empty segment\n    let filename: string = ff[ff.length - 1]\n    if (!filename) {\n      for (let i = ff.length - 2; !filename && i >= 0; i--) {\n        filename = ff[i]\n      }\n    }\n\n    for (let i = 0; i < set.length; i++) {\n      const pattern = set[i]\n      let file = ff\n      if (options.matchBase && pattern.length === 1) {\n        file = [filename]\n      }\n      const hit = this.matchOne(file, pattern, partial)\n      if (hit) {\n        if (options.flipNegate) {\n          return true\n        }\n        return !this.negate\n      }\n    }\n\n    // didn't get any hits.  this is success if it's a negative\n    // pattern, failure otherwise.\n    if (options.flipNegate) {\n      return false\n    }\n    return this.negate\n  }\n\n  static defaults(def: MinimatchOptions) {\n    return minimatch.defaults(def).Minimatch\n  }\n}\n/* c8 ignore start */\nexport { AST } from './ast.js'\nexport { escape } from './escape.js'\nexport { unescape } from './unescape.js'\n/* c8 ignore stop */\nminimatch.AST = AST\nminimatch.Minimatch = Minimatch\nminimatch.escape = escape\nminimatch.unescape = unescape\n", "const MAX_PATTERN_LENGTH = 1024 * 64\nexport const assertValidPattern: (pattern: any) => void = (\n  pattern: any\n): asserts pattern is string => {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('invalid pattern')\n  }\n\n  if (pattern.length > MAX_PATTERN_LENGTH) {\n    throw new TypeError('pattern is too long')\n  }\n}\n", "// translate the various posix character classes into unicode properties\n// this works across all unicode locales\n\n// { <posix class>: [<translation>, /u flag required, negated]\nconst posixClasses: { [k: string]: [e: string, u: boolean, n?: boolean] } = {\n  '[:alnum:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}', true],\n  '[:alpha:]': ['\\\\p{L}\\\\p{Nl}', true],\n  '[:ascii:]': ['\\\\x' + '00-\\\\x' + '7f', false],\n  '[:blank:]': ['\\\\p{Zs}\\\\t', true],\n  '[:cntrl:]': ['\\\\p{Cc}', true],\n  '[:digit:]': ['\\\\p{Nd}', true],\n  '[:graph:]': ['\\\\p{Z}\\\\p{C}', true, true],\n  '[:lower:]': ['\\\\p{Ll}', true],\n  '[:print:]': ['\\\\p{C}', true],\n  '[:punct:]': ['\\\\p{P}', true],\n  '[:space:]': ['\\\\p{Z}\\\\t\\\\r\\\\n\\\\v\\\\f', true],\n  '[:upper:]': ['\\\\p{Lu}', true],\n  '[:word:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}\\\\p{Pc}', true],\n  '[:xdigit:]': ['A-Fa-f0-9', false],\n}\n\n// only need to escape a few things inside of brace expressions\n// escapes: [ \\ ] -\nconst braceEscape = (s: string) => s.replace(/[[\\]\\\\-]/g, '\\\\$&')\n// escape all regexp magic characters\nconst regexpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\n// everything has already been escaped, we just have to join\nconst rangesToString = (ranges: string[]): string => ranges.join('')\n\nexport type ParseClassResult = [\n  src: string,\n  uFlag: boolean,\n  consumed: number,\n  hasMagic: boolean\n]\n\n// takes a glob string at a posix brace expression, and returns\n// an equivalent regular expression source, and boolean indicating\n// whether the /u flag needs to be applied, and the number of chars\n// consumed to parse the character class.\n// This also removes out of order ranges, and returns ($.) if the\n// entire class just no good.\nexport const parseClass = (\n  glob: string,\n  position: number\n): ParseClassResult => {\n  const pos = position\n  /* c8 ignore start */\n  if (glob.charAt(pos) !== '[') {\n    throw new Error('not in a brace expression')\n  }\n  /* c8 ignore stop */\n  const ranges: string[] = []\n  const negs: string[] = []\n\n  let i = pos + 1\n  let sawStart = false\n  let uflag = false\n  let escaping = false\n  let negate = false\n  let endPos = pos\n  let rangeStart = ''\n  WHILE: while (i < glob.length) {\n    const c = glob.charAt(i)\n    if ((c === '!' || c === '^') && i === pos + 1) {\n      negate = true\n      i++\n      continue\n    }\n\n    if (c === ']' && sawStart && !escaping) {\n      endPos = i + 1\n      break\n    }\n\n    sawStart = true\n    if (c === '\\\\') {\n      if (!escaping) {\n        escaping = true\n        i++\n        continue\n      }\n      // escaped \\ char, fall through and treat like normal char\n    }\n    if (c === '[' && !escaping) {\n      // either a posix class, a collation equivalent, or just a [\n      for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {\n        if (glob.startsWith(cls, i)) {\n          // invalid, [a-[] is fine, but not [a-[:alpha]]\n          if (rangeStart) {\n            return ['$.', false, glob.length - pos, true]\n          }\n          i += cls.length\n          if (neg) negs.push(unip)\n          else ranges.push(unip)\n          uflag = uflag || u\n          continue WHILE\n        }\n      }\n    }\n\n    // now it's just a normal character, effectively\n    escaping = false\n    if (rangeStart) {\n      // throw this range away if it's not valid, but others\n      // can still match.\n      if (c > rangeStart) {\n        ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c))\n      } else if (c === rangeStart) {\n        ranges.push(braceEscape(c))\n      }\n      rangeStart = ''\n      i++\n      continue\n    }\n\n    // now might be the start of a range.\n    // can be either c-d or c-] or c<more...>] or c] at this point\n    if (glob.startsWith('-]', i + 1)) {\n      ranges.push(braceEscape(c + '-'))\n      i += 2\n      continue\n    }\n    if (glob.startsWith('-', i + 1)) {\n      rangeStart = c\n      i += 2\n      continue\n    }\n\n    // not the start of a range, just a single character\n    ranges.push(braceEscape(c))\n    i++\n  }\n\n  if (endPos < i) {\n    // didn't see the end of the class, not a valid class,\n    // but might still be valid as a literal match.\n    return ['', false, 0, false]\n  }\n\n  // if we got no ranges and no negates, then we have a range that\n  // cannot possibly match anything, and that poisons the whole glob\n  if (!ranges.length && !negs.length) {\n    return ['$.', false, glob.length - pos, true]\n  }\n\n  // if we got one positive range, and it's a single character, then that's\n  // not actually a magic pattern, it's just that one literal character.\n  // we should not treat that as \"magic\", we should just return the literal\n  // character. [_] is a perfectly valid way to escape glob magic chars.\n  if (\n    negs.length === 0 &&\n    ranges.length === 1 &&\n    /^\\\\?.$/.test(ranges[0]) &&\n    !negate\n  ) {\n    const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0]\n    return [regexpEscape(r), false, endPos - pos, false]\n  }\n\n  const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']'\n  const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']'\n  const comb =\n    ranges.length && negs.length\n      ? '(' + sranges + '|' + snegs + ')'\n      : ranges.length\n      ? sranges\n      : snegs\n\n  return [comb, uflag, endPos - pos, true]\n}\n", "import { MinimatchOptions } from './index.js'\n/**\n * Un-escape a string that has been escaped with {@link escape}.\n *\n * If the {@link windowsPathsNoEscape} option is used, then square-brace\n * escapes are removed, but not backslash escapes.  For example, it will turn\n * the string `'[*]'` into `*`, but it will not turn `'\\\\*'` into `'*'`,\n * becuase `\\` is a path separator in `windowsPathsNoEscape` mode.\n *\n * When `windowsPathsNoEscape` is not set, then both brace escapes and\n * backslash escapes are removed.\n *\n * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped\n * or unescaped.\n */\nexport const unescape = (\n  s: string,\n  {\n    windowsPathsNoEscape = false,\n  }: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n) => {\n  return windowsPathsNoEscape\n    ? s.replace(/\\[([^\\/\\\\])\\]/g, '$1')\n    : s.replace(/((?!\\\\).|^)\\[([^\\/\\\\])\\]/g, '$1$2').replace(/\\\\([^\\/])/g, '$1')\n}\n", "// parse a single path portion\n\nimport { parseClass } from './brace-expressions.js'\nimport { MinimatchOptions, MMRegExp } from './index.js'\nimport { unescape } from './unescape.js'\n\n// classes [] are handled by the parseClass method\n// for positive extglobs, we sub-parse the contents, and combine,\n// with the appropriate regexp close.\n// for negative extglobs, we sub-parse the contents, but then\n// have to include the rest of the pattern, then the parent, etc.,\n// as the thing that cannot be because RegExp negative lookaheads\n// are different from globs.\n//\n// So for example:\n// a@(i|w!(x|y)z|j)b => ^a(i|w((!?(x|y)zb).*)z|j)b$\n//   1   2 3   4 5 6      1   2    3   46      5 6\n//\n// Assembling the extglob requires not just the negated patterns themselves,\n// but also anything following the negative patterns up to the boundary\n// of the current pattern, plus anything following in the parent pattern.\n//\n//\n// So, first, we parse the string into an AST of extglobs, without turning\n// anything into regexps yet.\n//\n// ['a', {@ [['i'], ['w', {!['x', 'y']}, 'z'], ['j']]}, 'b']\n//\n// Then, for all the negative extglobs, we append whatever comes after in\n// each parent as their tail\n//\n// ['a', {@ [['i'], ['w', {!['x', 'y'], 'z', 'b'}, 'z'], ['j']]}, 'b']\n//\n// Lastly, we turn each of these pieces into a regexp, and join\n//\n//                                 v----- .* because there's more following,\n//                                 v    v  otherwise, .+ because it must be\n//                                 v    v  *something* there.\n// ['^a', {@ ['i', 'w(?:(!?(?:x|y).*zb$).*)z', 'j' ]}, 'b$']\n//   copy what follows into here--^^^^^\n// ['^a', '(?:i|w(?:(?!(?:x|y).*zb$).*)z|j)', 'b$']\n// ['^a(?:i|w(?:(?!(?:x|y).*zb$).*)z|j)b$']\n\nexport type ExtglobType = '!' | '?' | '+' | '*' | '@'\nconst types = new Set<ExtglobType>(['!', '?', '+', '*', '@'])\nconst isExtglobType = (c: string): c is ExtglobType =>\n  types.has(c as ExtglobType)\n\n// Patterns that get prepended to bind to the start of either the\n// entire string, or just a single path portion, to prevent dots\n// and/or traversal patterns, when needed.\n// Exts don't need the ^ or / bit, because the root binds that already.\nconst startNoTraversal = '(?!(?:^|/)\\\\.\\\\.?(?:$|/))'\nconst startNoDot = '(?!\\\\.)'\n\n// characters that indicate a start of pattern needs the \"no dots\" bit,\n// because a dot *might* be matched. ( is not in the list, because in\n// the case of a child extglob, it will handle the prevention itself.\nconst addPatternStart = new Set(['[', '.'])\n// cases where traversal is A-OK, no dot prevention needed\nconst justDots = new Set(['..', '.'])\nconst reSpecials = new Set('().*{}+?[]^$\\\\!')\nconst regExpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\n// any single thing other than /\nconst qmark = '[^/]'\n\n// * => any number of characters\nconst star = qmark + '*?'\n// use + when we need to ensure that *something* matches, because the * is\n// the only thing in the path portion.\nconst starNoEmpty = qmark + '+?'\n\n// remove the \\ chars that we added if we end up doing a nonmagic compare\n// const deslash = (s: string) => s.replace(/\\\\(.)/g, '$1')\n\nexport class AST {\n  type: ExtglobType | null\n  readonly #root: AST\n\n  #hasMagic?: boolean\n  #uflag: boolean = false\n  #parts: (string | AST)[] = []\n  readonly #parent?: AST\n  readonly #parentIndex: number\n  #negs: AST[]\n  #filledNegs: boolean = false\n  #options: MinimatchOptions\n  #toString?: string\n  // set to true if it's an extglob with no children\n  // (which really means one child of '')\n  #emptyExt: boolean = false\n\n  constructor(\n    type: ExtglobType | null,\n    parent?: AST,\n    options: MinimatchOptions = {}\n  ) {\n    this.type = type\n    // extglobs are inherently magical\n    if (type) this.#hasMagic = true\n    this.#parent = parent\n    this.#root = this.#parent ? this.#parent.#root : this\n    this.#options = this.#root === this ? options : this.#root.#options\n    this.#negs = this.#root === this ? [] : this.#root.#negs\n    if (type === '!' && !this.#root.#filledNegs) this.#negs.push(this)\n    this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0\n  }\n\n  get hasMagic(): boolean | undefined {\n    /* c8 ignore start */\n    if (this.#hasMagic !== undefined) return this.#hasMagic\n    /* c8 ignore stop */\n    for (const p of this.#parts) {\n      if (typeof p === 'string') continue\n      if (p.type || p.hasMagic) return (this.#hasMagic = true)\n    }\n    // note: will be undefined until we generate the regexp src and find out\n    return this.#hasMagic\n  }\n\n  // reconstructs the pattern\n  toString(): string {\n    if (this.#toString !== undefined) return this.#toString\n    if (!this.type) {\n      return (this.#toString = this.#parts.map(p => String(p)).join(''))\n    } else {\n      return (this.#toString =\n        this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')')\n    }\n  }\n\n  #fillNegs() {\n    /* c8 ignore start */\n    if (this !== this.#root) throw new Error('should only call on root')\n    if (this.#filledNegs) return this\n    /* c8 ignore stop */\n\n    // call toString() once to fill this out\n    this.toString()\n    this.#filledNegs = true\n    let n: AST | undefined\n    while ((n = this.#negs.pop())) {\n      if (n.type !== '!') continue\n      // walk up the tree, appending everthing that comes AFTER parentIndex\n      let p: AST | undefined = n\n      let pp = p.#parent\n      while (pp) {\n        for (\n          let i = p.#parentIndex + 1;\n          !pp.type && i < pp.#parts.length;\n          i++\n        ) {\n          for (const part of n.#parts) {\n            /* c8 ignore start */\n            if (typeof part === 'string') {\n              throw new Error('string part in extglob AST??')\n            }\n            /* c8 ignore stop */\n            part.copyIn(pp.#parts[i])\n          }\n        }\n        p = pp\n        pp = p.#parent\n      }\n    }\n    return this\n  }\n\n  push(...parts: (string | AST)[]) {\n    for (const p of parts) {\n      if (p === '') continue\n      /* c8 ignore start */\n      if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {\n        throw new Error('invalid part: ' + p)\n      }\n      /* c8 ignore stop */\n      this.#parts.push(p)\n    }\n  }\n\n  toJSON() {\n    const ret: any[] =\n      this.type === null\n        ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))\n        : [this.type, ...this.#parts.map(p => (p as AST).toJSON())]\n    if (this.isStart() && !this.type) ret.unshift([])\n    if (\n      this.isEnd() &&\n      (this === this.#root ||\n        (this.#root.#filledNegs && this.#parent?.type === '!'))\n    ) {\n      ret.push({})\n    }\n    return ret\n  }\n\n  isStart(): boolean {\n    if (this.#root === this) return true\n    // if (this.type) return !!this.#parent?.isStart()\n    if (!this.#parent?.isStart()) return false\n    if (this.#parentIndex === 0) return true\n    // if everything AHEAD of this is a negation, then it's still the \"start\"\n    const p = this.#parent\n    for (let i = 0; i < this.#parentIndex; i++) {\n      const pp = p.#parts[i]\n      if (!(pp instanceof AST && pp.type === '!')) {\n        return false\n      }\n    }\n    return true\n  }\n\n  isEnd(): boolean {\n    if (this.#root === this) return true\n    if (this.#parent?.type === '!') return true\n    if (!this.#parent?.isEnd()) return false\n    if (!this.type) return this.#parent?.isEnd()\n    // if not root, it'll always have a parent\n    /* c8 ignore start */\n    const pl = this.#parent ? this.#parent.#parts.length : 0\n    /* c8 ignore stop */\n    return this.#parentIndex === pl - 1\n  }\n\n  copyIn(part: AST | string) {\n    if (typeof part === 'string') this.push(part)\n    else this.push(part.clone(this))\n  }\n\n  clone(parent: AST) {\n    const c = new AST(this.type, parent)\n    for (const p of this.#parts) {\n      c.copyIn(p)\n    }\n    return c\n  }\n\n  static #parseAST(\n    str: string,\n    ast: AST,\n    pos: number,\n    opt: MinimatchOptions\n  ): number {\n    let escaping = false\n    let inBrace = false\n    let braceStart = -1\n    let braceNeg = false\n    if (ast.type === null) {\n      // outside of a extglob, append until we find a start\n      let i = pos\n      let acc = ''\n      while (i < str.length) {\n        const c = str.charAt(i++)\n        // still accumulate escapes at this point, but we do ignore\n        // starts that are escaped\n        if (escaping || c === '\\\\') {\n          escaping = !escaping\n          acc += c\n          continue\n        }\n\n        if (inBrace) {\n          if (i === braceStart + 1) {\n            if (c === '^' || c === '!') {\n              braceNeg = true\n            }\n          } else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n            inBrace = false\n          }\n          acc += c\n          continue\n        } else if (c === '[') {\n          inBrace = true\n          braceStart = i\n          braceNeg = false\n          acc += c\n          continue\n        }\n\n        if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {\n          ast.push(acc)\n          acc = ''\n          const ext = new AST(c, ast)\n          i = AST.#parseAST(str, ext, i, opt)\n          ast.push(ext)\n          continue\n        }\n        acc += c\n      }\n      ast.push(acc)\n      return i\n    }\n\n    // some kind of extglob, pos is at the (\n    // find the next | or )\n    let i = pos + 1\n    let part = new AST(null, ast)\n    const parts: AST[] = []\n    let acc = ''\n    while (i < str.length) {\n      const c = str.charAt(i++)\n      // still accumulate escapes at this point, but we do ignore\n      // starts that are escaped\n      if (escaping || c === '\\\\') {\n        escaping = !escaping\n        acc += c\n        continue\n      }\n\n      if (inBrace) {\n        if (i === braceStart + 1) {\n          if (c === '^' || c === '!') {\n            braceNeg = true\n          }\n        } else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n          inBrace = false\n        }\n        acc += c\n        continue\n      } else if (c === '[') {\n        inBrace = true\n        braceStart = i\n        braceNeg = false\n        acc += c\n        continue\n      }\n\n      if (isExtglobType(c) && str.charAt(i) === '(') {\n        part.push(acc)\n        acc = ''\n        const ext = new AST(c, part)\n        part.push(ext)\n        i = AST.#parseAST(str, ext, i, opt)\n        continue\n      }\n      if (c === '|') {\n        part.push(acc)\n        acc = ''\n        parts.push(part)\n        part = new AST(null, ast)\n        continue\n      }\n      if (c === ')') {\n        if (acc === '' && ast.#parts.length === 0) {\n          ast.#emptyExt = true\n        }\n        part.push(acc)\n        acc = ''\n        ast.push(...parts, part)\n        return i\n      }\n      acc += c\n    }\n\n    // unfinished extglob\n    // if we got here, it was a malformed extglob! not an extglob, but\n    // maybe something else in there.\n    ast.type = null\n    ast.#hasMagic = undefined\n    ast.#parts = [str.substring(pos - 1)]\n    return i\n  }\n\n  static fromGlob(pattern: string, options: MinimatchOptions = {}) {\n    const ast = new AST(null, undefined, options)\n    AST.#parseAST(pattern, ast, 0, options)\n    return ast\n  }\n\n  // returns the regular expression if there's magic, or the unescaped\n  // string if not.\n  toMMPattern(): MMRegExp | string {\n    // should only be called on root\n    /* c8 ignore start */\n    if (this !== this.#root) return this.#root.toMMPattern()\n    /* c8 ignore stop */\n    const glob = this.toString()\n    const [re, body, hasMagic, uflag] = this.toRegExpSource()\n    // if we're in nocase mode, and not nocaseMagicOnly, then we do\n    // still need a regular expression if we have to case-insensitively\n    // match capital/lowercase characters.\n    const anyMagic =\n      hasMagic ||\n      this.#hasMagic ||\n      (this.#options.nocase &&\n        !this.#options.nocaseMagicOnly &&\n        glob.toUpperCase() !== glob.toLowerCase())\n    if (!anyMagic) {\n      return body\n    }\n\n    const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '')\n    return Object.assign(new RegExp(`^${re}$`, flags), {\n      _src: re,\n      _glob: glob,\n    })\n  }\n\n  // returns the string match, the regexp source, whether there's magic\n  // in the regexp (so a regular expression is required) and whether or\n  // not the uflag is needed for the regular expression (for posix classes)\n  // TODO: instead of injecting the start/end at this point, just return\n  // the BODY of the regexp, along with the start/end portions suitable\n  // for binding the start/end in either a joined full-path makeRe context\n  // (where we bind to (^|/), or a standalone matchPart context (where\n  // we bind to ^, and not /).  Otherwise slashes get duped!\n  //\n  // In part-matching mode, the start is:\n  // - if not isStart: nothing\n  // - if traversal possible, but not allowed: ^(?!\\.\\.?$)\n  // - if dots allowed or not possible: ^\n  // - if dots possible and not allowed: ^(?!\\.)\n  // end is:\n  // - if not isEnd(): nothing\n  // - else: $\n  //\n  // In full-path matching mode, we put the slash at the START of the\n  // pattern, so start is:\n  // - if first pattern: same as part-matching mode\n  // - if not isStart(): nothing\n  // - if traversal possible, but not allowed: /(?!\\.\\.?(?:$|/))\n  // - if dots allowed or not possible: /\n  // - if dots possible and not allowed: /(?!\\.)\n  // end is:\n  // - if last pattern, same as part-matching mode\n  // - else nothing\n  //\n  // Always put the (?:$|/) on negated tails, though, because that has to be\n  // there to bind the end of the negated pattern portion, and it's easier to\n  // just stick it in now rather than try to inject it later in the middle of\n  // the pattern.\n  //\n  // We can just always return the same end, and leave it up to the caller\n  // to know whether it's going to be used joined or in parts.\n  // And, if the start is adjusted slightly, can do the same there:\n  // - if not isStart: nothing\n  // - if traversal possible, but not allowed: (?:/|^)(?!\\.\\.?$)\n  // - if dots allowed or not possible: (?:/|^)\n  // - if dots possible and not allowed: (?:/|^)(?!\\.)\n  //\n  // But it's better to have a simpler binding without a conditional, for\n  // performance, so probably better to return both start options.\n  //\n  // Then the caller just ignores the end if it's not the first pattern,\n  // and the start always gets applied.\n  //\n  // But that's always going to be $ if it's the ending pattern, or nothing,\n  // so the caller can just attach $ at the end of the pattern when building.\n  //\n  // So the todo is:\n  // - better detect what kind of start is needed\n  // - return both flavors of starting pattern\n  // - attach $ at the end of the pattern when creating the actual RegExp\n  //\n  // Ah, but wait, no, that all only applies to the root when the first pattern\n  // is not an extglob. If the first pattern IS an extglob, then we need all\n  // that dot prevention biz to live in the extglob portions, because eg\n  // +(*|.x*) can match .xy but not .yx.\n  //\n  // So, return the two flavors if it's #root and the first child is not an\n  // AST, otherwise leave it to the child AST to handle it, and there,\n  // use the (?:^|/) style of start binding.\n  //\n  // Even simplified further:\n  // - Since the start for a join is eg /(?!\\.) and the start for a part\n  // is ^(?!\\.), we can just prepend (?!\\.) to the pattern (either root\n  // or start or whatever) and prepend ^ or / at the Regexp construction.\n  toRegExpSource(\n    allowDot?: boolean\n  ): [re: string, body: string, hasMagic: boolean, uflag: boolean] {\n    const dot = allowDot ?? !!this.#options.dot\n    if (this.#root === this) this.#fillNegs()\n    if (!this.type) {\n      const noEmpty = this.isStart() && this.isEnd()\n      const src = this.#parts\n        .map(p => {\n          const [re, _, hasMagic, uflag] =\n            typeof p === 'string'\n              ? AST.#parseGlob(p, this.#hasMagic, noEmpty)\n              : p.toRegExpSource(allowDot)\n          this.#hasMagic = this.#hasMagic || hasMagic\n          this.#uflag = this.#uflag || uflag\n          return re\n        })\n        .join('')\n\n      let start = ''\n      if (this.isStart()) {\n        if (typeof this.#parts[0] === 'string') {\n          // this is the string that will match the start of the pattern,\n          // so we need to protect against dots and such.\n\n          // '.' and '..' cannot match unless the pattern is that exactly,\n          // even if it starts with . or dot:true is set.\n          const dotTravAllowed =\n            this.#parts.length === 1 && justDots.has(this.#parts[0])\n          if (!dotTravAllowed) {\n            const aps = addPatternStart\n            // check if we have a possibility of matching . or ..,\n            // and prevent that.\n            const needNoTrav =\n              // dots are allowed, and the pattern starts with [ or .\n              (dot && aps.has(src.charAt(0))) ||\n              // the pattern starts with \\., and then [ or .\n              (src.startsWith('\\\\.') && aps.has(src.charAt(2))) ||\n              // the pattern starts with \\.\\., and then [ or .\n              (src.startsWith('\\\\.\\\\.') && aps.has(src.charAt(4)))\n            // no need to prevent dots if it can't match a dot, or if a\n            // sub-pattern will be preventing it anyway.\n            const needNoDot = !dot && !allowDot && aps.has(src.charAt(0))\n\n            start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : ''\n          }\n        }\n      }\n\n      // append the \"end of path portion\" pattern to negation tails\n      let end = ''\n      if (\n        this.isEnd() &&\n        this.#root.#filledNegs &&\n        this.#parent?.type === '!'\n      ) {\n        end = '(?:$|\\\\/)'\n      }\n      const final = start + src + end\n      return [\n        final,\n        unescape(src),\n        (this.#hasMagic = !!this.#hasMagic),\n        this.#uflag,\n      ]\n    }\n\n    // We need to calculate the body *twice* if it's a repeat pattern\n    // at the start, once in nodot mode, then again in dot mode, so a\n    // pattern like *(?) can match 'x.y'\n\n    const repeated = this.type === '*' || this.type === '+'\n    // some kind of extglob\n    const start = this.type === '!' ? '(?:(?!(?:' : '(?:'\n    let body = this.#partsToRegExp(dot)\n\n    if (this.isStart() && this.isEnd() && !body && this.type !== '!') {\n      // invalid extglob, has to at least be *something* present, if it's\n      // the entire path portion.\n      const s = this.toString()\n      this.#parts = [s]\n      this.type = null\n      this.#hasMagic = undefined\n      return [s, unescape(this.toString()), false, false]\n    }\n\n    // XXX abstract out this map method\n    let bodyDotAllowed =\n      !repeated || allowDot || dot || !startNoDot\n        ? ''\n        : this.#partsToRegExp(true)\n    if (bodyDotAllowed === body) {\n      bodyDotAllowed = ''\n    }\n    if (bodyDotAllowed) {\n      body = `(?:${body})(?:${bodyDotAllowed})*?`\n    }\n\n    // an empty !() is exactly equivalent to a starNoEmpty\n    let final = ''\n    if (this.type === '!' && this.#emptyExt) {\n      final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty\n    } else {\n      const close =\n        this.type === '!'\n          ? // !() must match something,but !(x) can match ''\n            '))' +\n            (this.isStart() && !dot && !allowDot ? startNoDot : '') +\n            star +\n            ')'\n          : this.type === '@'\n          ? ')'\n          : this.type === '?'\n          ? ')?'\n          : this.type === '+' && bodyDotAllowed\n          ? ')'\n          : this.type === '*' && bodyDotAllowed\n          ? `)?`\n          : `)${this.type}`\n      final = start + body + close\n    }\n    return [\n      final,\n      unescape(body),\n      (this.#hasMagic = !!this.#hasMagic),\n      this.#uflag,\n    ]\n  }\n\n  #partsToRegExp(dot: boolean) {\n    return this.#parts\n      .map(p => {\n        // extglob ASTs should only contain parent ASTs\n        /* c8 ignore start */\n        if (typeof p === 'string') {\n          throw new Error('string type in extglob ast??')\n        }\n        /* c8 ignore stop */\n        // can ignore hasMagic, because extglobs are already always magic\n        const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot)\n        this.#uflag = this.#uflag || uflag\n        return re\n      })\n      .filter(p => !(this.isStart() && this.isEnd()) || !!p)\n      .join('|')\n  }\n\n  static #parseGlob(\n    glob: string,\n    hasMagic: boolean | undefined,\n    noEmpty: boolean = false\n  ): [re: string, body: string, hasMagic: boolean, uflag: boolean] {\n    let escaping = false\n    let re = ''\n    let uflag = false\n    for (let i = 0; i < glob.length; i++) {\n      const c = glob.charAt(i)\n      if (escaping) {\n        escaping = false\n        re += (reSpecials.has(c) ? '\\\\' : '') + c\n        continue\n      }\n      if (c === '\\\\') {\n        if (i === glob.length - 1) {\n          re += '\\\\\\\\'\n        } else {\n          escaping = true\n        }\n        continue\n      }\n      if (c === '[') {\n        const [src, needUflag, consumed, magic] = parseClass(glob, i)\n        if (consumed) {\n          re += src\n          uflag = uflag || needUflag\n          i += consumed - 1\n          hasMagic = hasMagic || magic\n          continue\n        }\n      }\n      if (c === '*') {\n        if (noEmpty && glob === '*') re += starNoEmpty\n        else re += star\n        hasMagic = true\n        continue\n      }\n      if (c === '?') {\n        re += qmark\n        hasMagic = true\n        continue\n      }\n      re += regExpEscape(c)\n    }\n    return [re, unescape(glob), !!hasMagic, uflag]\n  }\n}\n", "import { MinimatchOptions } from './index.js'\n/**\n * Escape all magic characters in a glob pattern.\n *\n * If the {@link windowsPathsNoEscape | GlobOptions.windowsPathsNoEscape}\n * option is used, then characters are escaped by wrapping in `[]`, because\n * a magic character wrapped in a character class can only be satisfied by\n * that exact character.  In this mode, `\\` is _not_ escaped, because it is\n * not interpreted as a magic character, but instead as a path separator.\n */\nexport const escape = (\n  s: string,\n  {\n    windowsPathsNoEscape = false,\n  }: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n) => {\n  // don't need to escape +@! because we escape the parens\n  // that make those magic, and escaping ! as [!] isn't valid,\n  // because [!]] is a valid glob class meaning not ']'.\n  return windowsPathsNoEscape\n    ? s.replace(/[?*()[\\]]/g, '[$&]')\n    : s.replace(/[?*()[\\]\\\\]/g, '\\\\$&')\n}\n", "/**\n * @module LRUCache\n */\n\n// module-private names and types\ntype Perf = { now: () => number }\nconst perf: Perf =\n  typeof performance === 'object' &&\n  performance &&\n  typeof performance.now === 'function'\n    ? performance\n    : Date\n\nconst warned = new Set<string>()\n\n// either a function or a class\ntype ForC = ((...a: any[]) => any) | { new (...a: any[]): any }\n\n/* c8 ignore start */\nconst PROCESS = (\n  typeof process === 'object' && !!process ? process : {}\n) as { [k: string]: any }\n/* c8 ignore start */\n\nconst emitWarning = (\n  msg: string,\n  type: string,\n  code: string,\n  fn: ForC\n) => {\n  typeof PROCESS.emitWarning === 'function'\n    ? PROCESS.emitWarning(msg, type, code, fn)\n    : console.error(`[${code}] ${type}: ${msg}`)\n}\n\nlet AC = globalThis.AbortController\nlet AS = globalThis.AbortSignal\n\n/* c8 ignore start */\nif (typeof AC === 'undefined') {\n  //@ts-ignore\n  AS = class AbortSignal {\n    onabort?: (...a: any[]) => any\n    _onabort: ((...a: any[]) => any)[] = []\n    reason?: any\n    aborted: boolean = false\n    addEventListener(_: string, fn: (...a: any[]) => any) {\n      this._onabort.push(fn)\n    }\n  }\n  //@ts-ignore\n  AC = class AbortController {\n    constructor() {\n      warnACPolyfill()\n    }\n    signal = new AS()\n    abort(reason: any) {\n      if (this.signal.aborted) return\n      //@ts-ignore\n      this.signal.reason = reason\n      //@ts-ignore\n      this.signal.aborted = true\n      //@ts-ignore\n      for (const fn of this.signal._onabort) {\n        fn(reason)\n      }\n      this.signal.onabort?.(reason)\n    }\n  }\n  let printACPolyfillWarning =\n    PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1'\n  const warnACPolyfill = () => {\n    if (!printACPolyfillWarning) return\n    printACPolyfillWarning = false\n    emitWarning(\n      'AbortController is not defined. If using lru-cache in ' +\n        'node 14, load an AbortController polyfill from the ' +\n        '`node-abort-controller` package. A minimal polyfill is ' +\n        'provided for use by LRUCache.fetch(), but it should not be ' +\n        'relied upon in other contexts (eg, passing it to other APIs that ' +\n        'use AbortController/AbortSignal might have undesirable effects). ' +\n        'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.',\n      'NO_ABORT_CONTROLLER',\n      'ENOTSUP',\n      warnACPolyfill\n    )\n  }\n}\n/* c8 ignore stop */\n\nconst shouldWarn = (code: string) => !warned.has(code)\n\nconst TYPE = Symbol('type')\nexport type PosInt = number & { [TYPE]: 'Positive Integer' }\nexport type Index = number & { [TYPE]: 'LRUCache Index' }\n\nconst isPosInt = (n: any): n is PosInt =>\n  n && n === Math.floor(n) && n > 0 && isFinite(n)\n\nexport type UintArray = Uint8Array | Uint16Array | Uint32Array\nexport type NumberArray = UintArray | number[]\n\n/* c8 ignore start */\n// This is a little bit ridiculous, tbh.\n// The maximum array length is 2^32-1 or thereabouts on most JS impls.\n// And well before that point, you're caching the entire world, I mean,\n// that's ~32GB of just integers for the next/prev links, plus whatever\n// else to hold that many keys and values.  Just filling the memory with\n// zeroes at init time is brutal when you get that big.\n// But why not be complete?\n// Maybe in the future, these limits will have expanded.\nconst getUintArray = (max: number) =>\n  !isPosInt(max)\n    ? null\n    : max <= Math.pow(2, 8)\n    ? Uint8Array\n    : max <= Math.pow(2, 16)\n    ? Uint16Array\n    : max <= Math.pow(2, 32)\n    ? Uint32Array\n    : max <= Number.MAX_SAFE_INTEGER\n    ? ZeroArray\n    : null\n/* c8 ignore stop */\n\nclass ZeroArray extends Array<number> {\n  constructor(size: number) {\n    super(size)\n    this.fill(0)\n  }\n}\nexport type { ZeroArray }\nexport type { Stack }\n\nexport type StackLike = Stack | Index[]\nclass Stack {\n  heap: NumberArray\n  length: number\n  // private constructor\n  static #constructing: boolean = false\n  static create(max: number): StackLike {\n    const HeapCls = getUintArray(max)\n    if (!HeapCls) return []\n    Stack.#constructing = true\n    const s = new Stack(max, HeapCls)\n    Stack.#constructing = false\n    return s\n  }\n  constructor(\n    max: number,\n    HeapCls: { new (n: number): NumberArray }\n  ) {\n    /* c8 ignore start */\n    if (!Stack.#constructing) {\n      throw new TypeError('instantiate Stack using Stack.create(n)')\n    }\n    /* c8 ignore stop */\n    this.heap = new HeapCls(max)\n    this.length = 0\n  }\n  push(n: Index) {\n    this.heap[this.length++] = n\n  }\n  pop(): Index {\n    return this.heap[--this.length] as Index\n  }\n}\n\n/**\n * Promise representing an in-progress {@link LRUCache#fetch} call\n */\nexport type BackgroundFetch<V> = Promise<V | undefined> & {\n  __returned: BackgroundFetch<V> | undefined\n  __abortController: AbortController\n  __staleWhileFetching: V | undefined\n}\n\nexport type DisposeTask<K, V> = [\n  value: V,\n  key: K,\n  reason: LRUCache.DisposeReason\n]\n\nexport namespace LRUCache {\n  /**\n   * An integer greater than 0, reflecting the calculated size of items\n   */\n  export type Size = number\n\n  /**\n   * Integer greater than 0, representing some number of milliseconds, or the\n   * time at which a TTL started counting from.\n   */\n  export type Milliseconds = number\n\n  /**\n   * An integer greater than 0, reflecting a number of items\n   */\n  export type Count = number\n\n  /**\n   * The reason why an item was removed from the cache, passed\n   * to the {@link Disposer} methods.\n   */\n  export type DisposeReason = 'evict' | 'set' | 'delete'\n  /**\n   * A method called upon item removal, passed as the\n   * {@link OptionsBase.dispose} and/or\n   * {@link OptionsBase.disposeAfter} options.\n   */\n  export type Disposer<K, V> = (\n    value: V,\n    key: K,\n    reason: DisposeReason\n  ) => void\n\n  /**\n   * A function that returns the effective calculated size\n   * of an entry in the cache.\n   */\n  export type SizeCalculator<K, V> = (value: V, key: K) => Size\n\n  /**\n   * Options provided to the\n   * {@link OptionsBase.fetchMethod} function.\n   */\n  export interface FetcherOptions<K, V, FC = unknown> {\n    signal: AbortSignal\n    options: FetcherFetchOptions<K, V, FC>\n    /**\n     * Object provided in the {@link FetchOptions.context} option to\n     * {@link LRUCache#fetch}\n     */\n    context: FC\n  }\n\n  /**\n   * Status object that may be passed to {@link LRUCache#fetch},\n   * {@link LRUCache#get}, {@link LRUCache#set}, and {@link LRUCache#has}.\n   */\n  export interface Status<V> {\n    /**\n     * The status of a set() operation.\n     *\n     * - add: the item was not found in the cache, and was added\n     * - update: the item was in the cache, with the same value provided\n     * - replace: the item was in the cache, and replaced\n     * - miss: the item was not added to the cache for some reason\n     */\n    set?: 'add' | 'update' | 'replace' | 'miss'\n\n    /**\n     * the ttl stored for the item, or undefined if ttls are not used.\n     */\n    ttl?: Milliseconds\n\n    /**\n     * the start time for the item, or undefined if ttls are not used.\n     */\n    start?: Milliseconds\n\n    /**\n     * The timestamp used for TTL calculation\n     */\n    now?: Milliseconds\n\n    /**\n     * the remaining ttl for the item, or undefined if ttls are not used.\n     */\n    remainingTTL?: Milliseconds\n\n    /**\n     * The calculated size for the item, if sizes are used.\n     */\n    entrySize?: Size\n\n    /**\n     * The total calculated size of the cache, if sizes are used.\n     */\n    totalCalculatedSize?: Size\n\n    /**\n     * A flag indicating that the item was not stored, due to exceeding the\n     * {@link OptionsBase.maxEntrySize}\n     */\n    maxEntrySizeExceeded?: true\n\n    /**\n     * The old value, specified in the case of `set:'update'` or\n     * `set:'replace'`\n     */\n    oldValue?: V\n\n    /**\n     * The results of a {@link LRUCache#has} operation\n     *\n     * - hit: the item was found in the cache\n     * - stale: the item was found in the cache, but is stale\n     * - miss: the item was not found in the cache\n     */\n    has?: 'hit' | 'stale' | 'miss'\n\n    /**\n     * The status of a {@link LRUCache#fetch} operation.\n     * Note that this can change as the underlying fetch() moves through\n     * various states.\n     *\n     * - inflight: there is another fetch() for this key which is in process\n     * - get: there is no fetchMethod, so {@link LRUCache#get} was called.\n     * - miss: the item is not in cache, and will be fetched.\n     * - hit: the item is in the cache, and was resolved immediately.\n     * - stale: the item is in the cache, but stale.\n     * - refresh: the item is in the cache, and not stale, but\n     *   {@link FetchOptions.forceRefresh} was specified.\n     */\n    fetch?: 'get' | 'inflight' | 'miss' | 'hit' | 'stale' | 'refresh'\n\n    /**\n     * The {@link OptionsBase.fetchMethod} was called\n     */\n    fetchDispatched?: true\n\n    /**\n     * The cached value was updated after a successful call to\n     * {@link OptionsBase.fetchMethod}\n     */\n    fetchUpdated?: true\n\n    /**\n     * The reason for a fetch() rejection.  Either the error raised by the\n     * {@link OptionsBase.fetchMethod}, or the reason for an\n     * AbortSignal.\n     */\n    fetchError?: Error\n\n    /**\n     * The fetch received an abort signal\n     */\n    fetchAborted?: true\n\n    /**\n     * The abort signal received was ignored, and the fetch was allowed to\n     * continue.\n     */\n    fetchAbortIgnored?: true\n\n    /**\n     * The fetchMethod promise resolved successfully\n     */\n    fetchResolved?: true\n\n    /**\n     * The fetchMethod promise was rejected\n     */\n    fetchRejected?: true\n\n    /**\n     * The status of a {@link LRUCache#get} operation.\n     *\n     * - fetching: The item is currently being fetched.  If a previous value\n     *   is present and allowed, that will be returned.\n     * - stale: The item is in the cache, and is stale.\n     * - hit: the item is in the cache\n     * - miss: the item is not in the cache\n     */\n    get?: 'stale' | 'hit' | 'miss'\n\n    /**\n     * A fetch or get operation returned a stale value.\n     */\n    returnedStale?: true\n  }\n\n  /**\n   * options which override the options set in the LRUCache constructor\n   * when calling {@link LRUCache#fetch}.\n   *\n   * This is the union of {@link GetOptions} and {@link SetOptions}, plus\n   * {@link OptionsBase.noDeleteOnFetchRejection},\n   * {@link OptionsBase.allowStaleOnFetchRejection},\n   * {@link FetchOptions.forceRefresh}, and\n   * {@link FetcherOptions.context}\n   *\n   * Any of these may be modified in the {@link OptionsBase.fetchMethod}\n   * function, but the {@link GetOptions} fields will of course have no\n   * effect, as the {@link LRUCache#get} call already happened by the time\n   * the fetchMethod is called.\n   */\n  export interface FetcherFetchOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n      | 'noDeleteOnFetchRejection'\n      | 'allowStaleOnFetchRejection'\n      | 'ignoreFetchAbort'\n      | 'allowStaleOnFetchAbort'\n    > {\n    status?: Status<V>\n    size?: Size\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#fetch} method.\n   */\n  export interface FetchOptions<K, V, FC>\n    extends FetcherFetchOptions<K, V, FC> {\n    /**\n     * Set to true to force a re-load of the existing data, even if it\n     * is not yet stale.\n     */\n    forceRefresh?: boolean\n    /**\n     * Context provided to the {@link OptionsBase.fetchMethod} as\n     * the {@link FetcherOptions.context} param.\n     *\n     * If the FC type is specified as unknown (the default),\n     * undefined or void, then this is optional.  Otherwise, it will\n     * be required.\n     */\n    context?: FC\n    signal?: AbortSignal\n    status?: Status<V>\n  }\n  /**\n   * Options provided to {@link LRUCache#fetch} when the FC type is something\n   * other than `unknown`, `undefined`, or `void`\n   */\n  export interface FetchOptionsWithContext<K, V, FC>\n    extends FetchOptions<K, V, FC> {\n    context: FC\n  }\n  /**\n   * Options provided to {@link LRUCache#fetch} when the FC type is\n   * `undefined` or `void`\n   */\n  export interface FetchOptionsNoContext<K, V>\n    extends FetchOptions<K, V, undefined> {\n    context?: undefined\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#has} method.\n   */\n  export interface HasOptions<K, V, FC>\n    extends Pick<OptionsBase<K, V, FC>, 'updateAgeOnHas'> {\n    status?: Status<V>\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#get} method.\n   */\n  export interface GetOptions<K, V, FC>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet'\n    > {\n    status?: Status<V>\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#peek} method.\n   */\n  export interface PeekOptions<K, V, FC>\n    extends Pick<OptionsBase<K, V, FC>, 'allowStale'> {}\n\n  /**\n   * Options that may be passed to the {@link LRUCache#set} method.\n   */\n  export interface SetOptions<K, V, FC>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL'\n    > {\n    /**\n     * If size tracking is enabled, then setting an explicit size\n     * in the {@link LRUCache#set} call will prevent calling the\n     * {@link OptionsBase.sizeCalculation} function.\n     */\n    size?: Size\n    /**\n     * If TTL tracking is enabled, then setting an explicit start\n     * time in the {@link LRUCache#set} call will override the\n     * default time from `performance.now()` or `Date.now()`.\n     *\n     * Note that it must be a valid value for whichever time-tracking\n     * method is in use.\n     */\n    start?: Milliseconds\n    status?: Status<V>\n  }\n\n  /**\n   * The type signature for the {@link OptionsBase.fetchMethod} option.\n   */\n  export type Fetcher<K, V, FC = unknown> = (\n    key: K,\n    staleValue: V | undefined,\n    options: FetcherOptions<K, V, FC>\n  ) => Promise<V | undefined | void> | V | undefined | void\n\n  /**\n   * Options which may be passed to the {@link LRUCache} constructor.\n   *\n   * Most of these may be overridden in the various options that use\n   * them.\n   *\n   * Despite all being technically optional, the constructor requires that\n   * a cache is at minimum limited by one or more of {@link OptionsBase.max},\n   * {@link OptionsBase.ttl}, or {@link OptionsBase.maxSize}.\n   *\n   * If {@link OptionsBase.ttl} is used alone, then it is strongly advised\n   * (and in fact required by the type definitions here) that the cache\n   * also set {@link OptionsBase.ttlAutopurge}, to prevent potentially\n   * unbounded storage.\n   */\n  export interface OptionsBase<K, V, FC> {\n    /**\n     * The maximum number of items to store in the cache before evicting\n     * old entries. This is read-only on the {@link LRUCache} instance,\n     * and may not be overridden.\n     *\n     * If set, then storage space will be pre-allocated at construction\n     * time, and the cache will perform significantly faster.\n     *\n     * Note that significantly fewer items may be stored, if\n     * {@link OptionsBase.maxSize} and/or {@link OptionsBase.ttl} are also\n     * set.\n     */\n    max?: Count\n\n    /**\n     * Max time in milliseconds for items to live in cache before they are\n     * considered stale.  Note that stale items are NOT preemptively removed\n     * by default, and MAY live in the cache long after they have expired.\n     *\n     * Also, as this cache is optimized for LRU/MRU operations, some of\n     * the staleness/TTL checks will reduce performance, as they will incur\n     * overhead by deleting items.\n     *\n     * Must be an integer number of ms. If set to 0, this indicates \"no TTL\"\n     *\n     * @default 0\n     */\n    ttl?: Milliseconds\n\n    /**\n     * Minimum amount of time in ms in which to check for staleness.\n     * Defaults to 1, which means that the current time is checked\n     * at most once per millisecond.\n     *\n     * Set to 0 to check the current time every time staleness is tested.\n     * (This reduces performance, and is theoretically unnecessary.)\n     *\n     * Setting this to a higher value will improve performance somewhat\n     * while using ttl tracking, albeit at the expense of keeping stale\n     * items around a bit longer than their TTLs would indicate.\n     *\n     * @default 1\n     */\n    ttlResolution?: Milliseconds\n\n    /**\n     * Preemptively remove stale items from the cache.\n     * Note that this may significantly degrade performance,\n     * especially if the cache is storing a large number of items.\n     * It is almost always best to just leave the stale items in\n     * the cache, and let them fall out as new items are added.\n     *\n     * Note that this means that {@link OptionsBase.allowStale} is a bit\n     * pointless, as stale items will be deleted almost as soon as they\n     * expire.\n     *\n     * @default false\n     */\n    ttlAutopurge?: boolean\n\n    /**\n     * Update the age of items on {@link LRUCache#get}, renewing their TTL\n     *\n     * Has no effect if {@link OptionsBase.ttl} is not set.\n     *\n     * @default false\n     */\n    updateAgeOnGet?: boolean\n\n    /**\n     * Update the age of items on {@link LRUCache#has}, renewing their TTL\n     *\n     * Has no effect if {@link OptionsBase.ttl} is not set.\n     *\n     * @default false\n     */\n    updateAgeOnHas?: boolean\n\n    /**\n     * Allow {@link LRUCache#get} and {@link LRUCache#fetch} calls to return\n     * stale data, if available.\n     */\n    allowStale?: boolean\n\n    /**\n     * Function that is called on items when they are dropped from the cache.\n     * This can be handy if you want to close file descriptors or do other\n     * cleanup tasks when items are no longer accessible. Called with `key,\n     * value`.  It's called before actually removing the item from the\n     * internal cache, so it is *NOT* safe to re-add them.\n     *\n     * Use {@link OptionsBase.disposeAfter} if you wish to dispose items after\n     * they have been full removed, when it is safe to add them back to the\n     * cache.\n     */\n    dispose?: Disposer<K, V>\n\n    /**\n     * The same as {@link OptionsBase.dispose}, but called *after* the entry\n     * is completely removed and the cache is once again in a clean state.\n     * It is safe to add an item right back into the cache at this point.\n     * However, note that it is *very* easy to inadvertently create infinite\n     * recursion this way.\n     */\n    disposeAfter?: Disposer<K, V>\n\n    /**\n     * Set to true to suppress calling the\n     * {@link OptionsBase.dispose} function if the entry key is\n     * still accessible within the cache.\n     * This may be overridden by passing an options object to\n     * {@link LRUCache#set}.\n     */\n    noDisposeOnSet?: boolean\n\n    /**\n     * Boolean flag to tell the cache to not update the TTL when\n     * setting a new value for an existing key (ie, when updating a value\n     * rather than inserting a new value).  Note that the TTL value is\n     * _always_ set (if provided) when adding a new entry into the cache.\n     *\n     * Has no effect if a {@link OptionsBase.ttl} is not set.\n     */\n    noUpdateTTL?: boolean\n\n    /**\n     * If you wish to track item size, you must provide a maxSize\n     * note that we still will only keep up to max *actual items*,\n     * if max is set, so size tracking may cause fewer than max items\n     * to be stored.  At the extreme, a single item of maxSize size\n     * will cause everything else in the cache to be dropped when it\n     * is added.  Use with caution!\n     *\n     * Note also that size tracking can negatively impact performance,\n     * though for most cases, only minimally.\n     */\n    maxSize?: Size\n\n    /**\n     * The maximum allowed size for any single item in the cache.\n     *\n     * If a larger item is passed to {@link LRUCache#set} or returned by a\n     * {@link OptionsBase.fetchMethod}, then it will not be stored in the\n     * cache.\n     */\n    maxEntrySize?: Size\n\n    /**\n     * A function that returns a number indicating the item's size.\n     *\n     * If not provided, and {@link OptionsBase.maxSize} or\n     * {@link OptionsBase.maxEntrySize} are set, then all\n     * {@link LRUCache#set} calls **must** provide an explicit\n     * {@link SetOptions.size} or sizeCalculation param.\n     */\n    sizeCalculation?: SizeCalculator<K, V>\n\n    /**\n     * Method that provides the implementation for {@link LRUCache#fetch}\n     */\n    fetchMethod?: Fetcher<K, V, FC>\n\n    /**\n     * Set to true to suppress the deletion of stale data when a\n     * {@link OptionsBase.fetchMethod} returns a rejected promise.\n     */\n    noDeleteOnFetchRejection?: boolean\n\n    /**\n     * Do not delete stale items when they are retrieved with\n     * {@link LRUCache#get}.\n     *\n     * Note that the `get` return value will still be `undefined`\n     * unless {@link OptionsBase.allowStale} is true.\n     */\n    noDeleteOnStaleGet?: boolean\n\n    /**\n     * Set to true to allow returning stale data when a\n     * {@link OptionsBase.fetchMethod} throws an error or returns a rejected\n     * promise.\n     *\n     * This differs from using {@link OptionsBase.allowStale} in that stale\n     * data will ONLY be returned in the case that the\n     * {@link LRUCache#fetch} fails, not any other times.\n     */\n    allowStaleOnFetchRejection?: boolean\n\n    /**\n     * Set to true to return a stale value from the cache when the\n     * `AbortSignal` passed to the {@link OptionsBase.fetchMethod} dispatches an `'abort'`\n     * event, whether user-triggered, or due to internal cache behavior.\n     *\n     * Unless {@link OptionsBase.ignoreFetchAbort} is also set, the underlying\n     * {@link OptionsBase.fetchMethod} will still be considered canceled, and\n     * any value it returns will be ignored and not cached.\n     *\n     * Caveat: since fetches are aborted when a new value is explicitly\n     * set in the cache, this can lead to fetch returning a stale value,\n     * since that was the fallback value _at the moment the `fetch()` was\n     * initiated_, even though the new updated value is now present in\n     * the cache.\n     *\n     * For example:\n     *\n     * ```ts\n     * const cache = new LRUCache<string, any>({\n     *   ttl: 100,\n     *   fetchMethod: async (url, oldValue, { signal }) =>  {\n     *     const res = await fetch(url, { signal })\n     *     return await res.json()\n     *   }\n     * })\n     * cache.set('https://example.com/', { some: 'data' })\n     * // 100ms go by...\n     * const result = cache.fetch('https://example.com/')\n     * cache.set('https://example.com/', { other: 'thing' })\n     * console.log(await result) // { some: 'data' }\n     * console.log(cache.get('https://example.com/')) // { other: 'thing' }\n     * ```\n     */\n    allowStaleOnFetchAbort?: boolean\n\n    /**\n     * Set to true to ignore the `abort` event emitted by the `AbortSignal`\n     * object passed to {@link OptionsBase.fetchMethod}, and still cache the\n     * resulting resolution value, as long as it is not `undefined`.\n     *\n     * When used on its own, this means aborted {@link LRUCache#fetch} calls are not\n     * immediately resolved or rejected when they are aborted, and instead\n     * take the full time to await.\n     *\n     * When used with {@link OptionsBase.allowStaleOnFetchAbort}, aborted\n     * {@link LRUCache#fetch} calls will resolve immediately to their stale\n     * cached value or `undefined`, and will continue to process and eventually\n     * update the cache when they resolve, as long as the resulting value is\n     * not `undefined`, thus supporting a \"return stale on timeout while\n     * refreshing\" mechanism by passing `AbortSignal.timeout(n)` as the signal.\n     *\n     * **Note**: regardless of this setting, an `abort` event _is still\n     * emitted on the `AbortSignal` object_, so may result in invalid results\n     * when passed to other underlying APIs that use AbortSignals.\n     *\n     * This may be overridden in the {@link OptionsBase.fetchMethod} or the\n     * call to {@link LRUCache#fetch}.\n     */\n    ignoreFetchAbort?: boolean\n  }\n\n  export interface OptionsMaxLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    max: Count\n  }\n  export interface OptionsTTLLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    ttl: Milliseconds\n    ttlAutopurge: boolean\n  }\n  export interface OptionsSizeLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    maxSize: Size\n  }\n\n  /**\n   * The valid safe options for the {@link LRUCache} constructor\n   */\n  export type Options<K, V, FC> =\n    | OptionsMaxLimit<K, V, FC>\n    | OptionsSizeLimit<K, V, FC>\n    | OptionsTTLLimit<K, V, FC>\n\n  /**\n   * Entry objects used by {@link LRUCache#load} and {@link LRUCache#dump},\n   * and returned by {@link LRUCache#info}.\n   */\n  export interface Entry<V> {\n    value: V\n    ttl?: Milliseconds\n    size?: Size\n    start?: Milliseconds\n  }\n}\n\n/**\n * Default export, the thing you're using this module to get.\n *\n * All properties from the options object (with the exception of\n * {@link OptionsBase.max} and {@link OptionsBase.maxSize}) are added as\n * normal public members. (`max` and `maxBase` are read-only getters.)\n * Changing any of these will alter the defaults for subsequent method calls,\n * but is otherwise safe.\n */\nexport class LRUCache<K extends {}, V extends {}, FC = unknown> implements Map<K,V> {\n  // properties coming in from the options of these, only max and maxSize\n  // really *need* to be protected. The rest can be modified, as they just\n  // set defaults for various methods.\n  readonly #max: LRUCache.Count\n  readonly #maxSize: LRUCache.Size\n  readonly #dispose?: LRUCache.Disposer<K, V>\n  readonly #disposeAfter?: LRUCache.Disposer<K, V>\n  readonly #fetchMethod?: LRUCache.Fetcher<K, V, FC>\n\n  /**\n   * {@link LRUCache.OptionsBase.ttl}\n   */\n  ttl: LRUCache.Milliseconds\n\n  /**\n   * {@link LRUCache.OptionsBase.ttlResolution}\n   */\n  ttlResolution: LRUCache.Milliseconds\n  /**\n   * {@link LRUCache.OptionsBase.ttlAutopurge}\n   */\n  ttlAutopurge: boolean\n  /**\n   * {@link LRUCache.OptionsBase.updateAgeOnGet}\n   */\n  updateAgeOnGet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.updateAgeOnHas}\n   */\n  updateAgeOnHas: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStale}\n   */\n  allowStale: boolean\n\n  /**\n   * {@link LRUCache.OptionsBase.noDisposeOnSet}\n   */\n  noDisposeOnSet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.noUpdateTTL}\n   */\n  noUpdateTTL: boolean\n  /**\n   * {@link LRUCache.OptionsBase.maxEntrySize}\n   */\n  maxEntrySize: LRUCache.Size\n  /**\n   * {@link LRUCache.OptionsBase.sizeCalculation}\n   */\n  sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  /**\n   * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}\n   */\n  noDeleteOnFetchRejection: boolean\n  /**\n   * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}\n   */\n  noDeleteOnStaleGet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}\n   */\n  allowStaleOnFetchAbort: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}\n   */\n  allowStaleOnFetchRejection: boolean\n  /**\n   * {@link LRUCache.OptionsBase.ignoreFetchAbort}\n   */\n  ignoreFetchAbort: boolean\n\n  // computed properties\n  #size: LRUCache.Count\n  #calculatedSize: LRUCache.Size\n  #keyMap: Map<K, Index>\n  #keyList: (K | undefined)[]\n  #valList: (V | BackgroundFetch<V> | undefined)[]\n  #next: NumberArray\n  #prev: NumberArray\n  #head: Index\n  #tail: Index\n  #free: StackLike\n  #disposed?: DisposeTask<K, V>[]\n  #sizes?: ZeroArray\n  #starts?: ZeroArray\n  #ttls?: ZeroArray\n\n  #hasDispose: boolean\n  #hasFetchMethod: boolean\n  #hasDisposeAfter: boolean\n\n  /**\n   * Do not call this method unless you need to inspect the\n   * inner workings of the cache.  If anything returned by this\n   * object is modified in any way, strange breakage may occur.\n   *\n   * These fields are private for a reason!\n   *\n   * @internal\n   */\n  static unsafeExposeInternals<\n    K extends {},\n    V extends {},\n    FC extends unknown = unknown\n  >(c: LRUCache<K, V, FC>) {\n    return {\n      // properties\n      starts: c.#starts,\n      ttls: c.#ttls,\n      sizes: c.#sizes,\n      keyMap: c.#keyMap as Map<K, number>,\n      keyList: c.#keyList,\n      valList: c.#valList,\n      next: c.#next,\n      prev: c.#prev,\n      get head() {\n        return c.#head\n      },\n      get tail() {\n        return c.#tail\n      },\n      free: c.#free,\n      // methods\n      isBackgroundFetch: (p: any) => c.#isBackgroundFetch(p),\n      backgroundFetch: (\n        k: K,\n        index: number | undefined,\n        options: LRUCache.FetchOptions<K, V, FC>,\n        context: any\n      ): BackgroundFetch<V> =>\n        c.#backgroundFetch(\n          k,\n          index as Index | undefined,\n          options,\n          context\n        ),\n      moveToTail: (index: number): void =>\n        c.#moveToTail(index as Index),\n      indexes: (options?: { allowStale: boolean }) =>\n        c.#indexes(options),\n      rindexes: (options?: { allowStale: boolean }) =>\n        c.#rindexes(options),\n      isStale: (index: number | undefined) =>\n        c.#isStale(index as Index),\n    }\n  }\n\n  // Protected read-only members\n\n  /**\n   * {@link LRUCache.OptionsBase.max} (read-only)\n   */\n  get max(): LRUCache.Count {\n    return this.#max\n  }\n  /**\n   * {@link LRUCache.OptionsBase.maxSize} (read-only)\n   */\n  get maxSize(): LRUCache.Count {\n    return this.#maxSize\n  }\n  /**\n   * The total computed size of items in the cache (read-only)\n   */\n  get calculatedSize(): LRUCache.Size {\n    return this.#calculatedSize\n  }\n  /**\n   * The number of items stored in the cache (read-only)\n   */\n  get size(): LRUCache.Count {\n    return this.#size\n  }\n  /**\n   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)\n   */\n  get fetchMethod(): LRUCache.Fetcher<K, V, FC> | undefined {\n    return this.#fetchMethod\n  }\n  /**\n   * {@link LRUCache.OptionsBase.dispose} (read-only)\n   */\n  get dispose() {\n    return this.#dispose\n  }\n  /**\n   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)\n   */\n  get disposeAfter() {\n    return this.#disposeAfter\n  }\n\n  constructor(\n    options: LRUCache.Options<K, V, FC> | LRUCache<K, V, FC>\n  ) {\n    const {\n      max = 0,\n      ttl,\n      ttlResolution = 1,\n      ttlAutopurge,\n      updateAgeOnGet,\n      updateAgeOnHas,\n      allowStale,\n      dispose,\n      disposeAfter,\n      noDisposeOnSet,\n      noUpdateTTL,\n      maxSize = 0,\n      maxEntrySize = 0,\n      sizeCalculation,\n      fetchMethod,\n      noDeleteOnFetchRejection,\n      noDeleteOnStaleGet,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n    } = options\n\n    if (max !== 0 && !isPosInt(max)) {\n      throw new TypeError('max option must be a nonnegative integer')\n    }\n\n    const UintArray = max ? getUintArray(max) : Array\n    if (!UintArray) {\n      throw new Error('invalid max value: ' + max)\n    }\n\n    this.#max = max\n    this.#maxSize = maxSize\n    this.maxEntrySize = maxEntrySize || this.#maxSize\n    this.sizeCalculation = sizeCalculation\n    if (this.sizeCalculation) {\n      if (!this.#maxSize && !this.maxEntrySize) {\n        throw new TypeError(\n          'cannot set sizeCalculation without setting maxSize or maxEntrySize'\n        )\n      }\n      if (typeof this.sizeCalculation !== 'function') {\n        throw new TypeError('sizeCalculation set to non-function')\n      }\n    }\n\n    if (\n      fetchMethod !== undefined &&\n      typeof fetchMethod !== 'function'\n    ) {\n      throw new TypeError(\n        'fetchMethod must be a function if specified'\n      )\n    }\n    this.#fetchMethod = fetchMethod\n    this.#hasFetchMethod = !!fetchMethod\n\n    this.#keyMap = new Map()\n    this.#keyList = new Array(max).fill(undefined)\n    this.#valList = new Array(max).fill(undefined)\n    this.#next = new UintArray(max)\n    this.#prev = new UintArray(max)\n    this.#head = 0 as Index\n    this.#tail = 0 as Index\n    this.#free = Stack.create(max)\n    this.#size = 0\n    this.#calculatedSize = 0\n\n    if (typeof dispose === 'function') {\n      this.#dispose = dispose\n    }\n    if (typeof disposeAfter === 'function') {\n      this.#disposeAfter = disposeAfter\n      this.#disposed = []\n    } else {\n      this.#disposeAfter = undefined\n      this.#disposed = undefined\n    }\n    this.#hasDispose = !!this.#dispose\n    this.#hasDisposeAfter = !!this.#disposeAfter\n\n    this.noDisposeOnSet = !!noDisposeOnSet\n    this.noUpdateTTL = !!noUpdateTTL\n    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection\n    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection\n    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort\n    this.ignoreFetchAbort = !!ignoreFetchAbort\n\n    // NB: maxEntrySize is set to maxSize if it's set\n    if (this.maxEntrySize !== 0) {\n      if (this.#maxSize !== 0) {\n        if (!isPosInt(this.#maxSize)) {\n          throw new TypeError(\n            'maxSize must be a positive integer if specified'\n          )\n        }\n      }\n      if (!isPosInt(this.maxEntrySize)) {\n        throw new TypeError(\n          'maxEntrySize must be a positive integer if specified'\n        )\n      }\n      this.#initializeSizeTracking()\n    }\n\n    this.allowStale = !!allowStale\n    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet\n    this.updateAgeOnGet = !!updateAgeOnGet\n    this.updateAgeOnHas = !!updateAgeOnHas\n    this.ttlResolution =\n      isPosInt(ttlResolution) || ttlResolution === 0\n        ? ttlResolution\n        : 1\n    this.ttlAutopurge = !!ttlAutopurge\n    this.ttl = ttl || 0\n    if (this.ttl) {\n      if (!isPosInt(this.ttl)) {\n        throw new TypeError(\n          'ttl must be a positive integer if specified'\n        )\n      }\n      this.#initializeTTLTracking()\n    }\n\n    // do not allow completely unbounded caches\n    if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {\n      throw new TypeError(\n        'At least one of max, maxSize, or ttl is required'\n      )\n    }\n    if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {\n      const code = 'LRU_CACHE_UNBOUNDED'\n      if (shouldWarn(code)) {\n        warned.add(code)\n        const msg =\n          'TTL caching without ttlAutopurge, max, or maxSize can ' +\n          'result in unbounded memory consumption.'\n        emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache)\n      }\n    }\n  }\n\n  /**\n   * Return the remaining TTL time for a given entry key\n   */\n  getRemainingTTL(key: K) {\n    return this.#keyMap.has(key) ? Infinity : 0\n  }\n\n  #initializeTTLTracking() {\n    const ttls = new ZeroArray(this.#max)\n    const starts = new ZeroArray(this.#max)\n    this.#ttls = ttls\n    this.#starts = starts\n\n    this.#setItemTTL = (index, ttl, start = perf.now()) => {\n      starts[index] = ttl !== 0 ? start : 0\n      ttls[index] = ttl\n      if (ttl !== 0 && this.ttlAutopurge) {\n        const t = setTimeout(() => {\n          if (this.#isStale(index)) {\n            this.delete(this.#keyList[index] as K)\n          }\n        }, ttl + 1)\n        // unref() not supported on all platforms\n        /* c8 ignore start */\n        if (t.unref) {\n          t.unref()\n        }\n        /* c8 ignore stop */\n      }\n    }\n\n    this.#updateItemAge = index => {\n      starts[index] = ttls[index] !== 0 ? perf.now() : 0\n    }\n\n    this.#statusTTL = (status, index) => {\n      if (ttls[index]) {\n        const ttl = ttls[index]\n        const start = starts[index]\n        /* c8 ignore next */\n        if (!ttl || !start) return\n        status.ttl = ttl\n        status.start = start\n        status.now = cachedNow || getNow()\n        const age = status.now - start\n        status.remainingTTL = ttl - age\n      }\n    }\n\n    // debounce calls to perf.now() to 1s so we're not hitting\n    // that costly call repeatedly.\n    let cachedNow = 0\n    const getNow = () => {\n      const n = perf.now()\n      if (this.ttlResolution > 0) {\n        cachedNow = n\n        const t = setTimeout(\n          () => (cachedNow = 0),\n          this.ttlResolution\n        )\n        // not available on all platforms\n        /* c8 ignore start */\n        if (t.unref) {\n          t.unref()\n        }\n        /* c8 ignore stop */\n      }\n      return n\n    }\n\n    this.getRemainingTTL = key => {\n      const index = this.#keyMap.get(key)\n      if (index === undefined) {\n        return 0\n      }\n      const ttl = ttls[index]\n      const start = starts[index]\n      if (!ttl || !start) {\n        return Infinity\n      }\n      const age = (cachedNow || getNow()) - start\n      return ttl - age\n    }\n\n    this.#isStale = index => {\n      const s = starts[index]\n      const t = ttls[index]\n      return !!t && !!s && (cachedNow || getNow()) - s > t\n    }\n  }\n\n  // conditionally set private methods related to TTL\n  #updateItemAge: (index: Index) => void = () => {}\n  #statusTTL: (status: LRUCache.Status<V>, index: Index) => void =\n    () => {}\n  #setItemTTL: (\n    index: Index,\n    ttl: LRUCache.Milliseconds,\n    start?: LRUCache.Milliseconds\n    // ignore because we never call this if we're not already in TTL mode\n    /* c8 ignore start */\n  ) => void = () => {}\n  /* c8 ignore stop */\n\n  #isStale: (index: Index) => boolean = () => false\n\n  #initializeSizeTracking() {\n    const sizes = new ZeroArray(this.#max)\n    this.#calculatedSize = 0\n    this.#sizes = sizes\n    this.#removeItemSize = index => {\n      this.#calculatedSize -= sizes[index] as number\n      sizes[index] = 0\n    }\n    this.#requireSize = (k, v, size, sizeCalculation) => {\n      // provisionally accept background fetches.\n      // actual value size will be checked when they return.\n      if (this.#isBackgroundFetch(v)) {\n        return 0\n      }\n      if (!isPosInt(size)) {\n        if (sizeCalculation) {\n          if (typeof sizeCalculation !== 'function') {\n            throw new TypeError('sizeCalculation must be a function')\n          }\n          size = sizeCalculation(v, k)\n          if (!isPosInt(size)) {\n            throw new TypeError(\n              'sizeCalculation return invalid (expect positive integer)'\n            )\n          }\n        } else {\n          throw new TypeError(\n            'invalid size value (must be positive integer). ' +\n              'When maxSize or maxEntrySize is used, sizeCalculation ' +\n              'or size must be set.'\n          )\n        }\n      }\n      return size\n    }\n    this.#addItemSize = (\n      index: Index,\n      size: LRUCache.Size,\n      status?: LRUCache.Status<V>\n    ) => {\n      sizes[index] = size\n      if (this.#maxSize) {\n        const maxSize = this.#maxSize - (sizes[index] as number)\n        while (this.#calculatedSize > maxSize) {\n          this.#evict(true)\n        }\n      }\n      this.#calculatedSize += sizes[index] as number\n      if (status) {\n        status.entrySize = size\n        status.totalCalculatedSize = this.#calculatedSize\n      }\n    }\n  }\n\n  #removeItemSize: (index: Index) => void = _i => {}\n  #addItemSize: (\n    index: Index,\n    size: LRUCache.Size,\n    status?: LRUCache.Status<V>\n  ) => void = (_i, _s, _st) => {}\n  #requireSize: (\n    k: K,\n    v: V | BackgroundFetch<V>,\n    size?: LRUCache.Size,\n    sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  ) => LRUCache.Size = (\n    _k: K,\n    _v: V | BackgroundFetch<V>,\n    size?: LRUCache.Size,\n    sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  ) => {\n    if (size || sizeCalculation) {\n      throw new TypeError(\n        'cannot set size without setting maxSize or maxEntrySize on cache'\n      )\n    }\n    return 0\n  };\n\n  *#indexes({ allowStale = this.allowStale } = {}) {\n    if (this.#size) {\n      for (let i = this.#tail; true; ) {\n        if (!this.#isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.#isStale(i)) {\n          yield i\n        }\n        if (i === this.#head) {\n          break\n        } else {\n          i = this.#prev[i] as Index\n        }\n      }\n    }\n  }\n\n  *#rindexes({ allowStale = this.allowStale } = {}) {\n    if (this.#size) {\n      for (let i = this.#head; true; ) {\n        if (!this.#isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.#isStale(i)) {\n          yield i\n        }\n        if (i === this.#tail) {\n          break\n        } else {\n          i = this.#next[i] as Index\n        }\n      }\n    }\n  }\n\n  #isValidIndex(index: Index) {\n    return (\n      index !== undefined &&\n      this.#keyMap.get(this.#keyList[index] as K) === index\n    )\n  }\n\n  /**\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from most recently used to least recently used.\n   */\n  *entries() {\n    for (const i of this.#indexes()) {\n      if (\n        this.#valList[i] !== undefined &&\n        this.#keyList[i] !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield [this.#keyList[i], this.#valList[i]] as [K, V]\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.entries}\n   *\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from least recently used to most recently used.\n   */\n  *rentries() {\n    for (const i of this.#rindexes()) {\n      if (\n        this.#valList[i] !== undefined &&\n        this.#keyList[i] !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield [this.#keyList[i], this.#valList[i]]\n      }\n    }\n  }\n\n  /**\n   * Return a generator yielding the keys in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *keys() {\n    for (const i of this.#indexes()) {\n      const k = this.#keyList[i]\n      if (\n        k !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield k\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.keys}\n   *\n   * Return a generator yielding the keys in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rkeys() {\n    for (const i of this.#rindexes()) {\n      const k = this.#keyList[i]\n      if (\n        k !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield k\n      }\n    }\n  }\n\n  /**\n   * Return a generator yielding the values in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *values() {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      if (\n        v !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield this.#valList[i] as V\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.values}\n   *\n   * Return a generator yielding the values in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rvalues() {\n    for (const i of this.#rindexes()) {\n      const v = this.#valList[i]\n      if (\n        v !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield this.#valList[i]\n      }\n    }\n  }\n\n  /**\n   * Iterating over the cache itself yields the same results as\n   * {@link LRUCache.entries}\n   */\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n\n  /**\n   * A String value that is used in the creation of the default string description of an object.\n   * Called by the built-in method Object.prototype.toString.\n   */\n  [Symbol.toStringTag] = 'LRUCache'\n\n  /**\n   * Find a value for which the supplied fn method returns a truthy value,\n   * similar to Array.find().  fn is called as fn(value, key, cache).\n   */\n  find(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => boolean,\n    getOptions: LRUCache.GetOptions<K, V, FC> = {}\n  ) {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      if (fn(value, this.#keyList[i] as K, this)) {\n        return this.get(this.#keyList[i] as K, getOptions)\n      }\n    }\n  }\n\n  /**\n   * Call the supplied function on each item in the cache, in order from\n   * most recently used to least recently used.  fn is called as\n   * fn(value, key, cache).  Does not update age or recenty of use.\n   * Does not iterate over stale values.\n   */\n  forEach(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any,\n    thisp: any = this\n  ) {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.#keyList[i] as K, this)\n    }\n  }\n\n  /**\n   * The same as {@link LRUCache.forEach} but items are iterated over in\n   * reverse order.  (ie, less recently used items are iterated over first.)\n   */\n  rforEach(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any,\n    thisp: any = this\n  ) {\n    for (const i of this.#rindexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.#keyList[i] as K, this)\n    }\n  }\n\n  /**\n   * Delete any stale entries. Returns true if anything was removed,\n   * false otherwise.\n   */\n  purgeStale() {\n    let deleted = false\n    for (const i of this.#rindexes({ allowStale: true })) {\n      if (this.#isStale(i)) {\n        this.delete(this.#keyList[i] as K)\n        deleted = true\n      }\n    }\n    return deleted\n  }\n\n  /**\n   * Get the extended info about a given entry, to get its value, size, and\n   * TTL info simultaneously. Like {@link LRUCache#dump}, but just for a\n   * single key. Always returns stale values, if their info is found in the\n   * cache, so be sure to check for expired TTLs if relevant.\n   */\n  info(key: K): LRUCache.Entry<V> | undefined {\n    const i = this.#keyMap.get(key)\n    if (i === undefined) return undefined\n    const v = this.#valList[i]\n    const value: V | undefined = this.#isBackgroundFetch(v)\n      ? v.__staleWhileFetching\n      : v\n    if (value === undefined) return undefined\n    const entry: LRUCache.Entry<V> = { value }\n    if (this.#ttls && this.#starts) {\n      const ttl = this.#ttls[i]\n      const start = this.#starts[i]\n      if (ttl && start) {\n        const remain = ttl - (perf.now() - start)\n        entry.ttl = remain\n        entry.start = Date.now()\n      }\n    }\n    if (this.#sizes) {\n      entry.size = this.#sizes[i]\n    }\n    return entry\n  }\n\n  /**\n   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be\n   * passed to cache.load()\n   */\n  dump() {\n    const arr: [K, LRUCache.Entry<V>][] = []\n    for (const i of this.#indexes({ allowStale: true })) {\n      const key = this.#keyList[i]\n      const v = this.#valList[i]\n      const value: V | undefined = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined || key === undefined) continue\n      const entry: LRUCache.Entry<V> = { value }\n      if (this.#ttls && this.#starts) {\n        entry.ttl = this.#ttls[i]\n        // always dump the start relative to a portable timestamp\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = perf.now() - (this.#starts[i] as number)\n        entry.start = Math.floor(Date.now() - age)\n      }\n      if (this.#sizes) {\n        entry.size = this.#sizes[i]\n      }\n      arr.unshift([key, entry])\n    }\n    return arr\n  }\n\n  /**\n   * Reset the cache and load in the items in entries in the order listed.\n   * Note that the shape of the resulting cache may be different if the\n   * same options are not used in both caches.\n   */\n  load(arr: [K, LRUCache.Entry<V>][]) {\n    this.clear()\n    for (const [key, entry] of arr) {\n      if (entry.start) {\n        // entry.start is a portable timestamp, but we may be using\n        // node's performance.now(), so calculate the offset, so that\n        // we get the intended remaining TTL, no matter how long it's\n        // been on ice.\n        //\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = Date.now() - entry.start\n        entry.start = perf.now() - age\n      }\n      this.set(key, entry.value, entry)\n    }\n  }\n\n  /**\n   * Add a value to the cache.\n   *\n   * Note: if `undefined` is specified as a value, this is an alias for\n   * {@link LRUCache#delete}\n   */\n  set(\n    k: K,\n    v: V | BackgroundFetch<V> | undefined,\n    setOptions: LRUCache.SetOptions<K, V, FC> = {}\n  ) {\n    if (v === undefined) {\n      this.delete(k)\n      return this\n    }\n    const {\n      ttl = this.ttl,\n      start,\n      noDisposeOnSet = this.noDisposeOnSet,\n      sizeCalculation = this.sizeCalculation,\n      status,\n    } = setOptions\n    let { noUpdateTTL = this.noUpdateTTL } = setOptions\n\n    const size = this.#requireSize(\n      k,\n      v,\n      setOptions.size || 0,\n      sizeCalculation\n    )\n    // if the item doesn't fit, don't do anything\n    // NB: maxEntrySize set to maxSize by default\n    if (this.maxEntrySize && size > this.maxEntrySize) {\n      if (status) {\n        status.set = 'miss'\n        status.maxEntrySizeExceeded = true\n      }\n      // have to delete, in case something is there already.\n      this.delete(k)\n      return this\n    }\n    let index = this.#size === 0 ? undefined : this.#keyMap.get(k)\n    if (index === undefined) {\n      // addition\n      index = (\n        this.#size === 0\n          ? this.#tail\n          : this.#free.length !== 0\n          ? this.#free.pop()\n          : this.#size === this.#max\n          ? this.#evict(false)\n          : this.#size\n      ) as Index\n      this.#keyList[index] = k\n      this.#valList[index] = v\n      this.#keyMap.set(k, index)\n      this.#next[this.#tail] = index\n      this.#prev[index] = this.#tail\n      this.#tail = index\n      this.#size++\n      this.#addItemSize(index, size, status)\n      if (status) status.set = 'add'\n      noUpdateTTL = false\n    } else {\n      // update\n      this.#moveToTail(index)\n      const oldVal = this.#valList[index] as V | BackgroundFetch<V>\n      if (v !== oldVal) {\n        if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {\n          oldVal.__abortController.abort(new Error('replaced'))\n          const { __staleWhileFetching: s } = oldVal\n          if (s !== undefined && !noDisposeOnSet) {\n            if (this.#hasDispose) {\n              this.#dispose?.(s as V, k, 'set')\n            }\n            if (this.#hasDisposeAfter) {\n              this.#disposed?.push([s as V, k, 'set'])\n            }\n          }\n        } else if (!noDisposeOnSet) {\n          if (this.#hasDispose) {\n            this.#dispose?.(oldVal as V, k, 'set')\n          }\n          if (this.#hasDisposeAfter) {\n            this.#disposed?.push([oldVal as V, k, 'set'])\n          }\n        }\n        this.#removeItemSize(index)\n        this.#addItemSize(index, size, status)\n        this.#valList[index] = v\n        if (status) {\n          status.set = 'replace'\n          const oldValue =\n            oldVal && this.#isBackgroundFetch(oldVal)\n              ? oldVal.__staleWhileFetching\n              : oldVal\n          if (oldValue !== undefined) status.oldValue = oldValue\n        }\n      } else if (status) {\n        status.set = 'update'\n      }\n    }\n    if (ttl !== 0 && !this.#ttls) {\n      this.#initializeTTLTracking()\n    }\n    if (this.#ttls) {\n      if (!noUpdateTTL) {\n        this.#setItemTTL(index, ttl, start)\n      }\n      if (status) this.#statusTTL(status, index)\n    }\n    if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n    return this\n  }\n\n  /**\n   * Evict the least recently used item, returning its value or\n   * `undefined` if cache is empty.\n   */\n  pop(): V | undefined {\n    try {\n      while (this.#size) {\n        const val = this.#valList[this.#head]\n        this.#evict(true)\n        if (this.#isBackgroundFetch(val)) {\n          if (val.__staleWhileFetching) {\n            return val.__staleWhileFetching\n          }\n        } else if (val !== undefined) {\n          return val\n        }\n      }\n    } finally {\n      if (this.#hasDisposeAfter && this.#disposed) {\n        const dt = this.#disposed\n        let task: DisposeTask<K, V> | undefined\n        while ((task = dt?.shift())) {\n          this.#disposeAfter?.(...task)\n        }\n      }\n    }\n  }\n\n  #evict(free: boolean) {\n    const head = this.#head\n    const k = this.#keyList[head] as K\n    const v = this.#valList[head] as V\n    if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {\n      v.__abortController.abort(new Error('evicted'))\n    } else if (this.#hasDispose || this.#hasDisposeAfter) {\n      if (this.#hasDispose) {\n        this.#dispose?.(v, k, 'evict')\n      }\n      if (this.#hasDisposeAfter) {\n        this.#disposed?.push([v, k, 'evict'])\n      }\n    }\n    this.#removeItemSize(head)\n    // if we aren't about to use the index, then null these out\n    if (free) {\n      this.#keyList[head] = undefined\n      this.#valList[head] = undefined\n      this.#free.push(head)\n    }\n    if (this.#size === 1) {\n      this.#head = this.#tail = 0 as Index\n      this.#free.length = 0\n    } else {\n      this.#head = this.#next[head] as Index\n    }\n    this.#keyMap.delete(k)\n    this.#size--\n    return head\n  }\n\n  /**\n   * Check if a key is in the cache, without updating the recency of use.\n   * Will return false if the item is stale, even though it is technically\n   * in the cache.\n   *\n   * Will not update item age unless\n   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.\n   */\n  has(k: K, hasOptions: LRUCache.HasOptions<K, V, FC> = {}) {\n    const { updateAgeOnHas = this.updateAgeOnHas, status } =\n      hasOptions\n    const index = this.#keyMap.get(k)\n    if (index !== undefined) {\n      const v = this.#valList[index]\n      if (\n        this.#isBackgroundFetch(v) &&\n        v.__staleWhileFetching === undefined\n      ) {\n        return false\n      }\n      if (!this.#isStale(index)) {\n        if (updateAgeOnHas) {\n          this.#updateItemAge(index)\n        }\n        if (status) {\n          status.has = 'hit'\n          this.#statusTTL(status, index)\n        }\n        return true\n      } else if (status) {\n        status.has = 'stale'\n        this.#statusTTL(status, index)\n      }\n    } else if (status) {\n      status.has = 'miss'\n    }\n    return false\n  }\n\n  /**\n   * Like {@link LRUCache#get} but doesn't update recency or delete stale\n   * items.\n   *\n   * Returns `undefined` if the item is stale, unless\n   * {@link LRUCache.OptionsBase.allowStale} is set.\n   */\n  peek(k: K, peekOptions: LRUCache.PeekOptions<K, V, FC> = {}) {\n    const { allowStale = this.allowStale } = peekOptions\n    const index = this.#keyMap.get(k)\n    if (\n      index === undefined ||\n      (!allowStale && this.#isStale(index))\n    ) {\n      return\n    }\n    const v = this.#valList[index]\n    // either stale and allowed, or forcing a refresh of non-stale value\n    return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v\n  }\n\n  #backgroundFetch(\n    k: K,\n    index: Index | undefined,\n    options: LRUCache.FetchOptions<K, V, FC>,\n    context: any\n  ): BackgroundFetch<V> {\n    const v = index === undefined ? undefined : this.#valList[index]\n    if (this.#isBackgroundFetch(v)) {\n      return v\n    }\n\n    const ac = new AC()\n    const { signal } = options\n    // when/if our AC signals, then stop listening to theirs.\n    signal?.addEventListener('abort', () => ac.abort(signal.reason), {\n      signal: ac.signal,\n    })\n\n    const fetchOpts = {\n      signal: ac.signal,\n      options,\n      context,\n    }\n\n    const cb = (\n      v: V | undefined,\n      updateCache = false\n    ): V | undefined => {\n      const { aborted } = ac.signal\n      const ignoreAbort = options.ignoreFetchAbort && v !== undefined\n      if (options.status) {\n        if (aborted && !updateCache) {\n          options.status.fetchAborted = true\n          options.status.fetchError = ac.signal.reason\n          if (ignoreAbort) options.status.fetchAbortIgnored = true\n        } else {\n          options.status.fetchResolved = true\n        }\n      }\n      if (aborted && !ignoreAbort && !updateCache) {\n        return fetchFail(ac.signal.reason)\n      }\n      // either we didn't abort, and are still here, or we did, and ignored\n      const bf = p as BackgroundFetch<V>\n      if (this.#valList[index as Index] === p) {\n        if (v === undefined) {\n          if (bf.__staleWhileFetching) {\n            this.#valList[index as Index] = bf.__staleWhileFetching\n          } else {\n            this.delete(k)\n          }\n        } else {\n          if (options.status) options.status.fetchUpdated = true\n          this.set(k, v, fetchOpts.options)\n        }\n      }\n      return v\n    }\n\n    const eb = (er: any) => {\n      if (options.status) {\n        options.status.fetchRejected = true\n        options.status.fetchError = er\n      }\n      return fetchFail(er)\n    }\n\n    const fetchFail = (er: any): V | undefined => {\n      const { aborted } = ac.signal\n      const allowStaleAborted =\n        aborted && options.allowStaleOnFetchAbort\n      const allowStale =\n        allowStaleAborted || options.allowStaleOnFetchRejection\n      const noDelete = allowStale || options.noDeleteOnFetchRejection\n      const bf = p as BackgroundFetch<V>\n      if (this.#valList[index as Index] === p) {\n        // if we allow stale on fetch rejections, then we need to ensure that\n        // the stale value is not removed from the cache when the fetch fails.\n        const del = !noDelete || bf.__staleWhileFetching === undefined\n        if (del) {\n          this.delete(k)\n        } else if (!allowStaleAborted) {\n          // still replace the *promise* with the stale value,\n          // since we are done with the promise at this point.\n          // leave it untouched if we're still waiting for an\n          // aborted background fetch that hasn't yet returned.\n          this.#valList[index as Index] = bf.__staleWhileFetching\n        }\n      }\n      if (allowStale) {\n        if (options.status && bf.__staleWhileFetching !== undefined) {\n          options.status.returnedStale = true\n        }\n        return bf.__staleWhileFetching\n      } else if (bf.__returned === bf) {\n        throw er\n      }\n    }\n\n    const pcall = (\n      res: (v: V | undefined) => void,\n      rej: (e: any) => void\n    ) => {\n      const fmp = this.#fetchMethod?.(k, v, fetchOpts)\n      if (fmp && fmp instanceof Promise) {\n        fmp.then(v => res(v === undefined ? undefined : v), rej)\n      }\n      // ignored, we go until we finish, regardless.\n      // defer check until we are actually aborting,\n      // so fetchMethod can override.\n      ac.signal.addEventListener('abort', () => {\n        if (\n          !options.ignoreFetchAbort ||\n          options.allowStaleOnFetchAbort\n        ) {\n          res(undefined)\n          // when it eventually resolves, update the cache.\n          if (options.allowStaleOnFetchAbort) {\n            res = v => cb(v, true)\n          }\n        }\n      })\n    }\n\n    if (options.status) options.status.fetchDispatched = true\n    const p = new Promise(pcall).then(cb, eb)\n    const bf: BackgroundFetch<V> = Object.assign(p, {\n      __abortController: ac,\n      __staleWhileFetching: v,\n      __returned: undefined,\n    })\n\n    if (index === undefined) {\n      // internal, don't expose status.\n      this.set(k, bf, { ...fetchOpts.options, status: undefined })\n      index = this.#keyMap.get(k)\n    } else {\n      this.#valList[index] = bf\n    }\n    return bf\n  }\n\n  #isBackgroundFetch(p: any): p is BackgroundFetch<V> {\n    if (!this.#hasFetchMethod) return false\n    const b = p as BackgroundFetch<V>\n    return (\n      !!b &&\n      b instanceof Promise &&\n      b.hasOwnProperty('__staleWhileFetching') &&\n      b.__abortController instanceof AC\n    )\n  }\n\n  /**\n   * Make an asynchronous cached fetch using the\n   * {@link LRUCache.OptionsBase.fetchMethod} function.\n   *\n   * If multiple fetches for the same key are issued, then they will all be\n   * coalesced into a single call to fetchMethod.\n   *\n   * Note that this means that handling options such as\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort},\n   * {@link LRUCache.FetchOptions.signal},\n   * and {@link LRUCache.OptionsBase.allowStaleOnFetchRejection} will be\n   * determined by the FIRST fetch() call for a given key.\n   *\n   * This is a known (fixable) shortcoming which will be addresed on when\n   * someone complains about it, as the fix would involve added complexity and\n   * may not be worth the costs for this edge case.\n   */\n  fetch(\n    k: K,\n    fetchOptions: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : LRUCache.FetchOptionsWithContext<K, V, FC>\n  ): Promise<undefined | V>\n  // this overload not allowed if context is required\n  fetch(\n    k: unknown extends FC\n      ? K\n      : FC extends undefined | void\n      ? K\n      : never,\n    fetchOptions?: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : never\n  ): Promise<undefined | V>\n  async fetch(\n    k: K,\n    fetchOptions: LRUCache.FetchOptions<K, V, FC> = {}\n  ): Promise<undefined | V> {\n    const {\n      // get options\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      // set options\n      ttl = this.ttl,\n      noDisposeOnSet = this.noDisposeOnSet,\n      size = 0,\n      sizeCalculation = this.sizeCalculation,\n      noUpdateTTL = this.noUpdateTTL,\n      // fetch exclusive options\n      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,\n      ignoreFetchAbort = this.ignoreFetchAbort,\n      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,\n      context,\n      forceRefresh = false,\n      status,\n      signal,\n    } = fetchOptions\n\n    if (!this.#hasFetchMethod) {\n      if (status) status.fetch = 'get'\n      return this.get(k, {\n        allowStale,\n        updateAgeOnGet,\n        noDeleteOnStaleGet,\n        status,\n      })\n    }\n\n    const options = {\n      allowStale,\n      updateAgeOnGet,\n      noDeleteOnStaleGet,\n      ttl,\n      noDisposeOnSet,\n      size,\n      sizeCalculation,\n      noUpdateTTL,\n      noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n      status,\n      signal,\n    }\n\n    let index = this.#keyMap.get(k)\n    if (index === undefined) {\n      if (status) status.fetch = 'miss'\n      const p = this.#backgroundFetch(k, index, options, context)\n      return (p.__returned = p)\n    } else {\n      // in cache, maybe already fetching\n      const v = this.#valList[index]\n      if (this.#isBackgroundFetch(v)) {\n        const stale =\n          allowStale && v.__staleWhileFetching !== undefined\n        if (status) {\n          status.fetch = 'inflight'\n          if (stale) status.returnedStale = true\n        }\n        return stale ? v.__staleWhileFetching : (v.__returned = v)\n      }\n\n      // if we force a refresh, that means do NOT serve the cached value,\n      // unless we are already in the process of refreshing the cache.\n      const isStale = this.#isStale(index)\n      if (!forceRefresh && !isStale) {\n        if (status) status.fetch = 'hit'\n        this.#moveToTail(index)\n        if (updateAgeOnGet) {\n          this.#updateItemAge(index)\n        }\n        if (status) this.#statusTTL(status, index)\n        return v\n      }\n\n      // ok, it is stale or a forced refresh, and not already fetching.\n      // refresh the cache.\n      const p = this.#backgroundFetch(k, index, options, context)\n      const hasStale = p.__staleWhileFetching !== undefined\n      const staleVal = hasStale && allowStale\n      if (status) {\n        status.fetch = isStale ? 'stale' : 'refresh'\n        if (staleVal && isStale) status.returnedStale = true\n      }\n      return staleVal ? p.__staleWhileFetching : (p.__returned = p)\n    }\n  }\n\n  /**\n   * Return a value from the cache. Will update the recency of the cache\n   * entry found.\n   *\n   * If the key is not found, get() will return `undefined`.\n   */\n  get(k: K, getOptions: LRUCache.GetOptions<K, V, FC> = {}) {\n    const {\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      status,\n    } = getOptions\n    const index = this.#keyMap.get(k)\n    if (index !== undefined) {\n      const value = this.#valList[index]\n      const fetching = this.#isBackgroundFetch(value)\n      if (status) this.#statusTTL(status, index)\n      if (this.#isStale(index)) {\n        if (status) status.get = 'stale'\n        // delete only if not an in-flight background fetch\n        if (!fetching) {\n          if (!noDeleteOnStaleGet) {\n            this.delete(k)\n          }\n          if (status && allowStale) status.returnedStale = true\n          return allowStale ? value : undefined\n        } else {\n          if (\n            status &&\n            allowStale &&\n            value.__staleWhileFetching !== undefined\n          ) {\n            status.returnedStale = true\n          }\n          return allowStale ? value.__staleWhileFetching : undefined\n        }\n      } else {\n        if (status) status.get = 'hit'\n        // if we're currently fetching it, we don't actually have it yet\n        // it's not stale, which means this isn't a staleWhileRefetching.\n        // If it's not stale, and fetching, AND has a __staleWhileFetching\n        // value, then that means the user fetched with {forceRefresh:true},\n        // so it's safe to return that value.\n        if (fetching) {\n          return value.__staleWhileFetching\n        }\n        this.#moveToTail(index)\n        if (updateAgeOnGet) {\n          this.#updateItemAge(index)\n        }\n        return value\n      }\n    } else if (status) {\n      status.get = 'miss'\n    }\n  }\n\n  #connect(p: Index, n: Index) {\n    this.#prev[n] = p\n    this.#next[p] = n\n  }\n\n  #moveToTail(index: Index): void {\n    // if tail already, nothing to do\n    // if head, move head to next[index]\n    // else\n    //   move next[prev[index]] to next[index] (head has no prev)\n    //   move prev[next[index]] to prev[index]\n    // prev[index] = tail\n    // next[tail] = index\n    // tail = index\n    if (index !== this.#tail) {\n      if (index === this.#head) {\n        this.#head = this.#next[index] as Index\n      } else {\n        this.#connect(\n          this.#prev[index] as Index,\n          this.#next[index] as Index\n        )\n      }\n      this.#connect(this.#tail, index)\n      this.#tail = index\n    }\n  }\n\n  /**\n   * Deletes a key out of the cache.\n   * Returns true if the key was deleted, false otherwise.\n   */\n  delete(k: K) {\n    let deleted = false\n    if (this.#size !== 0) {\n      const index = this.#keyMap.get(k)\n      if (index !== undefined) {\n        deleted = true\n        if (this.#size === 1) {\n          this.clear()\n        } else {\n          this.#removeItemSize(index)\n          const v = this.#valList[index]\n          if (this.#isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error('deleted'))\n          } else if (this.#hasDispose || this.#hasDisposeAfter) {\n            if (this.#hasDispose) {\n              this.#dispose?.(v as V, k, 'delete')\n            }\n            if (this.#hasDisposeAfter) {\n              this.#disposed?.push([v as V, k, 'delete'])\n            }\n          }\n          this.#keyMap.delete(k)\n          this.#keyList[index] = undefined\n          this.#valList[index] = undefined\n          if (index === this.#tail) {\n            this.#tail = this.#prev[index] as Index\n          } else if (index === this.#head) {\n            this.#head = this.#next[index] as Index\n          } else {\n            const pi = this.#prev[index] as number\n            this.#next[pi] = this.#next[index] as number\n            const ni = this.#next[index] as number\n            this.#prev[ni] = this.#prev[index] as number\n          }\n          this.#size--\n          this.#free.push(index)\n        }\n      }\n    }\n    if (this.#hasDisposeAfter && this.#disposed?.length) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n    return deleted\n  }\n\n  /**\n   * Clear the cache entirely, throwing away all values.\n   */\n  clear() {\n    for (const index of this.#rindexes({ allowStale: true })) {\n      const v = this.#valList[index]\n      if (this.#isBackgroundFetch(v)) {\n        v.__abortController.abort(new Error('deleted'))\n      } else {\n        const k = this.#keyList[index]\n        if (this.#hasDispose) {\n          this.#dispose?.(v as V, k as K, 'delete')\n        }\n        if (this.#hasDisposeAfter) {\n          this.#disposed?.push([v as V, k as K, 'delete'])\n        }\n      }\n    }\n\n    this.#keyMap.clear()\n    this.#valList.fill(undefined)\n    this.#keyList.fill(undefined)\n    if (this.#ttls && this.#starts) {\n      this.#ttls.fill(0)\n      this.#starts.fill(0)\n    }\n    if (this.#sizes) {\n      this.#sizes.fill(0)\n    }\n    this.#head = 0 as Index\n    this.#tail = 0 as Index\n    this.#free.length = 0\n    this.#calculatedSize = 0\n    this.#size = 0\n    if (this.#hasDisposeAfter && this.#disposed) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n  }\n}\n", "import { LRUCache } from 'lru-cache'\nimport { posix, win32 } from 'path'\n\nimport { fileURLToPath } from 'url'\n\nimport * as actualFS from 'fs'\nimport {\n  lstatSync,\n  readdir as readdirCB,\n  readdirSync,\n  readlinkSync,\n  realpathSync as rps,\n} from 'fs'\nconst realpathSync = rps.native\n// TODO: test perf of fs/promises realpath vs realpathCB,\n// since the promises one uses realpath.native\nimport { lstat, readdir, readlink, realpath } from 'fs/promises'\n\nimport type { Dirent, Stats } from 'fs'\nimport { Minipass } from 'minipass'\n\n/**\n * An object that will be used to override the default `fs`\n * methods.  Any methods that are not overridden will use Node's\n * built-in implementations.\n *\n * - lstatSync\n * - readdir (callback `withFileTypes` Dirent variant, used for\n *   readdirCB and most walks)\n * - readdirSync\n * - readlinkSync\n * - realpathSync\n * - promises: Object containing the following async methods:\n *   - lstat\n *   - readdir (Dirent variant only)\n *   - readlink\n *   - realpath\n */\nexport interface FSOption {\n  lstatSync?: (path: string) => Stats\n  readdir?: (\n    path: string,\n    options: { withFileTypes: true },\n    cb: (er: NodeJS.ErrnoException | null, entries?: Dirent[]) => any\n  ) => void\n  readdirSync?: (\n    path: string,\n    options: { withFileTypes: true }\n  ) => Dirent[]\n  readlinkSync?: (path: string) => string\n  realpathSync?: (path: string) => string\n  promises?: {\n    lstat?: (path: string) => Promise<Stats>\n    readdir?: (\n      path: string,\n      options: { withFileTypes: true }\n    ) => Promise<Dirent[]>\n    readlink?: (path: string) => Promise<string>\n    realpath?: (path: string) => Promise<string>\n    [k: string]: any\n  }\n  [k: string]: any\n}\n\ninterface FSValue {\n  lstatSync: (path: string) => Stats\n  readdir: (\n    path: string,\n    options: { withFileTypes: true },\n    cb: (er: NodeJS.ErrnoException | null, entries?: Dirent[]) => any\n  ) => void\n  readdirSync: (path: string, options: { withFileTypes: true }) => Dirent[]\n  readlinkSync: (path: string) => string\n  realpathSync: (path: string) => string\n  promises: {\n    lstat: (path: string) => Promise<Stats>\n    readdir: (\n      path: string,\n      options: { withFileTypes: true }\n    ) => Promise<Dirent[]>\n    readlink: (path: string) => Promise<string>\n    realpath: (path: string) => Promise<string>\n    [k: string]: any\n  }\n  [k: string]: any\n}\n\nconst defaultFS: FSValue = {\n  lstatSync,\n  readdir: readdirCB,\n  readdirSync,\n  readlinkSync,\n  realpathSync,\n  promises: {\n    lstat,\n    readdir,\n    readlink,\n    realpath,\n  },\n}\n\n// if they just gave us require('fs') then use our default\nconst fsFromOption = (fsOption?: FSOption): FSValue =>\n  !fsOption || fsOption === defaultFS || fsOption === actualFS\n    ? defaultFS\n    : {\n        ...defaultFS,\n        ...fsOption,\n        promises: {\n          ...defaultFS.promises,\n          ...(fsOption.promises || {}),\n        },\n      }\n\n// turn something like //?/c:/ into c:\\\nconst uncDriveRegexp = /^\\\\\\\\\\?\\\\([a-z]:)\\\\?$/i\nconst uncToDrive = (rootPath: string): string =>\n  rootPath.replace(/\\//g, '\\\\').replace(uncDriveRegexp, '$1\\\\')\n\n// windows paths are separated by either / or \\\nconst eitherSep = /[\\\\\\/]/\n\nconst UNKNOWN = 0 // may not even exist, for all we know\nconst IFIFO = 0b0001\nconst IFCHR = 0b0010\nconst IFDIR = 0b0100\nconst IFBLK = 0b0110\nconst IFREG = 0b1000\nconst IFLNK = 0b1010\nconst IFSOCK = 0b1100\nconst IFMT = 0b1111\n\nexport type Type =\n  | 'Unknown'\n  | 'FIFO'\n  | 'CharacterDevice'\n  | 'Directory'\n  | 'BlockDevice'\n  | 'File'\n  | 'SymbolicLink'\n  | 'Socket'\n\n// mask to unset low 4 bits\nconst IFMT_UNKNOWN = ~IFMT\n\n// set after successfully calling readdir() and getting entries.\nconst READDIR_CALLED = 0b0000_0001_0000\n// set after a successful lstat()\nconst LSTAT_CALLED = 0b0000_0010_0000\n// set if an entry (or one of its parents) is definitely not a dir\nconst ENOTDIR = 0b0000_0100_0000\n// set if an entry (or one of its parents) does not exist\n// (can also be set on lstat errors like EACCES or ENAMETOOLONG)\nconst ENOENT = 0b0000_1000_0000\n// cannot have child entries -- also verify &IFMT is either IFDIR or IFLNK\n// set if we fail to readlink\nconst ENOREADLINK = 0b0001_0000_0000\n// set if we know realpath() will fail\nconst ENOREALPATH = 0b0010_0000_0000\n\nconst ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH\nconst TYPEMASK = 0b0011_1111_1111\n\nconst entToType = (s: Dirent | Stats) =>\n  s.isFile()\n    ? IFREG\n    : s.isDirectory()\n    ? IFDIR\n    : s.isSymbolicLink()\n    ? IFLNK\n    : s.isCharacterDevice()\n    ? IFCHR\n    : s.isBlockDevice()\n    ? IFBLK\n    : s.isSocket()\n    ? IFSOCK\n    : s.isFIFO()\n    ? IFIFO\n    : UNKNOWN\n\n// normalize unicode path names\nconst normalizeCache = new Map<string, string>()\nconst normalize = (s: string) => {\n  const c = normalizeCache.get(s)\n  if (c) return c\n  const n = s.normalize('NFKD')\n  normalizeCache.set(s, n)\n  return n\n}\n\nconst normalizeNocaseCache = new Map<string, string>()\nconst normalizeNocase = (s: string) => {\n  const c = normalizeNocaseCache.get(s)\n  if (c) return c\n  const n = normalize(s.toLowerCase())\n  normalizeNocaseCache.set(s, n)\n  return n\n}\n\n/**\n * Options that may be provided to the Path constructor\n */\nexport interface PathOpts {\n  fullpath?: string\n  relative?: string\n  relativePosix?: string\n  parent?: PathBase\n  /**\n   * See {@link FSOption}\n   */\n  fs?: FSOption\n}\n\n/**\n * An LRUCache for storing resolved path strings or Path objects.\n * @internal\n */\nexport class ResolveCache extends LRUCache<string, string> {\n  constructor() {\n    super({ max: 256 })\n  }\n}\n\n// In order to prevent blowing out the js heap by allocating hundreds of\n// thousands of Path entries when walking extremely large trees, the \"children\"\n// in this tree are represented by storing an array of Path entries in an\n// LRUCache, indexed by the parent.  At any time, Path.children() may return an\n// empty array, indicating that it doesn't know about any of its children, and\n// thus has to rebuild that cache.  This is fine, it just means that we don't\n// benefit as much from having the cached entries, but huge directory walks\n// don't blow out the stack, and smaller ones are still as fast as possible.\n//\n//It does impose some complexity when building up the readdir data, because we\n//need to pass a reference to the children array that we started with.\n\n/**\n * an LRUCache for storing child entries.\n * @internal\n */\nexport class ChildrenCache extends LRUCache<PathBase, Children> {\n  constructor(maxSize: number = 16 * 1024) {\n    super({\n      maxSize,\n      // parent + children\n      sizeCalculation: a => a.length + 1,\n    })\n  }\n}\n\n/**\n * Array of Path objects, plus a marker indicating the first provisional entry\n *\n * @internal\n */\nexport type Children = PathBase[] & { provisional: number }\n\nconst setAsCwd = Symbol('PathScurry setAsCwd')\n\n/**\n * Path objects are sort of like a super-powered\n * {@link https://nodejs.org/docs/latest/api/fs.html#class-fsdirent fs.Dirent}\n *\n * Each one represents a single filesystem entry on disk, which may or may not\n * exist. It includes methods for reading various types of information via\n * lstat, readlink, and readdir, and caches all information to the greatest\n * degree possible.\n *\n * Note that fs operations that would normally throw will instead return an\n * \"empty\" value. This is in order to prevent excessive overhead from error\n * stack traces.\n */\nexport abstract class PathBase implements Dirent {\n  /**\n   * the basename of this path\n   *\n   * **Important**: *always* test the path name against any test string\n   * usingthe {@link isNamed} method, and not by directly comparing this\n   * string. Otherwise, unicode path strings that the system sees as identical\n   * will not be properly treated as the same path, leading to incorrect\n   * behavior and possible security issues.\n   */\n  name: string\n  /**\n   * the Path entry corresponding to the path root.\n   *\n   * @internal\n   */\n  root: PathBase\n  /**\n   * All roots found within the current PathScurry family\n   *\n   * @internal\n   */\n  roots: { [k: string]: PathBase }\n  /**\n   * a reference to the parent path, or undefined in the case of root entries\n   *\n   * @internal\n   */\n  parent?: PathBase\n  /**\n   * boolean indicating whether paths are compared case-insensitively\n   * @internal\n   */\n  nocase: boolean\n\n  /**\n   * the string or regexp used to split paths. On posix, it is `'/'`, and on\n   * windows it is a RegExp matching either `'/'` or `'\\\\'`\n   */\n  abstract splitSep: string | RegExp\n  /**\n   * The path separator string to use when joining paths\n   */\n  abstract sep: string\n\n  // potential default fs override\n  #fs: FSValue\n\n  // Stats fields\n  #dev?: number\n  get dev() {\n    return this.#dev\n  }\n  #mode?: number\n  get mode() {\n    return this.#mode\n  }\n  #nlink?: number\n  get nlink() {\n    return this.#nlink\n  }\n  #uid?: number\n  get uid() {\n    return this.#uid\n  }\n  #gid?: number\n  get gid() {\n    return this.#gid\n  }\n  #rdev?: number\n  get rdev() {\n    return this.#rdev\n  }\n  #blksize?: number\n  get blksize() {\n    return this.#blksize\n  }\n  #ino?: number\n  get ino() {\n    return this.#ino\n  }\n  #size?: number\n  get size() {\n    return this.#size\n  }\n  #blocks?: number\n  get blocks() {\n    return this.#blocks\n  }\n  #atimeMs?: number\n  get atimeMs() {\n    return this.#atimeMs\n  }\n  #mtimeMs?: number\n  get mtimeMs() {\n    return this.#mtimeMs\n  }\n  #ctimeMs?: number\n  get ctimeMs() {\n    return this.#ctimeMs\n  }\n  #birthtimeMs?: number\n  get birthtimeMs() {\n    return this.#birthtimeMs\n  }\n  #atime?: Date\n  get atime() {\n    return this.#atime\n  }\n  #mtime?: Date\n  get mtime() {\n    return this.#mtime\n  }\n  #ctime?: Date\n  get ctime() {\n    return this.#ctime\n  }\n  #birthtime?: Date\n  get birthtime() {\n    return this.#birthtime\n  }\n\n  #matchName: string\n  #depth?: number\n  #fullpath?: string\n  #fullpathPosix?: string\n  #relative?: string\n  #relativePosix?: string\n  #type: number\n  #children: ChildrenCache\n  #linkTarget?: PathBase\n  #realpath?: PathBase\n\n  /**\n   * This property is for compatibility with the Dirent class as of\n   * Node v20, where Dirent['path'] refers to the path of the directory\n   * that was passed to readdir.  So, somewhat counterintuitively, this\n   * property refers to the *parent* path, not the path object itself.\n   * For root entries, it's the path to the entry itself.\n   */\n  get path(): string {\n    return (this.parent || this).fullpath()\n  }\n\n  /**\n   * Do not create new Path objects directly.  They should always be accessed\n   * via the PathScurry class or other methods on the Path class.\n   *\n   * @internal\n   */\n  constructor(\n    name: string,\n    type: number = UNKNOWN,\n    root: PathBase | undefined,\n    roots: { [k: string]: PathBase },\n    nocase: boolean,\n    children: ChildrenCache,\n    opts: PathOpts\n  ) {\n    this.name = name\n    this.#matchName = nocase ? normalizeNocase(name) : normalize(name)\n    this.#type = type & TYPEMASK\n    this.nocase = nocase\n    this.roots = roots\n    this.root = root || this\n    this.#children = children\n    this.#fullpath = opts.fullpath\n    this.#relative = opts.relative\n    this.#relativePosix = opts.relativePosix\n    this.parent = opts.parent\n    if (this.parent) {\n      this.#fs = this.parent.#fs\n    } else {\n      this.#fs = fsFromOption(opts.fs)\n    }\n  }\n\n  /**\n   * Returns the depth of the Path object from its root.\n   *\n   * For example, a path at `/foo/bar` would have a depth of 2.\n   */\n  depth(): number {\n    if (this.#depth !== undefined) return this.#depth\n    if (!this.parent) return (this.#depth = 0)\n    return (this.#depth = this.parent.depth() + 1)\n  }\n\n  /**\n   * @internal\n   */\n  abstract getRootString(path: string): string\n  /**\n   * @internal\n   */\n  abstract getRoot(rootPath: string): PathBase\n  /**\n   * @internal\n   */\n  abstract newChild(name: string, type?: number, opts?: PathOpts): PathBase\n\n  /**\n   * @internal\n   */\n  childrenCache() {\n    return this.#children\n  }\n\n  /**\n   * Get the Path object referenced by the string path, resolved from this Path\n   */\n  resolve(path?: string): PathBase {\n    if (!path) {\n      return this\n    }\n    const rootPath = this.getRootString(path)\n    const dir = path.substring(rootPath.length)\n    const dirParts = dir.split(this.splitSep)\n    const result: PathBase = rootPath\n      ? this.getRoot(rootPath).#resolveParts(dirParts)\n      : this.#resolveParts(dirParts)\n    return result\n  }\n\n  #resolveParts(dirParts: string[]) {\n    let p: PathBase = this\n    for (const part of dirParts) {\n      p = p.child(part)\n    }\n    return p\n  }\n\n  /**\n   * Returns the cached children Path objects, if still available.  If they\n   * have fallen out of the cache, then returns an empty array, and resets the\n   * READDIR_CALLED bit, so that future calls to readdir() will require an fs\n   * lookup.\n   *\n   * @internal\n   */\n  children(): Children {\n    const cached = this.#children.get(this)\n    if (cached) {\n      return cached\n    }\n    const children: Children = Object.assign([], { provisional: 0 })\n    this.#children.set(this, children)\n    this.#type &= ~READDIR_CALLED\n    return children\n  }\n\n  /**\n   * Resolves a path portion and returns or creates the child Path.\n   *\n   * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is\n   * `'..'`.\n   *\n   * This should not be called directly.  If `pathPart` contains any path\n   * separators, it will lead to unsafe undefined behavior.\n   *\n   * Use `Path.resolve()` instead.\n   *\n   * @internal\n   */\n  child(pathPart: string, opts?: PathOpts): PathBase {\n    if (pathPart === '' || pathPart === '.') {\n      return this\n    }\n    if (pathPart === '..') {\n      return this.parent || this\n    }\n\n    // find the child\n    const children = this.children()\n    const name = this.nocase\n      ? normalizeNocase(pathPart)\n      : normalize(pathPart)\n    for (const p of children) {\n      if (p.#matchName === name) {\n        return p\n      }\n    }\n\n    // didn't find it, create provisional child, since it might not\n    // actually exist.  If we know the parent isn't a dir, then\n    // in fact it CAN'T exist.\n    const s = this.parent ? this.sep : ''\n    const fullpath = this.#fullpath\n      ? this.#fullpath + s + pathPart\n      : undefined\n    const pchild = this.newChild(pathPart, UNKNOWN, {\n      ...opts,\n      parent: this,\n      fullpath,\n    })\n\n    if (!this.canReaddir()) {\n      pchild.#type |= ENOENT\n    }\n\n    // don't have to update provisional, because if we have real children,\n    // then provisional is set to children.length, otherwise a lower number\n    children.push(pchild)\n    return pchild\n  }\n\n  /**\n   * The relative path from the cwd. If it does not share an ancestor with\n   * the cwd, then this ends up being equivalent to the fullpath()\n   */\n  relative(): string {\n    if (this.#relative !== undefined) {\n      return this.#relative\n    }\n    const name = this.name\n    const p = this.parent\n    if (!p) {\n      return (this.#relative = this.name)\n    }\n    const pv = p.relative()\n    return pv + (!pv || !p.parent ? '' : this.sep) + name\n  }\n\n  /**\n   * The relative path from the cwd, using / as the path separator.\n   * If it does not share an ancestor with\n   * the cwd, then this ends up being equivalent to the fullpathPosix()\n   * On posix systems, this is identical to relative().\n   */\n  relativePosix(): string {\n    if (this.sep === '/') return this.relative()\n    if (this.#relativePosix !== undefined) return this.#relativePosix\n    const name = this.name\n    const p = this.parent\n    if (!p) {\n      return (this.#relativePosix = this.fullpathPosix())\n    }\n    const pv = p.relativePosix()\n    return pv + (!pv || !p.parent ? '' : '/') + name\n  }\n\n  /**\n   * The fully resolved path string for this Path entry\n   */\n  fullpath(): string {\n    if (this.#fullpath !== undefined) {\n      return this.#fullpath\n    }\n    const name = this.name\n    const p = this.parent\n    if (!p) {\n      return (this.#fullpath = this.name)\n    }\n    const pv = p.fullpath()\n    const fp = pv + (!p.parent ? '' : this.sep) + name\n    return (this.#fullpath = fp)\n  }\n\n  /**\n   * On platforms other than windows, this is identical to fullpath.\n   *\n   * On windows, this is overridden to return the forward-slash form of the\n   * full UNC path.\n   */\n  fullpathPosix(): string {\n    if (this.#fullpathPosix !== undefined) return this.#fullpathPosix\n    if (this.sep === '/') return (this.#fullpathPosix = this.fullpath())\n    if (!this.parent) {\n      const p = this.fullpath().replace(/\\\\/g, '/')\n      if (/^[a-z]:\\//i.test(p)) {\n        return (this.#fullpathPosix = `//?/${p}`)\n      } else {\n        return (this.#fullpathPosix = p)\n      }\n    }\n    const p = this.parent\n    const pfpp = p.fullpathPosix()\n    const fpp = pfpp + (!pfpp || !p.parent ? '' : '/') + this.name\n    return (this.#fullpathPosix = fpp)\n  }\n\n  /**\n   * Is the Path of an unknown type?\n   *\n   * Note that we might know *something* about it if there has been a previous\n   * filesystem operation, for example that it does not exist, or is not a\n   * link, or whether it has child entries.\n   */\n  isUnknown(): boolean {\n    return (this.#type & IFMT) === UNKNOWN\n  }\n\n  isType(type: Type): boolean {\n    return this[`is${type}`]()\n  }\n\n  getType(): Type {\n    return this.isUnknown()\n      ? 'Unknown'\n      : this.isDirectory()\n      ? 'Directory'\n      : this.isFile()\n      ? 'File'\n      : this.isSymbolicLink()\n      ? 'SymbolicLink'\n      : this.isFIFO()\n      ? 'FIFO'\n      : this.isCharacterDevice()\n      ? 'CharacterDevice'\n      : this.isBlockDevice()\n      ? 'BlockDevice'\n      : /* c8 ignore start */ this.isSocket()\n      ? 'Socket'\n      : 'Unknown'\n    /* c8 ignore stop */\n  }\n\n  /**\n   * Is the Path a regular file?\n   */\n  isFile(): boolean {\n    return (this.#type & IFMT) === IFREG\n  }\n\n  /**\n   * Is the Path a directory?\n   */\n  isDirectory(): boolean {\n    return (this.#type & IFMT) === IFDIR\n  }\n\n  /**\n   * Is the path a character device?\n   */\n  isCharacterDevice(): boolean {\n    return (this.#type & IFMT) === IFCHR\n  }\n\n  /**\n   * Is the path a block device?\n   */\n  isBlockDevice(): boolean {\n    return (this.#type & IFMT) === IFBLK\n  }\n\n  /**\n   * Is the path a FIFO pipe?\n   */\n  isFIFO(): boolean {\n    return (this.#type & IFMT) === IFIFO\n  }\n\n  /**\n   * Is the path a socket?\n   */\n  isSocket(): boolean {\n    return (this.#type & IFMT) === IFSOCK\n  }\n\n  /**\n   * Is the path a symbolic link?\n   */\n  isSymbolicLink(): boolean {\n    return (this.#type & IFLNK) === IFLNK\n  }\n\n  /**\n   * Return the entry if it has been subject of a successful lstat, or\n   * undefined otherwise.\n   *\n   * Does not read the filesystem, so an undefined result *could* simply\n   * mean that we haven't called lstat on it.\n   */\n  lstatCached(): PathBase | undefined {\n    return this.#type & LSTAT_CALLED ? this : undefined\n  }\n\n  /**\n   * Return the cached link target if the entry has been the subject of a\n   * successful readlink, or undefined otherwise.\n   *\n   * Does not read the filesystem, so an undefined result *could* just mean we\n   * don't have any cached data. Only use it if you are very sure that a\n   * readlink() has been called at some point.\n   */\n  readlinkCached(): PathBase | undefined {\n    return this.#linkTarget\n  }\n\n  /**\n   * Returns the cached realpath target if the entry has been the subject\n   * of a successful realpath, or undefined otherwise.\n   *\n   * Does not read the filesystem, so an undefined result *could* just mean we\n   * don't have any cached data. Only use it if you are very sure that a\n   * realpath() has been called at some point.\n   */\n  realpathCached(): PathBase | undefined {\n    return this.#realpath\n  }\n\n  /**\n   * Returns the cached child Path entries array if the entry has been the\n   * subject of a successful readdir(), or [] otherwise.\n   *\n   * Does not read the filesystem, so an empty array *could* just mean we\n   * don't have any cached data. Only use it if you are very sure that a\n   * readdir() has been called recently enough to still be valid.\n   */\n  readdirCached(): PathBase[] {\n    const children = this.children()\n    return children.slice(0, children.provisional)\n  }\n\n  /**\n   * Return true if it's worth trying to readlink.  Ie, we don't (yet) have\n   * any indication that readlink will definitely fail.\n   *\n   * Returns false if the path is known to not be a symlink, if a previous\n   * readlink failed, or if the entry does not exist.\n   */\n  canReadlink(): boolean {\n    if (this.#linkTarget) return true\n    if (!this.parent) return false\n    // cases where it cannot possibly succeed\n    const ifmt = this.#type & IFMT\n    return !(\n      (ifmt !== UNKNOWN && ifmt !== IFLNK) ||\n      this.#type & ENOREADLINK ||\n      this.#type & ENOENT\n    )\n  }\n\n  /**\n   * Return true if readdir has previously been successfully called on this\n   * path, indicating that cachedReaddir() is likely valid.\n   */\n  calledReaddir(): boolean {\n    return !!(this.#type & READDIR_CALLED)\n  }\n\n  /**\n   * Returns true if the path is known to not exist. That is, a previous lstat\n   * or readdir failed to verify its existence when that would have been\n   * expected, or a parent entry was marked either enoent or enotdir.\n   */\n  isENOENT(): boolean {\n    return !!(this.#type & ENOENT)\n  }\n\n  /**\n   * Return true if the path is a match for the given path name.  This handles\n   * case sensitivity and unicode normalization.\n   *\n   * Note: even on case-sensitive systems, it is **not** safe to test the\n   * equality of the `.name` property to determine whether a given pathname\n   * matches, due to unicode normalization mismatches.\n   *\n   * Always use this method instead of testing the `path.name` property\n   * directly.\n   */\n  isNamed(n: string): boolean {\n    return !this.nocase\n      ? this.#matchName === normalize(n)\n      : this.#matchName === normalizeNocase(n)\n  }\n\n  /**\n   * Return the Path object corresponding to the target of a symbolic link.\n   *\n   * If the Path is not a symbolic link, or if the readlink call fails for any\n   * reason, `undefined` is returned.\n   *\n   * Result is cached, and thus may be outdated if the filesystem is mutated.\n   */\n  async readlink(): Promise<PathBase | undefined> {\n    const target = this.#linkTarget\n    if (target) {\n      return target\n    }\n    if (!this.canReadlink()) {\n      return undefined\n    }\n    /* c8 ignore start */\n    // already covered by the canReadlink test, here for ts grumples\n    if (!this.parent) {\n      return undefined\n    }\n    /* c8 ignore stop */\n    try {\n      const read = await this.#fs.promises.readlink(this.fullpath())\n      const linkTarget = this.parent.resolve(read)\n      if (linkTarget) {\n        return (this.#linkTarget = linkTarget)\n      }\n    } catch (er) {\n      this.#readlinkFail((er as NodeJS.ErrnoException).code)\n      return undefined\n    }\n  }\n\n  /**\n   * Synchronous {@link PathBase.readlink}\n   */\n  readlinkSync(): PathBase | undefined {\n    const target = this.#linkTarget\n    if (target) {\n      return target\n    }\n    if (!this.canReadlink()) {\n      return undefined\n    }\n    /* c8 ignore start */\n    // already covered by the canReadlink test, here for ts grumples\n    if (!this.parent) {\n      return undefined\n    }\n    /* c8 ignore stop */\n    try {\n      const read = this.#fs.readlinkSync(this.fullpath())\n      const linkTarget = this.parent.resolve(read)\n      if (linkTarget) {\n        return (this.#linkTarget = linkTarget)\n      }\n    } catch (er) {\n      this.#readlinkFail((er as NodeJS.ErrnoException).code)\n      return undefined\n    }\n  }\n\n  #readdirSuccess(children: Children) {\n    // succeeded, mark readdir called bit\n    this.#type |= READDIR_CALLED\n    // mark all remaining provisional children as ENOENT\n    for (let p = children.provisional; p < children.length; p++) {\n      children[p].#markENOENT()\n    }\n  }\n\n  #markENOENT() {\n    // mark as UNKNOWN and ENOENT\n    if (this.#type & ENOENT) return\n    this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN\n    this.#markChildrenENOENT()\n  }\n\n  #markChildrenENOENT() {\n    // all children are provisional and do not exist\n    const children = this.children()\n    children.provisional = 0\n    for (const p of children) {\n      p.#markENOENT()\n    }\n  }\n\n  #markENOREALPATH() {\n    this.#type |= ENOREALPATH\n    this.#markENOTDIR()\n  }\n\n  // save the information when we know the entry is not a dir\n  #markENOTDIR() {\n    // entry is not a directory, so any children can't exist.\n    // this *should* be impossible, since any children created\n    // after it's been marked ENOTDIR should be marked ENOENT,\n    // so it won't even get to this point.\n    /* c8 ignore start */\n    if (this.#type & ENOTDIR) return\n    /* c8 ignore stop */\n    let t = this.#type\n    // this could happen if we stat a dir, then delete it,\n    // then try to read it or one of its children.\n    if ((t & IFMT) === IFDIR) t &= IFMT_UNKNOWN\n    this.#type = t | ENOTDIR\n    this.#markChildrenENOENT()\n  }\n\n  #readdirFail(code: string = '') {\n    // markENOTDIR and markENOENT also set provisional=0\n    if (code === 'ENOTDIR' || code === 'EPERM') {\n      this.#markENOTDIR()\n    } else if (code === 'ENOENT') {\n      this.#markENOENT()\n    } else {\n      this.children().provisional = 0\n    }\n  }\n\n  #lstatFail(code: string = '') {\n    // Windows just raises ENOENT in this case, disable for win CI\n    /* c8 ignore start */\n    if (code === 'ENOTDIR') {\n      // already know it has a parent by this point\n      const p = this.parent as PathBase\n      p.#markENOTDIR()\n    } else if (code === 'ENOENT') {\n      /* c8 ignore stop */\n      this.#markENOENT()\n    }\n  }\n\n  #readlinkFail(code: string = '') {\n    let ter = this.#type\n    ter |= ENOREADLINK\n    if (code === 'ENOENT') ter |= ENOENT\n    // windows gets a weird error when you try to readlink a file\n    if (code === 'EINVAL' || code === 'UNKNOWN') {\n      // exists, but not a symlink, we don't know WHAT it is, so remove\n      // all IFMT bits.\n      ter &= IFMT_UNKNOWN\n    }\n    this.#type = ter\n    // windows just gets ENOENT in this case.  We do cover the case,\n    // just disabled because it's impossible on Windows CI\n    /* c8 ignore start */\n    if (code === 'ENOTDIR' && this.parent) {\n      this.parent.#markENOTDIR()\n    }\n    /* c8 ignore stop */\n  }\n\n  #readdirAddChild(e: Dirent, c: Children) {\n    return (\n      this.#readdirMaybePromoteChild(e, c) ||\n      this.#readdirAddNewChild(e, c)\n    )\n  }\n\n  #readdirAddNewChild(e: Dirent, c: Children): PathBase {\n    // alloc new entry at head, so it's never provisional\n    const type = entToType(e)\n    const child = this.newChild(e.name, type, { parent: this })\n    const ifmt = child.#type & IFMT\n    if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {\n      child.#type |= ENOTDIR\n    }\n    c.unshift(child)\n    c.provisional++\n    return child\n  }\n\n  #readdirMaybePromoteChild(e: Dirent, c: Children): PathBase | undefined {\n    for (let p = c.provisional; p < c.length; p++) {\n      const pchild = c[p]\n      const name = this.nocase\n        ? normalizeNocase(e.name)\n        : normalize(e.name)\n      if (name !== pchild.#matchName) {\n        continue\n      }\n\n      return this.#readdirPromoteChild(e, pchild, p, c)\n    }\n  }\n\n  #readdirPromoteChild(\n    e: Dirent,\n    p: PathBase,\n    index: number,\n    c: Children\n  ): PathBase {\n    const v = p.name\n    // retain any other flags, but set ifmt from dirent\n    p.#type = (p.#type & IFMT_UNKNOWN) | entToType(e)\n    // case sensitivity fixing when we learn the true name.\n    if (v !== e.name) p.name = e.name\n\n    // just advance provisional index (potentially off the list),\n    // otherwise we have to splice/pop it out and re-insert at head\n    if (index !== c.provisional) {\n      if (index === c.length - 1) c.pop()\n      else c.splice(index, 1)\n      c.unshift(p)\n    }\n    c.provisional++\n    return p\n  }\n\n  /**\n   * Call lstat() on this Path, and update all known information that can be\n   * determined.\n   *\n   * Note that unlike `fs.lstat()`, the returned value does not contain some\n   * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that\n   * information is required, you will need to call `fs.lstat` yourself.\n   *\n   * If the Path refers to a nonexistent file, or if the lstat call fails for\n   * any reason, `undefined` is returned.  Otherwise the updated Path object is\n   * returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   */\n  async lstat(): Promise<PathBase | undefined> {\n    if ((this.#type & ENOENT) === 0) {\n      try {\n        this.#applyStat(await this.#fs.promises.lstat(this.fullpath()))\n        return this\n      } catch (er) {\n        this.#lstatFail((er as NodeJS.ErrnoException).code)\n      }\n    }\n  }\n\n  /**\n   * synchronous {@link PathBase.lstat}\n   */\n  lstatSync(): PathBase | undefined {\n    if ((this.#type & ENOENT) === 0) {\n      try {\n        this.#applyStat(this.#fs.lstatSync(this.fullpath()))\n        return this\n      } catch (er) {\n        this.#lstatFail((er as NodeJS.ErrnoException).code)\n      }\n    }\n  }\n\n  #applyStat(st: Stats) {\n    const {\n      atime,\n      atimeMs,\n      birthtime,\n      birthtimeMs,\n      blksize,\n      blocks,\n      ctime,\n      ctimeMs,\n      dev,\n      gid,\n      ino,\n      mode,\n      mtime,\n      mtimeMs,\n      nlink,\n      rdev,\n      size,\n      uid,\n    } = st\n    this.#atime = atime\n    this.#atimeMs = atimeMs\n    this.#birthtime = birthtime\n    this.#birthtimeMs = birthtimeMs\n    this.#blksize = blksize\n    this.#blocks = blocks\n    this.#ctime = ctime\n    this.#ctimeMs = ctimeMs\n    this.#dev = dev\n    this.#gid = gid\n    this.#ino = ino\n    this.#mode = mode\n    this.#mtime = mtime\n    this.#mtimeMs = mtimeMs\n    this.#nlink = nlink\n    this.#rdev = rdev\n    this.#size = size\n    this.#uid = uid\n    const ifmt = entToType(st)\n    // retain any other flags, but set the ifmt\n    this.#type = (this.#type & IFMT_UNKNOWN) | ifmt | LSTAT_CALLED\n    if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {\n      this.#type |= ENOTDIR\n    }\n  }\n\n  #onReaddirCB: ((\n    er: NodeJS.ErrnoException | null,\n    entries: Path[]\n  ) => any)[] = []\n  #readdirCBInFlight: boolean = false\n  #callOnReaddirCB(children: Path[]) {\n    this.#readdirCBInFlight = false\n    const cbs = this.#onReaddirCB.slice()\n    this.#onReaddirCB.length = 0\n    cbs.forEach(cb => cb(null, children))\n  }\n\n  /**\n   * Standard node-style callback interface to get list of directory entries.\n   *\n   * If the Path cannot or does not contain any children, then an empty array\n   * is returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   *\n   * @param cb The callback called with (er, entries).  Note that the `er`\n   * param is somewhat extraneous, as all readdir() errors are handled and\n   * simply result in an empty set of entries being returned.\n   * @param allowZalgo Boolean indicating that immediately known results should\n   * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release\n   * zalgo at your peril, the dark pony lord is devious and unforgiving.\n   */\n  readdirCB(\n    cb: (er: NodeJS.ErrnoException | null, entries: PathBase[]) => any,\n    allowZalgo: boolean = false\n  ): void {\n    if (!this.canReaddir()) {\n      if (allowZalgo) cb(null, [])\n      else queueMicrotask(() => cb(null, []))\n      return\n    }\n\n    const children = this.children()\n    if (this.calledReaddir()) {\n      const c = children.slice(0, children.provisional)\n      if (allowZalgo) cb(null, c)\n      else queueMicrotask(() => cb(null, c))\n      return\n    }\n\n    // don't have to worry about zalgo at this point.\n    this.#onReaddirCB.push(cb)\n    if (this.#readdirCBInFlight) {\n      return\n    }\n    this.#readdirCBInFlight = true\n\n    // else read the directory, fill up children\n    // de-provisionalize any provisional children.\n    const fullpath = this.fullpath()\n    this.#fs.readdir(fullpath, { withFileTypes: true }, (er, entries) => {\n      if (er) {\n        this.#readdirFail((er as NodeJS.ErrnoException).code)\n        children.provisional = 0\n      } else {\n        // if we didn't get an error, we always get entries.\n        //@ts-ignore\n        for (const e of entries) {\n          this.#readdirAddChild(e, children)\n        }\n        this.#readdirSuccess(children)\n      }\n      this.#callOnReaddirCB(children.slice(0, children.provisional))\n      return\n    })\n  }\n\n  #asyncReaddirInFlight?: Promise<void>\n\n  /**\n   * Return an array of known child entries.\n   *\n   * If the Path cannot or does not contain any children, then an empty array\n   * is returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   */\n  async readdir(): Promise<PathBase[]> {\n    if (!this.canReaddir()) {\n      return []\n    }\n\n    const children = this.children()\n    if (this.calledReaddir()) {\n      return children.slice(0, children.provisional)\n    }\n\n    // else read the directory, fill up children\n    // de-provisionalize any provisional children.\n    const fullpath = this.fullpath()\n    if (this.#asyncReaddirInFlight) {\n      await this.#asyncReaddirInFlight\n    } else {\n      /* c8 ignore start */\n      let resolve: () => void = () => {}\n      /* c8 ignore stop */\n      this.#asyncReaddirInFlight = new Promise<void>(\n        res => (resolve = res)\n      )\n      try {\n        for (const e of await this.#fs.promises.readdir(fullpath, {\n          withFileTypes: true,\n        })) {\n          this.#readdirAddChild(e, children)\n        }\n        this.#readdirSuccess(children)\n      } catch (er) {\n        this.#readdirFail((er as NodeJS.ErrnoException).code)\n        children.provisional = 0\n      }\n      this.#asyncReaddirInFlight = undefined\n      resolve()\n    }\n    return children.slice(0, children.provisional)\n  }\n\n  /**\n   * synchronous {@link PathBase.readdir}\n   */\n  readdirSync(): PathBase[] {\n    if (!this.canReaddir()) {\n      return []\n    }\n\n    const children = this.children()\n    if (this.calledReaddir()) {\n      return children.slice(0, children.provisional)\n    }\n\n    // else read the directory, fill up children\n    // de-provisionalize any provisional children.\n    const fullpath = this.fullpath()\n    try {\n      for (const e of this.#fs.readdirSync(fullpath, {\n        withFileTypes: true,\n      })) {\n        this.#readdirAddChild(e, children)\n      }\n      this.#readdirSuccess(children)\n    } catch (er) {\n      this.#readdirFail((er as NodeJS.ErrnoException).code)\n      children.provisional = 0\n    }\n    return children.slice(0, children.provisional)\n  }\n\n  canReaddir() {\n    if (this.#type & ENOCHILD) return false\n    const ifmt = IFMT & this.#type\n    // we always set ENOTDIR when setting IFMT, so should be impossible\n    /* c8 ignore start */\n    if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {\n      return false\n    }\n    /* c8 ignore stop */\n    return true\n  }\n\n  shouldWalk(\n    dirs: Set<PathBase | undefined>,\n    walkFilter?: (e: PathBase) => boolean\n  ): boolean {\n    return (\n      (this.#type & IFDIR) === IFDIR &&\n      !(this.#type & ENOCHILD) &&\n      !dirs.has(this) &&\n      (!walkFilter || walkFilter(this))\n    )\n  }\n\n  /**\n   * Return the Path object corresponding to path as resolved\n   * by realpath(3).\n   *\n   * If the realpath call fails for any reason, `undefined` is returned.\n   *\n   * Result is cached, and thus may be outdated if the filesystem is mutated.\n   * On success, returns a Path object.\n   */\n  async realpath(): Promise<PathBase | undefined> {\n    if (this.#realpath) return this.#realpath\n    if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type) return undefined\n    try {\n      const rp = await this.#fs.promises.realpath(this.fullpath())\n      return (this.#realpath = this.resolve(rp))\n    } catch (_) {\n      this.#markENOREALPATH()\n    }\n  }\n\n  /**\n   * Synchronous {@link realpath}\n   */\n  realpathSync(): PathBase | undefined {\n    if (this.#realpath) return this.#realpath\n    if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type) return undefined\n    try {\n      const rp = this.#fs.realpathSync(this.fullpath())\n      return (this.#realpath = this.resolve(rp))\n    } catch (_) {\n      this.#markENOREALPATH()\n    }\n  }\n\n  /**\n   * Internal method to mark this Path object as the scurry cwd,\n   * called by {@link PathScurry#chdir}\n   *\n   * @internal\n   */\n  [setAsCwd](oldCwd: PathBase): void {\n    if (oldCwd === this) return\n\n    const changed = new Set<PathBase>([])\n    let rp = []\n    let p: PathBase = this\n    while (p && p.parent) {\n      changed.add(p)\n      p.#relative = rp.join(this.sep)\n      p.#relativePosix = rp.join('/')\n      p = p.parent\n      rp.push('..')\n    }\n    // now un-memoize parents of old cwd\n    p = oldCwd\n    while (p && p.parent && !changed.has(p)) {\n      p.#relative = undefined\n      p.#relativePosix = undefined\n      p = p.parent\n    }\n  }\n}\n\n/**\n * Path class used on win32 systems\n *\n * Uses `'\\\\'` as the path separator for returned paths, either `'\\\\'` or `'/'`\n * as the path separator for parsing paths.\n */\nexport class PathWin32 extends PathBase {\n  /**\n   * Separator for generating path strings.\n   */\n  sep: '\\\\' = '\\\\'\n  /**\n   * Separator for parsing path strings.\n   */\n  splitSep: RegExp = eitherSep\n\n  /**\n   * Do not create new Path objects directly.  They should always be accessed\n   * via the PathScurry class or other methods on the Path class.\n   *\n   * @internal\n   */\n  constructor(\n    name: string,\n    type: number = UNKNOWN,\n    root: PathBase | undefined,\n    roots: { [k: string]: PathBase },\n    nocase: boolean,\n    children: ChildrenCache,\n    opts: PathOpts\n  ) {\n    super(name, type, root, roots, nocase, children, opts)\n  }\n\n  /**\n   * @internal\n   */\n  newChild(name: string, type: number = UNKNOWN, opts: PathOpts = {}) {\n    return new PathWin32(\n      name,\n      type,\n      this.root,\n      this.roots,\n      this.nocase,\n      this.childrenCache(),\n      opts\n    )\n  }\n\n  /**\n   * @internal\n   */\n  getRootString(path: string): string {\n    return win32.parse(path).root\n  }\n\n  /**\n   * @internal\n   */\n  getRoot(rootPath: string): PathBase {\n    rootPath = uncToDrive(rootPath.toUpperCase())\n    if (rootPath === this.root.name) {\n      return this.root\n    }\n    // ok, not that one, check if it matches another we know about\n    for (const [compare, root] of Object.entries(this.roots)) {\n      if (this.sameRoot(rootPath, compare)) {\n        return (this.roots[rootPath] = root)\n      }\n    }\n    // otherwise, have to create a new one.\n    return (this.roots[rootPath] = new PathScurryWin32(\n      rootPath,\n      this\n    ).root)\n  }\n\n  /**\n   * @internal\n   */\n  sameRoot(rootPath: string, compare: string = this.root.name): boolean {\n    // windows can (rarely) have case-sensitive filesystem, but\n    // UNC and drive letters are always case-insensitive, and canonically\n    // represented uppercase.\n    rootPath = rootPath\n      .toUpperCase()\n      .replace(/\\//g, '\\\\')\n      .replace(uncDriveRegexp, '$1\\\\')\n    return rootPath === compare\n  }\n}\n\n/**\n * Path class used on all posix systems.\n *\n * Uses `'/'` as the path separator.\n */\nexport class PathPosix extends PathBase {\n  /**\n   * separator for parsing path strings\n   */\n  splitSep: '/' = '/'\n  /**\n   * separator for generating path strings\n   */\n  sep: '/' = '/'\n\n  /**\n   * Do not create new Path objects directly.  They should always be accessed\n   * via the PathScurry class or other methods on the Path class.\n   *\n   * @internal\n   */\n  constructor(\n    name: string,\n    type: number = UNKNOWN,\n    root: PathBase | undefined,\n    roots: { [k: string]: PathBase },\n    nocase: boolean,\n    children: ChildrenCache,\n    opts: PathOpts\n  ) {\n    super(name, type, root, roots, nocase, children, opts)\n  }\n\n  /**\n   * @internal\n   */\n  getRootString(path: string): string {\n    return path.startsWith('/') ? '/' : ''\n  }\n\n  /**\n   * @internal\n   */\n  getRoot(_rootPath: string): PathBase {\n    return this.root\n  }\n\n  /**\n   * @internal\n   */\n  newChild(name: string, type: number = UNKNOWN, opts: PathOpts = {}) {\n    return new PathPosix(\n      name,\n      type,\n      this.root,\n      this.roots,\n      this.nocase,\n      this.childrenCache(),\n      opts\n    )\n  }\n}\n\n/**\n * Options that may be provided to the PathScurry constructor\n */\nexport interface PathScurryOpts {\n  /**\n   * perform case-insensitive path matching. Default based on platform\n   * subclass.\n   */\n  nocase?: boolean\n  /**\n   * Number of Path entries to keep in the cache of Path child references.\n   *\n   * Setting this higher than 65536 will dramatically increase the data\n   * consumption and construction time overhead of each PathScurry.\n   *\n   * Setting this value to 256 or lower will significantly reduce the data\n   * consumption and construction time overhead, but may also reduce resolve()\n   * and readdir() performance on large filesystems.\n   *\n   * Default `16384`.\n   */\n  childrenCacheSize?: number\n  /**\n   * An object that overrides the built-in functions from the fs and\n   * fs/promises modules.\n   *\n   * See {@link FSOption}\n   */\n  fs?: FSOption\n}\n\n/**\n * The base class for all PathScurry classes, providing the interface for path\n * resolution and filesystem operations.\n *\n * Typically, you should *not* instantiate this class directly, but rather one\n * of the platform-specific classes, or the exported {@link PathScurry} which\n * defaults to the current platform.\n */\nexport abstract class PathScurryBase {\n  /**\n   * The root Path entry for the current working directory of this Scurry\n   */\n  root: PathBase\n  /**\n   * The string path for the root of this Scurry's current working directory\n   */\n  rootPath: string\n  /**\n   * A collection of all roots encountered, referenced by rootPath\n   */\n  roots: { [k: string]: PathBase }\n  /**\n   * The Path entry corresponding to this PathScurry's current working directory.\n   */\n  cwd: PathBase\n  #resolveCache: ResolveCache\n  #resolvePosixCache: ResolveCache\n  #children: ChildrenCache\n  /**\n   * Perform path comparisons case-insensitively.\n   *\n   * Defaults true on Darwin and Windows systems, false elsewhere.\n   */\n  nocase: boolean\n\n  /**\n   * The path separator used for parsing paths\n   *\n   * `'/'` on Posix systems, either `'/'` or `'\\\\'` on Windows\n   */\n  abstract sep: string | RegExp\n\n  #fs: FSValue\n\n  /**\n   * This class should not be instantiated directly.\n   *\n   * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry\n   *\n   * @internal\n   */\n  constructor(\n    cwd: URL | string = process.cwd(),\n    pathImpl: typeof win32 | typeof posix,\n    sep: string | RegExp,\n    {\n      nocase,\n      childrenCacheSize = 16 * 1024,\n      fs = defaultFS,\n    }: PathScurryOpts = {}\n  ) {\n    this.#fs = fsFromOption(fs)\n    if (cwd instanceof URL || cwd.startsWith('file://')) {\n      cwd = fileURLToPath(cwd)\n    }\n    // resolve and split root, and then add to the store.\n    // this is the only time we call path.resolve()\n    const cwdPath = pathImpl.resolve(cwd)\n    this.roots = Object.create(null)\n    this.rootPath = this.parseRootPath(cwdPath)\n    this.#resolveCache = new ResolveCache()\n    this.#resolvePosixCache = new ResolveCache()\n    this.#children = new ChildrenCache(childrenCacheSize)\n\n    const split = cwdPath.substring(this.rootPath.length).split(sep)\n    // resolve('/') leaves '', splits to [''], we don't want that.\n    if (split.length === 1 && !split[0]) {\n      split.pop()\n    }\n    /* c8 ignore start */\n    if (nocase === undefined) {\n      throw new TypeError(\n        'must provide nocase setting to PathScurryBase ctor'\n      )\n    }\n    /* c8 ignore stop */\n    this.nocase = nocase\n    this.root = this.newRoot(this.#fs)\n    this.roots[this.rootPath] = this.root\n    let prev: PathBase = this.root\n    let len = split.length - 1\n    const joinSep = pathImpl.sep\n    let abs = this.rootPath\n    let sawFirst = false\n    for (const part of split) {\n      const l = len--\n      prev = prev.child(part, {\n        relative: new Array(l).fill('..').join(joinSep),\n        relativePosix: new Array(l).fill('..').join('/'),\n        fullpath: (abs += (sawFirst ? '' : joinSep) + part),\n      })\n      sawFirst = true\n    }\n    this.cwd = prev\n  }\n\n  /**\n   * Get the depth of a provided path, string, or the cwd\n   */\n  depth(path: Path | string = this.cwd): number {\n    if (typeof path === 'string') {\n      path = this.cwd.resolve(path)\n    }\n    return path.depth()\n  }\n\n  /**\n   * Parse the root portion of a path string\n   *\n   * @internal\n   */\n  abstract parseRootPath(dir: string): string\n  /**\n   * create a new Path to use as root during construction.\n   *\n   * @internal\n   */\n  abstract newRoot(fs: FSValue): PathBase\n  /**\n   * Determine whether a given path string is absolute\n   */\n  abstract isAbsolute(p: string): boolean\n\n  /**\n   * Return the cache of child entries.  Exposed so subclasses can create\n   * child Path objects in a platform-specific way.\n   *\n   * @internal\n   */\n  childrenCache() {\n    return this.#children\n  }\n\n  /**\n   * Resolve one or more path strings to a resolved string\n   *\n   * Same interface as require('path').resolve.\n   *\n   * Much faster than path.resolve() when called multiple times for the same\n   * path, because the resolved Path objects are cached.  Much slower\n   * otherwise.\n   */\n  resolve(...paths: string[]): string {\n    // first figure out the minimum number of paths we have to test\n    // we always start at cwd, but any absolutes will bump the start\n    let r = ''\n    for (let i = paths.length - 1; i >= 0; i--) {\n      const p = paths[i]\n      if (!p || p === '.') continue\n      r = r ? `${p}/${r}` : p\n      if (this.isAbsolute(p)) {\n        break\n      }\n    }\n    const cached = this.#resolveCache.get(r)\n    if (cached !== undefined) {\n      return cached\n    }\n    const result = this.cwd.resolve(r).fullpath()\n    this.#resolveCache.set(r, result)\n    return result\n  }\n\n  /**\n   * Resolve one or more path strings to a resolved string, returning\n   * the posix path.  Identical to .resolve() on posix systems, but on\n   * windows will return a forward-slash separated UNC path.\n   *\n   * Same interface as require('path').resolve.\n   *\n   * Much faster than path.resolve() when called multiple times for the same\n   * path, because the resolved Path objects are cached.  Much slower\n   * otherwise.\n   */\n  resolvePosix(...paths: string[]): string {\n    // first figure out the minimum number of paths we have to test\n    // we always start at cwd, but any absolutes will bump the start\n    let r = ''\n    for (let i = paths.length - 1; i >= 0; i--) {\n      const p = paths[i]\n      if (!p || p === '.') continue\n      r = r ? `${p}/${r}` : p\n      if (this.isAbsolute(p)) {\n        break\n      }\n    }\n    const cached = this.#resolvePosixCache.get(r)\n    if (cached !== undefined) {\n      return cached\n    }\n    const result = this.cwd.resolve(r).fullpathPosix()\n    this.#resolvePosixCache.set(r, result)\n    return result\n  }\n\n  /**\n   * find the relative path from the cwd to the supplied path string or entry\n   */\n  relative(entry: PathBase | string = this.cwd): string {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return entry.relative()\n  }\n\n  /**\n   * find the relative path from the cwd to the supplied path string or\n   * entry, using / as the path delimiter, even on Windows.\n   */\n  relativePosix(entry: PathBase | string = this.cwd): string {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return entry.relativePosix()\n  }\n\n  /**\n   * Return the basename for the provided string or Path object\n   */\n  basename(entry: PathBase | string = this.cwd): string {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return entry.name\n  }\n\n  /**\n   * Return the dirname for the provided string or Path object\n   */\n  dirname(entry: PathBase | string = this.cwd): string {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return (entry.parent || entry).fullpath()\n  }\n\n  /**\n   * Return an array of known child entries.\n   *\n   * First argument may be either a string, or a Path object.\n   *\n   * If the Path cannot or does not contain any children, then an empty array\n   * is returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   *\n   * Unlike `fs.readdir()`, the `withFileTypes` option defaults to `true`. Set\n   * `{ withFileTypes: false }` to return strings.\n   */\n\n  readdir(): Promise<PathBase[]>\n  readdir(opts: { withFileTypes: true }): Promise<PathBase[]>\n  readdir(opts: { withFileTypes: false }): Promise<string[]>\n  readdir(opts: { withFileTypes: boolean }): Promise<PathBase[] | string[]>\n  readdir(entry: PathBase | string): Promise<PathBase[]>\n  readdir(\n    entry: PathBase | string,\n    opts: { withFileTypes: true }\n  ): Promise<PathBase[]>\n  readdir(\n    entry: PathBase | string,\n    opts: { withFileTypes: false }\n  ): Promise<string[]>\n  readdir(\n    entry: PathBase | string,\n    opts: { withFileTypes: boolean }\n  ): Promise<PathBase[] | string[]>\n  async readdir(\n    entry: PathBase | string | { withFileTypes: boolean } = this.cwd,\n    opts: { withFileTypes: boolean } = {\n      withFileTypes: true,\n    }\n  ): Promise<PathBase[] | string[]> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const { withFileTypes } = opts\n    if (!entry.canReaddir()) {\n      return []\n    } else {\n      const p = await entry.readdir()\n      return withFileTypes ? p : p.map(e => e.name)\n    }\n  }\n\n  /**\n   * synchronous {@link PathScurryBase.readdir}\n   */\n  readdirSync(): PathBase[]\n  readdirSync(opts: { withFileTypes: true }): PathBase[]\n  readdirSync(opts: { withFileTypes: false }): string[]\n  readdirSync(opts: { withFileTypes: boolean }): PathBase[] | string[]\n  readdirSync(entry: PathBase | string): PathBase[]\n  readdirSync(\n    entry: PathBase | string,\n    opts: { withFileTypes: true }\n  ): PathBase[]\n  readdirSync(\n    entry: PathBase | string,\n    opts: { withFileTypes: false }\n  ): string[]\n  readdirSync(\n    entry: PathBase | string,\n    opts: { withFileTypes: boolean }\n  ): PathBase[] | string[]\n  readdirSync(\n    entry: PathBase | string | { withFileTypes: boolean } = this.cwd,\n    opts: { withFileTypes: boolean } = {\n      withFileTypes: true,\n    }\n  ): PathBase[] | string[] {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const { withFileTypes = true } = opts\n    if (!entry.canReaddir()) {\n      return []\n    } else if (withFileTypes) {\n      return entry.readdirSync()\n    } else {\n      return entry.readdirSync().map(e => e.name)\n    }\n  }\n\n  /**\n   * Call lstat() on the string or Path object, and update all known\n   * information that can be determined.\n   *\n   * Note that unlike `fs.lstat()`, the returned value does not contain some\n   * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that\n   * information is required, you will need to call `fs.lstat` yourself.\n   *\n   * If the Path refers to a nonexistent file, or if the lstat call fails for\n   * any reason, `undefined` is returned.  Otherwise the updated Path object is\n   * returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   */\n  async lstat(\n    entry: string | PathBase = this.cwd\n  ): Promise<PathBase | undefined> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return entry.lstat()\n  }\n\n  /**\n   * synchronous {@link PathScurryBase.lstat}\n   */\n  lstatSync(entry: string | PathBase = this.cwd): PathBase | undefined {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return entry.lstatSync()\n  }\n\n  /**\n   * Return the Path object or string path corresponding to the target of a\n   * symbolic link.\n   *\n   * If the path is not a symbolic link, or if the readlink call fails for any\n   * reason, `undefined` is returned.\n   *\n   * Result is cached, and thus may be outdated if the filesystem is mutated.\n   *\n   * `{withFileTypes}` option defaults to `false`.\n   *\n   * On success, returns a Path object if `withFileTypes` option is true,\n   * otherwise a string.\n   */\n  readlink(): Promise<string | undefined>\n  readlink(opt: { withFileTypes: false }): Promise<string | undefined>\n  readlink(opt: { withFileTypes: true }): Promise<PathBase | undefined>\n  readlink(opt: {\n    withFileTypes: boolean\n  }): Promise<PathBase | string | undefined>\n  readlink(\n    entry: string | PathBase,\n    opt?: { withFileTypes: false }\n  ): Promise<string | undefined>\n  readlink(\n    entry: string | PathBase,\n    opt: { withFileTypes: true }\n  ): Promise<PathBase | undefined>\n  readlink(\n    entry: string | PathBase,\n    opt: { withFileTypes: boolean }\n  ): Promise<string | PathBase | undefined>\n  async readlink(\n    entry: string | PathBase | { withFileTypes: boolean } = this.cwd,\n    { withFileTypes }: { withFileTypes: boolean } = {\n      withFileTypes: false,\n    }\n  ): Promise<string | PathBase | undefined> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      withFileTypes = entry.withFileTypes\n      entry = this.cwd\n    }\n    const e = await entry.readlink()\n    return withFileTypes ? e : e?.fullpath()\n  }\n\n  /**\n   * synchronous {@link PathScurryBase.readlink}\n   */\n  readlinkSync(): string | undefined\n  readlinkSync(opt: { withFileTypes: false }): string | undefined\n  readlinkSync(opt: { withFileTypes: true }): PathBase | undefined\n  readlinkSync(opt: {\n    withFileTypes: boolean\n  }): PathBase | string | undefined\n  readlinkSync(\n    entry: string | PathBase,\n    opt?: { withFileTypes: false }\n  ): string | undefined\n  readlinkSync(\n    entry: string | PathBase,\n    opt: { withFileTypes: true }\n  ): PathBase | undefined\n  readlinkSync(\n    entry: string | PathBase,\n    opt: { withFileTypes: boolean }\n  ): string | PathBase | undefined\n  readlinkSync(\n    entry: string | PathBase | { withFileTypes: boolean } = this.cwd,\n    { withFileTypes }: { withFileTypes: boolean } = {\n      withFileTypes: false,\n    }\n  ): string | PathBase | undefined {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      withFileTypes = entry.withFileTypes\n      entry = this.cwd\n    }\n    const e = entry.readlinkSync()\n    return withFileTypes ? e : e?.fullpath()\n  }\n\n  /**\n   * Return the Path object or string path corresponding to path as resolved\n   * by realpath(3).\n   *\n   * If the realpath call fails for any reason, `undefined` is returned.\n   *\n   * Result is cached, and thus may be outdated if the filesystem is mutated.\n   *\n   * `{withFileTypes}` option defaults to `false`.\n   *\n   * On success, returns a Path object if `withFileTypes` option is true,\n   * otherwise a string.\n   */\n  realpath(): Promise<string | undefined>\n  realpath(opt: { withFileTypes: false }): Promise<string | undefined>\n  realpath(opt: { withFileTypes: true }): Promise<PathBase | undefined>\n  realpath(opt: {\n    withFileTypes: boolean\n  }): Promise<PathBase | string | undefined>\n  realpath(\n    entry: string | PathBase,\n    opt?: { withFileTypes: false }\n  ): Promise<string | undefined>\n  realpath(\n    entry: string | PathBase,\n    opt: { withFileTypes: true }\n  ): Promise<PathBase | undefined>\n  realpath(\n    entry: string | PathBase,\n    opt: { withFileTypes: boolean }\n  ): Promise<string | PathBase | undefined>\n  async realpath(\n    entry: string | PathBase | { withFileTypes: boolean } = this.cwd,\n    { withFileTypes }: { withFileTypes: boolean } = {\n      withFileTypes: false,\n    }\n  ): Promise<string | PathBase | undefined> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      withFileTypes = entry.withFileTypes\n      entry = this.cwd\n    }\n    const e = await entry.realpath()\n    return withFileTypes ? e : e?.fullpath()\n  }\n\n  realpathSync(): string | undefined\n  realpathSync(opt: { withFileTypes: false }): string | undefined\n  realpathSync(opt: { withFileTypes: true }): PathBase | undefined\n  realpathSync(opt: {\n    withFileTypes: boolean\n  }): PathBase | string | undefined\n  realpathSync(\n    entry: string | PathBase,\n    opt?: { withFileTypes: false }\n  ): string | undefined\n  realpathSync(\n    entry: string | PathBase,\n    opt: { withFileTypes: true }\n  ): PathBase | undefined\n  realpathSync(\n    entry: string | PathBase,\n    opt: { withFileTypes: boolean }\n  ): string | PathBase | undefined\n  realpathSync(\n    entry: string | PathBase | { withFileTypes: boolean } = this.cwd,\n    { withFileTypes }: { withFileTypes: boolean } = {\n      withFileTypes: false,\n    }\n  ): string | PathBase | undefined {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      withFileTypes = entry.withFileTypes\n      entry = this.cwd\n    }\n    const e = entry.realpathSync()\n    return withFileTypes ? e : e?.fullpath()\n  }\n\n  /**\n   * Asynchronously walk the directory tree, returning an array of\n   * all path strings or Path objects found.\n   *\n   * Note that this will be extremely memory-hungry on large filesystems.\n   * In such cases, it may be better to use the stream or async iterator\n   * walk implementation.\n   */\n  walk(): Promise<PathBase[]>\n  walk(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset\n  ): Promise<PathBase[]>\n  walk(opts: WalkOptionsWithFileTypesFalse): Promise<string[]>\n  walk(opts: WalkOptions): Promise<string[] | PathBase[]>\n  walk(entry: string | PathBase): Promise<PathBase[]>\n  walk(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset\n  ): Promise<PathBase[]>\n  walk(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse\n  ): Promise<string[]>\n  walk(\n    entry: string | PathBase,\n    opts: WalkOptions\n  ): Promise<PathBase[] | string[]>\n  async walk(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    opts: WalkOptions = {}\n  ): Promise<PathBase[] | string[]> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter,\n    } = opts\n    const results: (string | PathBase)[] = []\n    if (!filter || filter(entry)) {\n      results.push(withFileTypes ? entry : entry.fullpath())\n    }\n    const dirs = new Set<PathBase>()\n    const walk = (\n      dir: PathBase,\n      cb: (er?: NodeJS.ErrnoException) => void\n    ) => {\n      dirs.add(dir)\n      dir.readdirCB((er, entries) => {\n        /* c8 ignore start */\n        if (er) {\n          return cb(er)\n        }\n        /* c8 ignore stop */\n        let len = entries.length\n        if (!len) return cb()\n        const next = () => {\n          if (--len === 0) {\n            cb()\n          }\n        }\n        for (const e of entries) {\n          if (!filter || filter(e)) {\n            results.push(withFileTypes ? e : e.fullpath())\n          }\n          if (follow && e.isSymbolicLink()) {\n            e.realpath()\n              .then(r => (r?.isUnknown() ? r.lstat() : r))\n              .then(r =>\n                r?.shouldWalk(dirs, walkFilter) ? walk(r, next) : next()\n              )\n          } else {\n            if (e.shouldWalk(dirs, walkFilter)) {\n              walk(e, next)\n            } else {\n              next()\n            }\n          }\n        }\n      }, true) // zalgooooooo\n    }\n\n    const start = entry\n    return new Promise<PathBase[] | string[]>((res, rej) => {\n      walk(start, er => {\n        /* c8 ignore start */\n        if (er) return rej(er)\n        /* c8 ignore stop */\n        res(results as PathBase[] | string[])\n      })\n    })\n  }\n\n  /**\n   * Synchronously walk the directory tree, returning an array of\n   * all path strings or Path objects found.\n   *\n   * Note that this will be extremely memory-hungry on large filesystems.\n   * In such cases, it may be better to use the stream or async iterator\n   * walk implementation.\n   */\n  walkSync(): PathBase[]\n  walkSync(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset\n  ): PathBase[]\n  walkSync(opts: WalkOptionsWithFileTypesFalse): string[]\n  walkSync(opts: WalkOptions): string[] | PathBase[]\n  walkSync(entry: string | PathBase): PathBase[]\n  walkSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesUnset | WalkOptionsWithFileTypesTrue\n  ): PathBase[]\n  walkSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse\n  ): string[]\n  walkSync(\n    entry: string | PathBase,\n    opts: WalkOptions\n  ): PathBase[] | string[]\n  walkSync(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    opts: WalkOptions = {}\n  ): PathBase[] | string[] {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter,\n    } = opts\n    const results: (string | PathBase)[] = []\n    if (!filter || filter(entry)) {\n      results.push(withFileTypes ? entry : entry.fullpath())\n    }\n    const dirs = new Set<PathBase>([entry])\n    for (const dir of dirs) {\n      const entries = dir.readdirSync()\n      for (const e of entries) {\n        if (!filter || filter(e)) {\n          results.push(withFileTypes ? e : e.fullpath())\n        }\n        let r: PathBase | undefined = e\n        if (e.isSymbolicLink()) {\n          if (!(follow && (r = e.realpathSync()))) continue\n          if (r.isUnknown()) r.lstatSync()\n        }\n        if (r.shouldWalk(dirs, walkFilter)) {\n          dirs.add(r)\n        }\n      }\n    }\n    return results as string[] | PathBase[]\n  }\n\n  /**\n   * Support for `for await`\n   *\n   * Alias for {@link PathScurryBase.iterate}\n   *\n   * Note: As of Node 19, this is very slow, compared to other methods of\n   * walking.  Consider using {@link PathScurryBase.stream} if memory overhead\n   * and backpressure are concerns, or {@link PathScurryBase.walk} if not.\n   */\n  [Symbol.asyncIterator]() {\n    return this.iterate()\n  }\n\n  /**\n   * Async generator form of {@link PathScurryBase.walk}\n   *\n   * Note: As of Node 19, this is very slow, compared to other methods of\n   * walking, especially if most/all of the directory tree has been previously\n   * walked.  Consider using {@link PathScurryBase.stream} if memory overhead\n   * and backpressure are concerns, or {@link PathScurryBase.walk} if not.\n   */\n  iterate(): AsyncGenerator<PathBase, void, void>\n  iterate(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset\n  ): AsyncGenerator<PathBase, void, void>\n  iterate(\n    opts: WalkOptionsWithFileTypesFalse\n  ): AsyncGenerator<string, void, void>\n  iterate(opts: WalkOptions): AsyncGenerator<string | PathBase, void, void>\n  iterate(entry: string | PathBase): AsyncGenerator<PathBase, void, void>\n  iterate(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset\n  ): AsyncGenerator<PathBase, void, void>\n  iterate(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse\n  ): AsyncGenerator<string, void, void>\n  iterate(\n    entry: string | PathBase,\n    opts: WalkOptions\n  ): AsyncGenerator<PathBase | string, void, void>\n  iterate(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    options: WalkOptions = {}\n  ): AsyncGenerator<PathBase | string, void, void> {\n    // iterating async over the stream is significantly more performant,\n    // especially in the warm-cache scenario, because it buffers up directory\n    // entries in the background instead of waiting for a yield for each one.\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      options = entry\n      entry = this.cwd\n    }\n    return this.stream(entry, options)[Symbol.asyncIterator]()\n  }\n\n  /**\n   * Iterating over a PathScurry performs a synchronous walk.\n   *\n   * Alias for {@link PathScurryBase.iterateSync}\n   */\n  [Symbol.iterator]() {\n    return this.iterateSync()\n  }\n\n  iterateSync(): Generator<PathBase, void, void>\n  iterateSync(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset\n  ): Generator<PathBase, void, void>\n  iterateSync(\n    opts: WalkOptionsWithFileTypesFalse\n  ): Generator<string, void, void>\n  iterateSync(opts: WalkOptions): Generator<string | PathBase, void, void>\n  iterateSync(entry: string | PathBase): Generator<PathBase, void, void>\n  iterateSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset\n  ): Generator<PathBase, void, void>\n  iterateSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse\n  ): Generator<string, void, void>\n  iterateSync(\n    entry: string | PathBase,\n    opts: WalkOptions\n  ): Generator<PathBase | string, void, void>\n  *iterateSync(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    opts: WalkOptions = {}\n  ): Generator<PathBase | string, void, void> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter,\n    } = opts\n    if (!filter || filter(entry)) {\n      yield withFileTypes ? entry : entry.fullpath()\n    }\n    const dirs = new Set<PathBase>([entry])\n    for (const dir of dirs) {\n      const entries = dir.readdirSync()\n      for (const e of entries) {\n        if (!filter || filter(e)) {\n          yield withFileTypes ? e : e.fullpath()\n        }\n        let r: PathBase | undefined = e\n        if (e.isSymbolicLink()) {\n          if (!(follow && (r = e.realpathSync()))) continue\n          if (r.isUnknown()) r.lstatSync()\n        }\n        if (r.shouldWalk(dirs, walkFilter)) {\n          dirs.add(r)\n        }\n      }\n    }\n  }\n\n  /**\n   * Stream form of {@link PathScurryBase.walk}\n   *\n   * Returns a Minipass stream that emits {@link PathBase} objects by default,\n   * or strings if `{ withFileTypes: false }` is set in the options.\n   */\n  stream(): Minipass<PathBase>\n  stream(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset\n  ): Minipass<PathBase>\n  stream(opts: WalkOptionsWithFileTypesFalse): Minipass<string>\n  stream(opts: WalkOptions): Minipass<string | PathBase>\n  stream(entry: string | PathBase): Minipass<PathBase>\n  stream(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesUnset | WalkOptionsWithFileTypesTrue\n  ): Minipass<PathBase>\n  stream(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse\n  ): Minipass<string>\n  stream(\n    entry: string | PathBase,\n    opts: WalkOptions\n  ): Minipass<string> | Minipass<PathBase>\n  stream(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    opts: WalkOptions = {}\n  ): Minipass<string> | Minipass<PathBase> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter,\n    } = opts\n    const results = new Minipass<string | PathBase>({ objectMode: true })\n    if (!filter || filter(entry)) {\n      results.write(withFileTypes ? entry : entry.fullpath())\n    }\n    const dirs = new Set<PathBase>()\n    const queue: PathBase[] = [entry]\n    let processing = 0\n    const process = () => {\n      let paused = false\n      while (!paused) {\n        const dir = queue.shift()\n        if (!dir) {\n          if (processing === 0) results.end()\n          return\n        }\n\n        processing++\n        dirs.add(dir)\n\n        const onReaddir = (\n          er: null | NodeJS.ErrnoException,\n          entries: PathBase[],\n          didRealpaths: boolean = false\n        ) => {\n          /* c8 ignore start */\n          if (er) return results.emit('error', er)\n          /* c8 ignore stop */\n          if (follow && !didRealpaths) {\n            const promises: Promise<PathBase | undefined>[] = []\n            for (const e of entries) {\n              if (e.isSymbolicLink()) {\n                promises.push(\n                  e\n                    .realpath()\n                    .then((r: PathBase | undefined) =>\n                      r?.isUnknown() ? r.lstat() : r\n                    )\n                )\n              }\n            }\n            if (promises.length) {\n              Promise.all(promises).then(() =>\n                onReaddir(null, entries, true)\n              )\n              return\n            }\n          }\n\n          for (const e of entries) {\n            if (e && (!filter || filter(e))) {\n              if (!results.write(withFileTypes ? e : e.fullpath())) {\n                paused = true\n              }\n            }\n          }\n\n          processing--\n          for (const e of entries) {\n            const r = e.realpathCached() || e\n            if (r.shouldWalk(dirs, walkFilter)) {\n              queue.push(r)\n            }\n          }\n          if (paused && !results.flowing) {\n            results.once('drain', process)\n          } else if (!sync) {\n            process()\n          }\n        }\n\n        // zalgo containment\n        let sync = true\n        dir.readdirCB(onReaddir, true)\n        sync = false\n      }\n    }\n    process()\n    return results as Minipass<string> | Minipass<PathBase>\n  }\n\n  /**\n   * Synchronous form of {@link PathScurryBase.stream}\n   *\n   * Returns a Minipass stream that emits {@link PathBase} objects by default,\n   * or strings if `{ withFileTypes: false }` is set in the options.\n   *\n   * Will complete the walk in a single tick if the stream is consumed fully.\n   * Otherwise, will pause as needed for stream backpressure.\n   */\n  streamSync(): Minipass<PathBase>\n  streamSync(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset\n  ): Minipass<PathBase>\n  streamSync(opts: WalkOptionsWithFileTypesFalse): Minipass<string>\n  streamSync(opts: WalkOptions): Minipass<string | PathBase>\n  streamSync(entry: string | PathBase): Minipass<PathBase>\n  streamSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesUnset | WalkOptionsWithFileTypesTrue\n  ): Minipass<PathBase>\n  streamSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse\n  ): Minipass<string>\n  streamSync(\n    entry: string | PathBase,\n    opts: WalkOptions\n  ): Minipass<string> | Minipass<PathBase>\n  streamSync(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    opts: WalkOptions = {}\n  ): Minipass<string> | Minipass<PathBase> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter,\n    } = opts\n    const results = new Minipass<string | PathBase>({ objectMode: true })\n    const dirs = new Set<PathBase>()\n    if (!filter || filter(entry)) {\n      results.write(withFileTypes ? entry : entry.fullpath())\n    }\n    const queue: PathBase[] = [entry]\n    let processing = 0\n    const process = () => {\n      let paused = false\n      while (!paused) {\n        const dir = queue.shift()\n        if (!dir) {\n          if (processing === 0) results.end()\n          return\n        }\n        processing++\n        dirs.add(dir)\n\n        const entries = dir.readdirSync()\n        for (const e of entries) {\n          if (!filter || filter(e)) {\n            if (!results.write(withFileTypes ? e : e.fullpath())) {\n              paused = true\n            }\n          }\n        }\n        processing--\n        for (const e of entries) {\n          let r: PathBase | undefined = e\n          if (e.isSymbolicLink()) {\n            if (!(follow && (r = e.realpathSync()))) continue\n            if (r.isUnknown()) r.lstatSync()\n          }\n          if (r.shouldWalk(dirs, walkFilter)) {\n            queue.push(r)\n          }\n        }\n      }\n      if (paused && !results.flowing) results.once('drain', process)\n    }\n    process()\n    return results as Minipass<string> | Minipass<PathBase>\n  }\n\n  chdir(path: string | Path = this.cwd) {\n    const oldCwd = this.cwd\n    this.cwd = typeof path === 'string' ? this.cwd.resolve(path) : path\n    this.cwd[setAsCwd](oldCwd)\n  }\n}\n\n/**\n * Options provided to all walk methods.\n */\nexport interface WalkOptions {\n  /**\n   * Return results as {@link PathBase} objects rather than strings.\n   * When set to false, results are fully resolved paths, as returned by\n   * {@link PathBase.fullpath}.\n   * @default true\n   */\n  withFileTypes?: boolean\n\n  /**\n   *  Attempt to read directory entries from symbolic links. Otherwise, only\n   *  actual directories are traversed. Regardless of this setting, a given\n   *  target path will only ever be walked once, meaning that a symbolic link\n   *  to a previously traversed directory will never be followed.\n   *\n   *  Setting this imposes a slight performance penalty, because `readlink`\n   *  must be called on all symbolic links encountered, in order to avoid\n   *  infinite cycles.\n   * @default false\n   */\n  follow?: boolean\n\n  /**\n   * Only return entries where the provided function returns true.\n   *\n   * This will not prevent directories from being traversed, even if they do\n   * not pass the filter, though it will prevent directories themselves from\n   * being included in the result set.  See {@link walkFilter}\n   *\n   * Asynchronous functions are not supported here.\n   *\n   * By default, if no filter is provided, all entries and traversed\n   * directories are included.\n   */\n  filter?: (entry: PathBase) => boolean\n\n  /**\n   * Only traverse directories (and in the case of {@link follow} being set to\n   * true, symbolic links to directories) if the provided function returns\n   * true.\n   *\n   * This will not prevent directories from being included in the result set,\n   * even if they do not pass the supplied filter function.  See {@link filter}\n   * to do that.\n   *\n   * Asynchronous functions are not supported here.\n   */\n  walkFilter?: (entry: PathBase) => boolean\n}\n\nexport type WalkOptionsWithFileTypesUnset = WalkOptions & {\n  withFileTypes?: undefined\n}\nexport type WalkOptionsWithFileTypesTrue = WalkOptions & {\n  withFileTypes: true\n}\nexport type WalkOptionsWithFileTypesFalse = WalkOptions & {\n  withFileTypes: false\n}\n\n/**\n * Windows implementation of {@link PathScurryBase}\n *\n * Defaults to case insensitve, uses `'\\\\'` to generate path strings.  Uses\n * {@link PathWin32} for Path objects.\n */\nexport class PathScurryWin32 extends PathScurryBase {\n  /**\n   * separator for generating path strings\n   */\n  sep: '\\\\' = '\\\\'\n\n  constructor(\n    cwd: URL | string = process.cwd(),\n    opts: PathScurryOpts = {}\n  ) {\n    const { nocase = true } = opts\n    super(cwd, win32, '\\\\', { ...opts, nocase })\n    this.nocase = nocase\n    for (let p: PathBase | undefined = this.cwd; p; p = p.parent) {\n      p.nocase = this.nocase\n    }\n  }\n\n  /**\n   * @internal\n   */\n  parseRootPath(dir: string): string {\n    // if the path starts with a single separator, it's not a UNC, and we'll\n    // just get separator as the root, and driveFromUNC will return \\\n    // In that case, mount \\ on the root from the cwd.\n    return win32.parse(dir).root.toUpperCase()\n  }\n\n  /**\n   * @internal\n   */\n  newRoot(fs: FSValue) {\n    return new PathWin32(\n      this.rootPath,\n      IFDIR,\n      undefined,\n      this.roots,\n      this.nocase,\n      this.childrenCache(),\n      { fs }\n    )\n  }\n\n  /**\n   * Return true if the provided path string is an absolute path\n   */\n  isAbsolute(p: string): boolean {\n    return (\n      p.startsWith('/') || p.startsWith('\\\\') || /^[a-z]:(\\/|\\\\)/i.test(p)\n    )\n  }\n}\n\n/**\n * {@link PathScurryBase} implementation for all posix systems other than Darwin.\n *\n * Defaults to case-sensitive matching, uses `'/'` to generate path strings.\n *\n * Uses {@link PathPosix} for Path objects.\n */\nexport class PathScurryPosix extends PathScurryBase {\n  /**\n   * separator for generating path strings\n   */\n  sep: '/' = '/'\n  constructor(\n    cwd: URL | string = process.cwd(),\n    opts: PathScurryOpts = {}\n  ) {\n    const { nocase = false } = opts\n    super(cwd, posix, '/', { ...opts, nocase })\n    this.nocase = nocase\n  }\n\n  /**\n   * @internal\n   */\n  parseRootPath(_dir: string): string {\n    return '/'\n  }\n\n  /**\n   * @internal\n   */\n  newRoot(fs: FSValue) {\n    return new PathPosix(\n      this.rootPath,\n      IFDIR,\n      undefined,\n      this.roots,\n      this.nocase,\n      this.childrenCache(),\n      { fs }\n    )\n  }\n\n  /**\n   * Return true if the provided path string is an absolute path\n   */\n  isAbsolute(p: string): boolean {\n    return p.startsWith('/')\n  }\n}\n\n/**\n * {@link PathScurryBase} implementation for Darwin (macOS) systems.\n *\n * Defaults to case-insensitive matching, uses `'/'` for generating path\n * strings.\n *\n * Uses {@link PathPosix} for Path objects.\n */\nexport class PathScurryDarwin extends PathScurryPosix {\n  constructor(\n    cwd: URL | string = process.cwd(),\n    opts: PathScurryOpts = {}\n  ) {\n    const { nocase = true } = opts\n    super(cwd, { ...opts, nocase })\n  }\n}\n\n/**\n * Default {@link PathBase} implementation for the current platform.\n *\n * {@link PathWin32} on Windows systems, {@link PathPosix} on all others.\n */\nexport const Path = process.platform === 'win32' ? PathWin32 : PathPosix\nexport type Path = PathBase | InstanceType<typeof Path>\n\n/**\n * Default {@link PathScurryBase} implementation for the current platform.\n *\n * {@link PathScurryWin32} on Windows systems, {@link PathScurryDarwin} on\n * Darwin (macOS) systems, {@link PathScurryPosix} on all others.\n */\nexport const PathScurry:\n  | typeof PathScurryWin32\n  | typeof PathScurryDarwin\n  | typeof PathScurryPosix =\n  process.platform === 'win32'\n    ? PathScurryWin32\n    : process.platform === 'darwin'\n    ? PathScurryDarwin\n    : PathScurryPosix\nexport type PathScurry = PathScurryBase | InstanceType<typeof PathScurry>\n", "const proc =\n  typeof process === 'object' && process\n    ? process\n    : {\n        stdout: null,\n        stderr: null,\n      }\nimport { EventEmitter } from 'events'\nimport Stream from 'stream'\nimport { StringDecoder } from 'string_decoder'\n\n/**\n * Same as StringDecoder, but exposing the `lastNeed` flag on the type\n */\ntype SD = StringDecoder & { lastNeed: boolean }\n\nexport type { SD, Pipe, PipeProxyErrors }\n\n/**\n * Return true if the argument is a Minipass stream, Node stream, or something\n * else that Minipass can interact with.\n */\nexport const isStream = (\n  s: any\n): s is Minipass.Readable | Minipass.Writable =>\n  !!s &&\n  typeof s === 'object' &&\n  (s instanceof Minipass ||\n    s instanceof Stream ||\n    isReadable(s) ||\n    isWritable(s))\n\n/**\n * Return true if the argument is a valid {@link Minipass.Readable}\n */\nexport const isReadable = (s: any): s is Minipass.Readable =>\n  !!s &&\n  typeof s === 'object' &&\n  s instanceof EventEmitter &&\n  typeof (s as Minipass.Readable).pipe === 'function' &&\n  // node core Writable streams have a pipe() method, but it throws\n  (s as Minipass.Readable).pipe !== Stream.Writable.prototype.pipe\n\n/**\n * Return true if the argument is a valid {@link Minipass.Writable}\n */\nexport const isWritable = (s: any): s is Minipass.Readable =>\n  !!s &&\n  typeof s === 'object' &&\n  s instanceof EventEmitter &&\n  typeof (s as Minipass.Writable).write === 'function' &&\n  typeof (s as Minipass.Writable).end === 'function'\n\nconst EOF = Symbol('EOF')\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd')\nconst EMITTED_END = Symbol('emittedEnd')\nconst EMITTING_END = Symbol('emittingEnd')\nconst EMITTED_ERROR = Symbol('emittedError')\nconst CLOSED = Symbol('closed')\nconst READ = Symbol('read')\nconst FLUSH = Symbol('flush')\nconst FLUSHCHUNK = Symbol('flushChunk')\nconst ENCODING = Symbol('encoding')\nconst DECODER = Symbol('decoder')\nconst FLOWING = Symbol('flowing')\nconst PAUSED = Symbol('paused')\nconst RESUME = Symbol('resume')\nconst BUFFER = Symbol('buffer')\nconst PIPES = Symbol('pipes')\nconst BUFFERLENGTH = Symbol('bufferLength')\nconst BUFFERPUSH = Symbol('bufferPush')\nconst BUFFERSHIFT = Symbol('bufferShift')\nconst OBJECTMODE = Symbol('objectMode')\n// internal event when stream is destroyed\nconst DESTROYED = Symbol('destroyed')\n// internal event when stream has an error\nconst ERROR = Symbol('error')\nconst EMITDATA = Symbol('emitData')\nconst EMITEND = Symbol('emitEnd')\nconst EMITEND2 = Symbol('emitEnd2')\nconst ASYNC = Symbol('async')\nconst ABORT = Symbol('abort')\nconst ABORTED = Symbol('aborted')\nconst SIGNAL = Symbol('signal')\nconst DATALISTENERS = Symbol('dataListeners')\nconst DISCARDED = Symbol('discarded')\n\nconst defer = (fn: (...a: any[]) => any) => Promise.resolve().then(fn)\nconst nodefer = (fn: (...a: any[]) => any) => fn()\n\n// events that mean 'the stream is over'\n// these are treated specially, and re-emitted\n// if they are listened for after emitting.\ntype EndishEvent = 'end' | 'finish' | 'prefinish'\nconst isEndish = (ev: any): ev is EndishEvent =>\n  ev === 'end' || ev === 'finish' || ev === 'prefinish'\n\nconst isArrayBufferLike = (b: any): b is ArrayBufferLike =>\n  b instanceof ArrayBuffer ||\n  (!!b &&\n    typeof b === 'object' &&\n    b.constructor &&\n    b.constructor.name === 'ArrayBuffer' &&\n    b.byteLength >= 0)\n\nconst isArrayBufferView = (b: any): b is ArrayBufferView =>\n  !Buffer.isBuffer(b) && ArrayBuffer.isView(b)\n\n/**\n * Options that may be passed to stream.pipe()\n */\nexport interface PipeOptions {\n  /**\n   * end the destination stream when the source stream ends\n   */\n  end?: boolean\n  /**\n   * proxy errors from the source stream to the destination stream\n   */\n  proxyErrors?: boolean\n}\n\n/**\n * Internal class representing a pipe to a destination stream.\n *\n * @internal\n */\nclass Pipe<T extends unknown> {\n  src: Minipass<T>\n  dest: Minipass<any, T>\n  opts: PipeOptions\n  ondrain: () => any\n  constructor(\n    src: Minipass<T>,\n    dest: Minipass.Writable,\n    opts: PipeOptions\n  ) {\n    this.src = src\n    this.dest = dest as Minipass<any, T>\n    this.opts = opts\n    this.ondrain = () => src[RESUME]()\n    this.dest.on('drain', this.ondrain)\n  }\n  unpipe() {\n    this.dest.removeListener('drain', this.ondrain)\n  }\n  // only here for the prototype\n  /* c8 ignore start */\n  proxyErrors(_er: any) {}\n  /* c8 ignore stop */\n  end() {\n    this.unpipe()\n    if (this.opts.end) this.dest.end()\n  }\n}\n\n/**\n * Internal class representing a pipe to a destination stream where\n * errors are proxied.\n *\n * @internal\n */\nclass PipeProxyErrors<T> extends Pipe<T> {\n  unpipe() {\n    this.src.removeListener('error', this.proxyErrors)\n    super.unpipe()\n  }\n  constructor(\n    src: Minipass<T>,\n    dest: Minipass.Writable,\n    opts: PipeOptions\n  ) {\n    super(src, dest, opts)\n    this.proxyErrors = er => dest.emit('error', er)\n    src.on('error', this.proxyErrors)\n  }\n}\n\nexport namespace Minipass {\n  /**\n   * Encoding used to create a stream that outputs strings rather than\n   * Buffer objects.\n   */\n  export type Encoding = BufferEncoding | 'buffer' | null\n\n  /**\n   * Any stream that Minipass can pipe into\n   */\n  export type Writable =\n    | Minipass<any, any, any>\n    | NodeJS.WriteStream\n    | (NodeJS.WriteStream & { fd: number })\n    | (EventEmitter & {\n        end(): any\n        write(chunk: any, ...args: any[]): any\n      })\n\n  /**\n   * Any stream that can be read from\n   */\n  export type Readable =\n    | Minipass<any, any, any>\n    | NodeJS.ReadStream\n    | (NodeJS.ReadStream & { fd: number })\n    | (EventEmitter & {\n        pause(): any\n        resume(): any\n        pipe(...destArgs: any[]): any\n      })\n\n  /**\n   * Utility type that can be iterated sync or async\n   */\n  export type DualIterable<T> = Iterable<T> & AsyncIterable<T>\n\n  type EventArguments = Record<string | symbol, unknown[]>\n\n  /**\n   * The listing of events that a Minipass class can emit.\n   * Extend this when extending the Minipass class, and pass as\n   * the third template argument.  The key is the name of the event,\n   * and the value is the argument list.\n   *\n   * Any undeclared events will still be allowed, but the handler will get\n   * arguments as `unknown[]`.\n   */\n  export interface Events<RType extends any = Buffer>\n    extends EventArguments {\n    readable: []\n    data: [chunk: RType]\n    error: [er: unknown]\n    abort: [reason: unknown]\n    drain: []\n    resume: []\n    end: []\n    finish: []\n    prefinish: []\n    close: []\n    [DESTROYED]: [er?: unknown]\n    [ERROR]: [er: unknown]\n  }\n\n  /**\n   * String or buffer-like data that can be joined and sliced\n   */\n  export type ContiguousData =\n    | Buffer\n    | ArrayBufferLike\n    | ArrayBufferView\n    | string\n  export type BufferOrString = Buffer | string\n\n  /**\n   * Options passed to the Minipass constructor.\n   */\n  export type SharedOptions = {\n    /**\n     * Defer all data emission and other events until the end of the\n     * current tick, similar to Node core streams\n     */\n    async?: boolean\n    /**\n     * A signal which will abort the stream\n     */\n    signal?: AbortSignal\n    /**\n     * Output string encoding. Set to `null` or `'buffer'` (or omit) to\n     * emit Buffer objects rather than strings.\n     *\n     * Conflicts with `objectMode`\n     */\n    encoding?: BufferEncoding | null | 'buffer'\n    /**\n     * Output data exactly as it was written, supporting non-buffer/string\n     * data (such as arbitrary objects, falsey values, etc.)\n     *\n     * Conflicts with `encoding`\n     */\n    objectMode?: boolean\n  }\n\n  /**\n   * Options for a string encoded output\n   */\n  export type EncodingOptions = SharedOptions & {\n    encoding: BufferEncoding\n    objectMode?: false\n  }\n\n  /**\n   * Options for contiguous data buffer output\n   */\n  export type BufferOptions = SharedOptions & {\n    encoding?: null | 'buffer'\n    objectMode?: false\n  }\n\n  /**\n   * Options for objectMode arbitrary output\n   */\n  export type ObjectModeOptions = SharedOptions & {\n    objectMode: true\n    encoding?: null\n  }\n\n  /**\n   * Utility type to determine allowed options based on read type\n   */\n  export type Options<T> = T extends string\n    ? EncodingOptions | ObjectModeOptions\n    : T extends Buffer\n    ? BufferOptions | ObjectModeOptions\n    : SharedOptions\n}\n\nconst isObjectModeOptions = (\n  o: Minipass.SharedOptions\n): o is Minipass.ObjectModeOptions => !!o.objectMode\n\nconst isEncodingOptions = (\n  o: Minipass.SharedOptions\n): o is Minipass.EncodingOptions =>\n  !o.objectMode && !!o.encoding && o.encoding !== 'buffer'\n\n/**\n * Main export, the Minipass class\n *\n * `RType` is the type of data emitted, defaults to Buffer\n *\n * `WType` is the type of data to be written, if RType is buffer or string,\n * then any {@link Minipass.ContiguousData} is allowed.\n *\n * `Events` is the set of event handler signatures that this object\n * will emit, see {@link Minipass.Events}\n */\nexport class Minipass<\n    RType extends unknown = Buffer,\n    WType extends unknown = RType extends Minipass.BufferOrString\n      ? Minipass.ContiguousData\n      : RType,\n    Events extends Minipass.Events<RType> = Minipass.Events<RType>\n  >\n  extends EventEmitter\n  implements Minipass.DualIterable<RType>\n{\n  [FLOWING]: boolean = false;\n  [PAUSED]: boolean = false;\n  [PIPES]: Pipe<RType>[] = [];\n  [BUFFER]: RType[] = [];\n  [OBJECTMODE]: boolean;\n  [ENCODING]: BufferEncoding | null;\n  [ASYNC]: boolean;\n  [DECODER]: SD | null;\n  [EOF]: boolean = false;\n  [EMITTED_END]: boolean = false;\n  [EMITTING_END]: boolean = false;\n  [CLOSED]: boolean = false;\n  [EMITTED_ERROR]: unknown = null;\n  [BUFFERLENGTH]: number = 0;\n  [DESTROYED]: boolean = false;\n  [SIGNAL]?: AbortSignal;\n  [ABORTED]: boolean = false;\n  [DATALISTENERS]: number = 0;\n  [DISCARDED]: boolean = false\n\n  /**\n   * true if the stream can be written\n   */\n  writable: boolean = true\n  /**\n   * true if the stream can be read\n   */\n  readable: boolean = true\n\n  /**\n   * If `RType` is Buffer, then options do not need to be provided.\n   * Otherwise, an options object must be provided to specify either\n   * {@link Minipass.SharedOptions.objectMode} or\n   * {@link Minipass.SharedOptions.encoding}, as appropriate.\n   */\n  constructor(\n    ...args: RType extends Buffer\n      ? [] | [Minipass.Options<RType>]\n      : [Minipass.Options<RType>]\n  ) {\n    const options: Minipass.Options<RType> = (args[0] ||\n      {}) as Minipass.Options<RType>\n    super()\n    if (options.objectMode && typeof options.encoding === 'string') {\n      throw new TypeError(\n        'Encoding and objectMode may not be used together'\n      )\n    }\n    if (isObjectModeOptions(options)) {\n      this[OBJECTMODE] = true\n      this[ENCODING] = null\n    } else if (isEncodingOptions(options)) {\n      this[ENCODING] = options.encoding\n      this[OBJECTMODE] = false\n    } else {\n      this[OBJECTMODE] = false\n      this[ENCODING] = null\n    }\n    this[ASYNC] = !!options.async\n    this[DECODER] = this[ENCODING]\n      ? (new StringDecoder(this[ENCODING]) as SD)\n      : null\n\n    //@ts-ignore - private option for debugging and testing\n    if (options && options.debugExposeBuffer === true) {\n      Object.defineProperty(this, 'buffer', { get: () => this[BUFFER] })\n    }\n    //@ts-ignore - private option for debugging and testing\n    if (options && options.debugExposePipes === true) {\n      Object.defineProperty(this, 'pipes', { get: () => this[PIPES] })\n    }\n\n    const { signal } = options\n    if (signal) {\n      this[SIGNAL] = signal\n      if (signal.aborted) {\n        this[ABORT]()\n      } else {\n        signal.addEventListener('abort', () => this[ABORT]())\n      }\n    }\n  }\n\n  /**\n   * The amount of data stored in the buffer waiting to be read.\n   *\n   * For Buffer strings, this will be the total byte length.\n   * For string encoding streams, this will be the string character length,\n   * according to JavaScript's `string.length` logic.\n   * For objectMode streams, this is a count of the items waiting to be\n   * emitted.\n   */\n  get bufferLength() {\n    return this[BUFFERLENGTH]\n  }\n\n  /**\n   * The `BufferEncoding` currently in use, or `null`\n   */\n  get encoding() {\n    return this[ENCODING]\n  }\n\n  /**\n   * @deprecated - This is a read only property\n   */\n  set encoding(_enc) {\n    throw new Error('Encoding must be set at instantiation time')\n  }\n\n  /**\n   * @deprecated - Encoding may only be set at instantiation time\n   */\n  setEncoding(_enc: Minipass.Encoding) {\n    throw new Error('Encoding must be set at instantiation time')\n  }\n\n  /**\n   * True if this is an objectMode stream\n   */\n  get objectMode() {\n    return this[OBJECTMODE]\n  }\n\n  /**\n   * @deprecated - This is a read-only property\n   */\n  set objectMode(_om) {\n    throw new Error('objectMode must be set at instantiation time')\n  }\n\n  /**\n   * true if this is an async stream\n   */\n  get ['async'](): boolean {\n    return this[ASYNC]\n  }\n  /**\n   * Set to true to make this stream async.\n   *\n   * Once set, it cannot be unset, as this would potentially cause incorrect\n   * behavior.  Ie, a sync stream can be made async, but an async stream\n   * cannot be safely made sync.\n   */\n  set ['async'](a: boolean) {\n    this[ASYNC] = this[ASYNC] || !!a\n  }\n\n  // drop everything and get out of the flow completely\n  [ABORT]() {\n    this[ABORTED] = true\n    this.emit('abort', this[SIGNAL]?.reason)\n    this.destroy(this[SIGNAL]?.reason)\n  }\n\n  /**\n   * True if the stream has been aborted.\n   */\n  get aborted() {\n    return this[ABORTED]\n  }\n  /**\n   * No-op setter. Stream aborted status is set via the AbortSignal provided\n   * in the constructor options.\n   */\n  set aborted(_) {}\n\n  /**\n   * Write data into the stream\n   *\n   * If the chunk written is a string, and encoding is not specified, then\n   * `utf8` will be assumed. If the stream encoding matches the encoding of\n   * a written string, and the state of the string decoder allows it, then\n   * the string will be passed through to either the output or the internal\n   * buffer without any processing. Otherwise, it will be turned into a\n   * Buffer object for processing into the desired encoding.\n   *\n   * If provided, `cb` function is called immediately before return for\n   * sync streams, or on next tick for async streams, because for this\n   * base class, a chunk is considered \"processed\" once it is accepted\n   * and either emitted or buffered. That is, the callback does not indicate\n   * that the chunk has been eventually emitted, though of course child\n   * classes can override this function to do whatever processing is required\n   * and call `super.write(...)` only once processing is completed.\n   */\n  write(chunk: WType, cb?: () => void): boolean\n  write(\n    chunk: WType,\n    encoding?: Minipass.Encoding,\n    cb?: () => void\n  ): boolean\n  write(\n    chunk: WType,\n    encoding?: Minipass.Encoding | (() => void),\n    cb?: () => void\n  ): boolean {\n    if (this[ABORTED]) return false\n    if (this[EOF]) throw new Error('write after end')\n\n    if (this[DESTROYED]) {\n      this.emit(\n        'error',\n        Object.assign(\n          new Error('Cannot call write after a stream was destroyed'),\n          { code: 'ERR_STREAM_DESTROYED' }\n        )\n      )\n      return true\n    }\n\n    if (typeof encoding === 'function') {\n      cb = encoding\n      encoding = 'utf8'\n    }\n\n    if (!encoding) encoding = 'utf8'\n\n    const fn = this[ASYNC] ? defer : nodefer\n\n    // convert array buffers and typed array views into buffers\n    // at some point in the future, we may want to do the opposite!\n    // leave strings and buffers as-is\n    // anything is only allowed if in object mode, so throw\n    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n      if (isArrayBufferView(chunk)) {\n        //@ts-ignore - sinful unsafe type changing\n        chunk = Buffer.from(\n          chunk.buffer,\n          chunk.byteOffset,\n          chunk.byteLength\n        )\n      } else if (isArrayBufferLike(chunk)) {\n        //@ts-ignore - sinful unsafe type changing\n        chunk = Buffer.from(chunk)\n      } else if (typeof chunk !== 'string') {\n        throw new Error(\n          'Non-contiguous data written to non-objectMode stream'\n        )\n      }\n    }\n\n    // handle object mode up front, since it's simpler\n    // this yields better performance, fewer checks later.\n    if (this[OBJECTMODE]) {\n      // maybe impossible?\n      /* c8 ignore start */\n      if (this[FLOWING] && this[BUFFERLENGTH] !== 0) this[FLUSH](true)\n      /* c8 ignore stop */\n\n      if (this[FLOWING]) this.emit('data', chunk as unknown as RType)\n      else this[BUFFERPUSH](chunk as unknown as RType)\n\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable')\n\n      if (cb) fn(cb)\n\n      return this[FLOWING]\n    }\n\n    // at this point the chunk is a buffer or string\n    // don't buffer it up or send it to the decoder\n    if (!(chunk as Minipass.BufferOrString).length) {\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable')\n      if (cb) fn(cb)\n      return this[FLOWING]\n    }\n\n    // fast-path writing strings of same encoding to a stream with\n    // an empty buffer, skipping the buffer/decoder dance\n    if (\n      typeof chunk === 'string' &&\n      // unless it is a string already ready for us to use\n      !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)\n    ) {\n      //@ts-ignore - sinful unsafe type change\n      chunk = Buffer.from(chunk, encoding)\n    }\n\n    if (Buffer.isBuffer(chunk) && this[ENCODING]) {\n      //@ts-ignore - sinful unsafe type change\n      chunk = this[DECODER].write(chunk)\n    }\n\n    // Note: flushing CAN potentially switch us into not-flowing mode\n    if (this[FLOWING] && this[BUFFERLENGTH] !== 0) this[FLUSH](true)\n\n    if (this[FLOWING]) this.emit('data', chunk as unknown as RType)\n    else this[BUFFERPUSH](chunk as unknown as RType)\n\n    if (this[BUFFERLENGTH] !== 0) this.emit('readable')\n\n    if (cb) fn(cb)\n\n    return this[FLOWING]\n  }\n\n  /**\n   * Low-level explicit read method.\n   *\n   * In objectMode, the argument is ignored, and one item is returned if\n   * available.\n   *\n   * `n` is the number of bytes (or in the case of encoding streams,\n   * characters) to consume. If `n` is not provided, then the entire buffer\n   * is returned, or `null` is returned if no data is available.\n   *\n   * If `n` is greater that the amount of data in the internal buffer,\n   * then `null` is returned.\n   */\n  read(n?: number | null): RType | null {\n    if (this[DESTROYED]) return null\n    this[DISCARDED] = false\n\n    if (\n      this[BUFFERLENGTH] === 0 ||\n      n === 0 ||\n      (n && n > this[BUFFERLENGTH])\n    ) {\n      this[MAYBE_EMIT_END]()\n      return null\n    }\n\n    if (this[OBJECTMODE]) n = null\n\n    if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {\n      // not object mode, so if we have an encoding, then RType is string\n      // otherwise, must be Buffer\n      this[BUFFER] = [\n        (this[ENCODING]\n          ? this[BUFFER].join('')\n          : Buffer.concat(\n              this[BUFFER] as Buffer[],\n              this[BUFFERLENGTH]\n            )) as RType,\n      ]\n    }\n\n    const ret = this[READ](n || null, this[BUFFER][0] as RType)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [READ](n: number | null, chunk: RType) {\n    if (this[OBJECTMODE]) this[BUFFERSHIFT]()\n    else {\n      const c = chunk as Minipass.BufferOrString\n      if (n === c.length || n === null) this[BUFFERSHIFT]()\n      else if (typeof c === 'string') {\n        this[BUFFER][0] = c.slice(n) as RType\n        chunk = c.slice(0, n) as RType\n        this[BUFFERLENGTH] -= n\n      } else {\n        this[BUFFER][0] = c.subarray(n) as RType\n        chunk = c.subarray(0, n) as RType\n        this[BUFFERLENGTH] -= n\n      }\n    }\n\n    this.emit('data', chunk)\n\n    if (!this[BUFFER].length && !this[EOF]) this.emit('drain')\n\n    return chunk\n  }\n\n  /**\n   * End the stream, optionally providing a final write.\n   *\n   * See {@link Minipass#write} for argument descriptions\n   */\n  end(cb?: () => void): this\n  end(chunk: WType, cb?: () => void): this\n  end(chunk: WType, encoding?: Minipass.Encoding, cb?: () => void): this\n  end(\n    chunk?: WType | (() => void),\n    encoding?: Minipass.Encoding | (() => void),\n    cb?: () => void\n  ) {\n    if (typeof chunk === 'function') {\n      cb = chunk as () => void\n      chunk = undefined\n    }\n    if (typeof encoding === 'function') {\n      cb = encoding\n      encoding = 'utf8'\n    }\n    if (chunk !== undefined) this.write(chunk, encoding)\n    if (cb) this.once('end', cb)\n    this[EOF] = true\n    this.writable = false\n\n    // if we haven't written anything, then go ahead and emit,\n    // even if we're not reading.\n    // we'll re-emit if a new 'end' listener is added anyway.\n    // This makes MP more suitable to write-only use cases.\n    if (this[FLOWING] || !this[PAUSED]) this[MAYBE_EMIT_END]()\n    return this\n  }\n\n  // don't let the internal resume be overwritten\n  [RESUME]() {\n    if (this[DESTROYED]) return\n\n    if (!this[DATALISTENERS] && !this[PIPES].length) {\n      this[DISCARDED] = true\n    }\n    this[PAUSED] = false\n    this[FLOWING] = true\n    this.emit('resume')\n    if (this[BUFFER].length) this[FLUSH]()\n    else if (this[EOF]) this[MAYBE_EMIT_END]()\n    else this.emit('drain')\n  }\n\n  /**\n   * Resume the stream if it is currently in a paused state\n   *\n   * If called when there are no pipe destinations or `data` event listeners,\n   * this will place the stream in a \"discarded\" state, where all data will\n   * be thrown away. The discarded state is removed if a pipe destination or\n   * data handler is added, if pause() is called, or if any synchronous or\n   * asynchronous iteration is started.\n   */\n  resume() {\n    return this[RESUME]()\n  }\n\n  /**\n   * Pause the stream\n   */\n  pause() {\n    this[FLOWING] = false\n    this[PAUSED] = true\n    this[DISCARDED] = false\n  }\n\n  /**\n   * true if the stream has been forcibly destroyed\n   */\n  get destroyed() {\n    return this[DESTROYED]\n  }\n\n  /**\n   * true if the stream is currently in a flowing state, meaning that\n   * any writes will be immediately emitted.\n   */\n  get flowing() {\n    return this[FLOWING]\n  }\n\n  /**\n   * true if the stream is currently in a paused state\n   */\n  get paused() {\n    return this[PAUSED]\n  }\n\n  [BUFFERPUSH](chunk: RType) {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1\n    else this[BUFFERLENGTH] += (chunk as Minipass.BufferOrString).length\n    this[BUFFER].push(chunk)\n  }\n\n  [BUFFERSHIFT](): RType {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1\n    else\n      this[BUFFERLENGTH] -= (\n        this[BUFFER][0] as Minipass.BufferOrString\n      ).length\n    return this[BUFFER].shift() as RType\n  }\n\n  [FLUSH](noDrain: boolean = false) {\n    do {} while (\n      this[FLUSHCHUNK](this[BUFFERSHIFT]()) &&\n      this[BUFFER].length\n    )\n\n    if (!noDrain && !this[BUFFER].length && !this[EOF]) this.emit('drain')\n  }\n\n  [FLUSHCHUNK](chunk: RType) {\n    this.emit('data', chunk)\n    return this[FLOWING]\n  }\n\n  /**\n   * Pipe all data emitted by this stream into the destination provided.\n   *\n   * Triggers the flow of data.\n   */\n  pipe<W extends Minipass.Writable>(dest: W, opts?: PipeOptions): W {\n    if (this[DESTROYED]) return dest\n    this[DISCARDED] = false\n\n    const ended = this[EMITTED_END]\n    opts = opts || {}\n    if (dest === proc.stdout || dest === proc.stderr) opts.end = false\n    else opts.end = opts.end !== false\n    opts.proxyErrors = !!opts.proxyErrors\n\n    // piping an ended stream ends immediately\n    if (ended) {\n      if (opts.end) dest.end()\n    } else {\n      // \"as\" here just ignores the WType, which pipes don't care about,\n      // since they're only consuming from us, and writing to the dest\n      this[PIPES].push(\n        !opts.proxyErrors\n          ? new Pipe<RType>(this as Minipass<RType>, dest, opts)\n          : new PipeProxyErrors<RType>(this as Minipass<RType>, dest, opts)\n      )\n      if (this[ASYNC]) defer(() => this[RESUME]())\n      else this[RESUME]()\n    }\n\n    return dest\n  }\n\n  /**\n   * Fully unhook a piped destination stream.\n   *\n   * If the destination stream was the only consumer of this stream (ie,\n   * there are no other piped destinations or `'data'` event listeners)\n   * then the flow of data will stop until there is another consumer or\n   * {@link Minipass#resume} is explicitly called.\n   */\n  unpipe<W extends Minipass.Writable>(dest: W) {\n    const p = this[PIPES].find(p => p.dest === dest)\n    if (p) {\n      if (this[PIPES].length === 1) {\n        if (this[FLOWING] && this[DATALISTENERS] === 0) {\n          this[FLOWING] = false\n        }\n        this[PIPES] = []\n      } else this[PIPES].splice(this[PIPES].indexOf(p), 1)\n      p.unpipe()\n    }\n  }\n\n  /**\n   * Alias for {@link Minipass#on}\n   */\n  addListener<Event extends keyof Events>(\n    ev: Event,\n    handler: (...args: Events[Event]) => any\n  ): this {\n    return this.on(ev, handler)\n  }\n\n  /**\n   * Mostly identical to `EventEmitter.on`, with the following\n   * behavior differences to prevent data loss and unnecessary hangs:\n   *\n   * - Adding a 'data' event handler will trigger the flow of data\n   *\n   * - Adding a 'readable' event handler when there is data waiting to be read\n   *   will cause 'readable' to be emitted immediately.\n   *\n   * - Adding an 'endish' event handler ('end', 'finish', etc.) which has\n   *   already passed will cause the event to be emitted immediately and all\n   *   handlers removed.\n   *\n   * - Adding an 'error' event handler after an error has been emitted will\n   *   cause the event to be re-emitted immediately with the error previously\n   *   raised.\n   */\n  on<Event extends keyof Events>(\n    ev: Event,\n    handler: (...args: Events[Event]) => any\n  ): this {\n    const ret = super.on(\n      ev as string | symbol,\n      handler as (...a: any[]) => any\n    )\n    if (ev === 'data') {\n      this[DISCARDED] = false\n      this[DATALISTENERS]++\n      if (!this[PIPES].length && !this[FLOWING]) {\n        this[RESUME]()\n      }\n    } else if (ev === 'readable' && this[BUFFERLENGTH] !== 0) {\n      super.emit('readable')\n    } else if (isEndish(ev) && this[EMITTED_END]) {\n      super.emit(ev)\n      this.removeAllListeners(ev)\n    } else if (ev === 'error' && this[EMITTED_ERROR]) {\n      const h = handler as (...a: Events['error']) => any\n      if (this[ASYNC]) defer(() => h.call(this, this[EMITTED_ERROR]))\n      else h.call(this, this[EMITTED_ERROR])\n    }\n    return ret\n  }\n\n  /**\n   * Alias for {@link Minipass#off}\n   */\n  removeListener<Event extends keyof Events>(\n    ev: Event,\n    handler: (...args: Events[Event]) => any\n  ) {\n    return this.off(ev, handler)\n  }\n\n  /**\n   * Mostly identical to `EventEmitter.off`\n   *\n   * If a 'data' event handler is removed, and it was the last consumer\n   * (ie, there are no pipe destinations or other 'data' event listeners),\n   * then the flow of data will stop until there is another consumer or\n   * {@link Minipass#resume} is explicitly called.\n   */\n  off<Event extends keyof Events>(\n    ev: Event,\n    handler: (...args: Events[Event]) => any\n  ) {\n    const ret = super.off(\n      ev as string | symbol,\n      handler as (...a: any[]) => any\n    )\n    // if we previously had listeners, and now we don't, and we don't\n    // have any pipes, then stop the flow, unless it's been explicitly\n    // put in a discarded flowing state via stream.resume().\n    if (ev === 'data') {\n      this[DATALISTENERS] = this.listeners('data').length\n      if (\n        this[DATALISTENERS] === 0 &&\n        !this[DISCARDED] &&\n        !this[PIPES].length\n      ) {\n        this[FLOWING] = false\n      }\n    }\n    return ret\n  }\n\n  /**\n   * Mostly identical to `EventEmitter.removeAllListeners`\n   *\n   * If all 'data' event handlers are removed, and they were the last consumer\n   * (ie, there are no pipe destinations), then the flow of data will stop\n   * until there is another consumer or {@link Minipass#resume} is explicitly\n   * called.\n   */\n  removeAllListeners<Event extends keyof Events>(ev?: Event) {\n    const ret = super.removeAllListeners(ev as string | symbol | undefined)\n    if (ev === 'data' || ev === undefined) {\n      this[DATALISTENERS] = 0\n      if (!this[DISCARDED] && !this[PIPES].length) {\n        this[FLOWING] = false\n      }\n    }\n    return ret\n  }\n\n  /**\n   * true if the 'end' event has been emitted\n   */\n  get emittedEnd() {\n    return this[EMITTED_END]\n  }\n\n  [MAYBE_EMIT_END]() {\n    if (\n      !this[EMITTING_END] &&\n      !this[EMITTED_END] &&\n      !this[DESTROYED] &&\n      this[BUFFER].length === 0 &&\n      this[EOF]\n    ) {\n      this[EMITTING_END] = true\n      this.emit('end')\n      this.emit('prefinish')\n      this.emit('finish')\n      if (this[CLOSED]) this.emit('close')\n      this[EMITTING_END] = false\n    }\n  }\n\n  /**\n   * Mostly identical to `EventEmitter.emit`, with the following\n   * behavior differences to prevent data loss and unnecessary hangs:\n   *\n   * If the stream has been destroyed, and the event is something other\n   * than 'close' or 'error', then `false` is returned and no handlers\n   * are called.\n   *\n   * If the event is 'end', and has already been emitted, then the event\n   * is ignored. If the stream is in a paused or non-flowing state, then\n   * the event will be deferred until data flow resumes. If the stream is\n   * async, then handlers will be called on the next tick rather than\n   * immediately.\n   *\n   * If the event is 'close', and 'end' has not yet been emitted, then\n   * the event will be deferred until after 'end' is emitted.\n   *\n   * If the event is 'error', and an AbortSignal was provided for the stream,\n   * and there are no listeners, then the event is ignored, matching the\n   * behavior of node core streams in the presense of an AbortSignal.\n   *\n   * If the event is 'finish' or 'prefinish', then all listeners will be\n   * removed after emitting the event, to prevent double-firing.\n   */\n  emit<Event extends keyof Events>(\n    ev: Event,\n    ...args: Events[Event]\n  ): boolean {\n    const data = args[0]\n    // error and close are only events allowed after calling destroy()\n    if (\n      ev !== 'error' &&\n      ev !== 'close' &&\n      ev !== DESTROYED &&\n      this[DESTROYED]\n    ) {\n      return false\n    } else if (ev === 'data') {\n      return !this[OBJECTMODE] && !data\n        ? false\n        : this[ASYNC]\n        ? (defer(() => this[EMITDATA](data as RType)), true)\n        : this[EMITDATA](data as RType)\n    } else if (ev === 'end') {\n      return this[EMITEND]()\n    } else if (ev === 'close') {\n      this[CLOSED] = true\n      // don't emit close before 'end' and 'finish'\n      if (!this[EMITTED_END] && !this[DESTROYED]) return false\n      const ret = super.emit('close')\n      this.removeAllListeners('close')\n      return ret\n    } else if (ev === 'error') {\n      this[EMITTED_ERROR] = data\n      super.emit(ERROR, data)\n      const ret =\n        !this[SIGNAL] || this.listeners('error').length\n          ? super.emit('error', data)\n          : false\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'resume') {\n      const ret = super.emit('resume')\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'finish' || ev === 'prefinish') {\n      const ret = super.emit(ev)\n      this.removeAllListeners(ev)\n      return ret\n    }\n\n    // Some other unknown event\n    const ret = super.emit(ev as string, ...args)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITDATA](data: RType) {\n    for (const p of this[PIPES]) {\n      if (p.dest.write(data) === false) this.pause()\n    }\n    const ret = this[DISCARDED] ? false : super.emit('data', data)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITEND]() {\n    if (this[EMITTED_END]) return false\n\n    this[EMITTED_END] = true\n    this.readable = false\n    return this[ASYNC]\n      ? (defer(() => this[EMITEND2]()), true)\n      : this[EMITEND2]()\n  }\n\n  [EMITEND2]() {\n    if (this[DECODER]) {\n      const data = this[DECODER].end()\n      if (data) {\n        for (const p of this[PIPES]) {\n          p.dest.write(data as RType)\n        }\n        if (!this[DISCARDED]) super.emit('data', data)\n      }\n    }\n\n    for (const p of this[PIPES]) {\n      p.end()\n    }\n    const ret = super.emit('end')\n    this.removeAllListeners('end')\n    return ret\n  }\n\n  /**\n   * Return a Promise that resolves to an array of all emitted data once\n   * the stream ends.\n   */\n  async collect(): Promise<RType[] & { dataLength: number }> {\n    const buf: RType[] & { dataLength: number } = Object.assign([], {\n      dataLength: 0,\n    })\n    if (!this[OBJECTMODE]) buf.dataLength = 0\n    // set the promise first, in case an error is raised\n    // by triggering the flow here.\n    const p = this.promise()\n    this.on('data', c => {\n      buf.push(c)\n      if (!this[OBJECTMODE])\n        buf.dataLength += (c as Minipass.BufferOrString).length\n    })\n    await p\n    return buf\n  }\n\n  /**\n   * Return a Promise that resolves to the concatenation of all emitted data\n   * once the stream ends.\n   *\n   * Not allowed on objectMode streams.\n   */\n  async concat(): Promise<RType> {\n    if (this[OBJECTMODE]) {\n      throw new Error('cannot concat in objectMode')\n    }\n    const buf = await this.collect()\n    return (\n      this[ENCODING]\n        ? buf.join('')\n        : Buffer.concat(buf as Buffer[], buf.dataLength)\n    ) as RType\n  }\n\n  /**\n   * Return a void Promise that resolves once the stream ends.\n   */\n  async promise(): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      this.on(DESTROYED, () => reject(new Error('stream destroyed')))\n      this.on('error', er => reject(er))\n      this.on('end', () => resolve())\n    })\n  }\n\n  /**\n   * Asynchronous `for await of` iteration.\n   *\n   * This will continue emitting all chunks until the stream terminates.\n   */\n  [Symbol.asyncIterator](): AsyncGenerator<RType, void, void> {\n    // set this up front, in case the consumer doesn't call next()\n    // right away.\n    this[DISCARDED] = false\n    let stopped = false\n    const stop = async (): Promise<IteratorReturnResult<void>> => {\n      this.pause()\n      stopped = true\n      return { value: undefined, done: true }\n    }\n    const next = (): Promise<IteratorResult<RType, void>> => {\n      if (stopped) return stop()\n      const res = this.read()\n      if (res !== null) return Promise.resolve({ done: false, value: res })\n\n      if (this[EOF]) return stop()\n\n      let resolve!: (res: IteratorResult<RType>) => void\n      let reject!: (er: unknown) => void\n      const onerr = (er: unknown) => {\n        this.off('data', ondata)\n        this.off('end', onend)\n        this.off(DESTROYED, ondestroy)\n        stop()\n        reject(er)\n      }\n      const ondata = (value: RType) => {\n        this.off('error', onerr)\n        this.off('end', onend)\n        this.off(DESTROYED, ondestroy)\n        this.pause()\n        resolve({ value, done: !!this[EOF] })\n      }\n      const onend = () => {\n        this.off('error', onerr)\n        this.off('data', ondata)\n        this.off(DESTROYED, ondestroy)\n        stop()\n        resolve({ done: true, value: undefined })\n      }\n      const ondestroy = () => onerr(new Error('stream destroyed'))\n      return new Promise<IteratorResult<RType>>((res, rej) => {\n        reject = rej\n        resolve = res\n        this.once(DESTROYED, ondestroy)\n        this.once('error', onerr)\n        this.once('end', onend)\n        this.once('data', ondata)\n      })\n    }\n\n    return {\n      next,\n      throw: stop,\n      return: stop,\n      [Symbol.asyncIterator]() {\n        return this\n      },\n    }\n  }\n\n  /**\n   * Synchronous `for of` iteration.\n   *\n   * The iteration will terminate when the internal buffer runs out, even\n   * if the stream has not yet terminated.\n   */\n  [Symbol.iterator](): Generator<RType, void, void> {\n    // set this up front, in case the consumer doesn't call next()\n    // right away.\n    this[DISCARDED] = false\n    let stopped = false\n    const stop = (): IteratorReturnResult<void> => {\n      this.pause()\n      this.off(ERROR, stop)\n      this.off(DESTROYED, stop)\n      this.off('end', stop)\n      stopped = true\n      return { done: true, value: undefined }\n    }\n\n    const next = (): IteratorResult<RType, void> => {\n      if (stopped) return stop()\n      const value = this.read()\n      return value === null ? stop() : { done: false, value }\n    }\n\n    this.once('end', stop)\n    this.once(ERROR, stop)\n    this.once(DESTROYED, stop)\n\n    return {\n      next,\n      throw: stop,\n      return: stop,\n      [Symbol.iterator]() {\n        return this\n      },\n    }\n  }\n\n  /**\n   * Destroy a stream, preventing it from being used for any further purpose.\n   *\n   * If the stream has a `close()` method, then it will be called on\n   * destruction.\n   *\n   * After destruction, any attempt to write data, read data, or emit most\n   * events will be ignored.\n   *\n   * If an error argument is provided, then it will be emitted in an\n   * 'error' event.\n   */\n  destroy(er?: unknown) {\n    if (this[DESTROYED]) {\n      if (er) this.emit('error', er)\n      else this.emit(DESTROYED)\n      return this\n    }\n\n    this[DESTROYED] = true\n    this[DISCARDED] = true\n\n    // throw away all buffered data, it's never coming out\n    this[BUFFER].length = 0\n    this[BUFFERLENGTH] = 0\n\n    const wc = this as Minipass<RType, WType, Events> & {\n      close?: () => void\n    }\n    if (typeof wc.close === 'function' && !this[CLOSED]) wc.close()\n\n    if (er) this.emit('error', er)\n    // if no error to emit, still reject pending promises\n    else this.emit(DESTROYED)\n\n    return this\n  }\n\n  /**\n   * Alias for {@link isStream}\n   *\n   * Former export location, maintained for backwards compatibility.\n   *\n   * @deprecated\n   */\n  static get isStream() {\n    return isStream\n  }\n}\n", "import { Minimatch, MinimatchOptions } from 'minimatch'\nimport { Minipass } from 'minipass'\nimport {\n  FSOption,\n  Path,\n  PathScurry,\n  PathScurryDarwin,\n  PathScurryPosix,\n  PathScurryWin32,\n} from 'path-scurry'\nimport { fileURLToPath } from 'url'\nimport { IgnoreLike } from './ignore.js'\nimport { Pattern } from './pattern.js'\nimport { GlobStream, GlobWalker } from './walker.js'\n\nexport type MatchSet = Minimatch['set']\nexport type GlobParts = Exclude<Minimatch['globParts'], undefined>\n\n// if no process global, just call it linux.\n// so we default to case-sensitive, / separators\nconst defaultPlatform: NodeJS.Platform =\n  typeof process === 'object' &&\n  process &&\n  typeof process.platform === 'string'\n    ? process.platform\n    : 'linux'\n\n/**\n * A `GlobOptions` object may be provided to any of the exported methods, and\n * must be provided to the `Glob` constructor.\n *\n * All options are optional, boolean, and false by default, unless otherwise\n * noted.\n *\n * All resolved options are added to the Glob object as properties.\n *\n * If you are running many `glob` operations, you can pass a Glob object as the\n * `options` argument to a subsequent operation to share the previously loaded\n * cache.\n */\nexport interface GlobOptions {\n  /**\n   * Set to `true` to always receive absolute paths for\n   * matched files. Set to `false` to always return relative paths.\n   *\n   * When this option is not set, absolute paths are returned for patterns\n   * that are absolute, and otherwise paths are returned that are relative\n   * to the `cwd` setting.\n   *\n   * This does _not_ make an extra system call to get\n   * the realpath, it only does string path resolution.\n   *\n   * Conflicts with {@link withFileTypes}\n   */\n  absolute?: boolean\n\n  /**\n   * Set to false to enable {@link windowsPathsNoEscape}\n   *\n   * @deprecated\n   */\n  allowWindowsEscape?: boolean\n\n  /**\n   * The current working directory in which to search. Defaults to\n   * `process.cwd()`.\n   *\n   * May be eiher a string path or a `file://` URL object or string.\n   */\n  cwd?: string | URL\n\n  /**\n   * Include `.dot` files in normal matches and `globstar`\n   * matches. Note that an explicit dot in a portion of the pattern\n   * will always match dot files.\n   */\n  dot?: boolean\n\n  /**\n   * Prepend all relative path strings with `./` (or `.\\` on Windows).\n   *\n   * Without this option, returned relative paths are \"bare\", so instead of\n   * returning `'./foo/bar'`, they are returned as `'foo/bar'`.\n   *\n   * Relative patterns starting with `'../'` are not prepended with `./`, even\n   * if this option is set.\n   */\n  dotRelative?: boolean\n\n  /**\n   * Follow symlinked directories when expanding `**`\n   * patterns. This can result in a lot of duplicate references in\n   * the presence of cyclic links, and make performance quite bad.\n   *\n   * By default, a `**` in a pattern will follow 1 symbolic link if\n   * it is not the first item in the pattern, or none if it is the\n   * first item in the pattern, following the same behavior as Bash.\n   */\n  follow?: boolean\n\n  /**\n   * string or string[], or an object with `ignore` and `ignoreChildren`\n   * methods.\n   *\n   * If a string or string[] is provided, then this is treated as a glob\n   * pattern or array of glob patterns to exclude from matches. To ignore all\n   * children within a directory, as well as the entry itself, append `'/**'`\n   * to the ignore pattern.\n   *\n   * **Note** `ignore` patterns are _always_ in `dot:true` mode, regardless of\n   * any other settings.\n   *\n   * If an object is provided that has `ignored(path)` and/or\n   * `childrenIgnored(path)` methods, then these methods will be called to\n   * determine whether any Path is a match or if its children should be\n   * traversed, respectively.\n   */\n  ignore?: string | string[] | IgnoreLike\n\n  /**\n   * Treat brace expansion like `{a,b}` as a \"magic\" pattern. Has no\n   * effect if {@link nobrace} is set.\n   *\n   * Only has effect on the {@link hasMagic} function.\n   */\n  magicalBraces?: boolean\n\n  /**\n   * Add a `/` character to directory matches. Note that this requires\n   * additional stat calls in some cases.\n   */\n  mark?: boolean\n\n  /**\n   * Perform a basename-only match if the pattern does not contain any slash\n   * characters. That is, `*.js` would be treated as equivalent to\n   * `**\\/*.js`, matching all js files in all directories.\n   */\n  matchBase?: boolean\n\n  /**\n   * Limit the directory traversal to a given depth below the cwd.\n   * Note that this does NOT prevent traversal to sibling folders,\n   * root patterns, and so on. It only limits the maximum folder depth\n   * that the walk will descend, relative to the cwd.\n   */\n  maxDepth?: number\n\n  /**\n   * Do not expand `{a,b}` and `{1..3}` brace sets.\n   */\n  nobrace?: boolean\n\n  /**\n   * Perform a case-insensitive match. This defaults to `true` on macOS and\n   * Windows systems, and `false` on all others.\n   *\n   * **Note** `nocase` should only be explicitly set when it is\n   * known that the filesystem's case sensitivity differs from the\n   * platform default. If set `true` on case-sensitive file\n   * systems, or `false` on case-insensitive file systems, then the\n   * walk may return more or less results than expected.\n   */\n  nocase?: boolean\n\n  /**\n   * Do not match directories, only files. (Note: to match\n   * _only_ directories, put a `/` at the end of the pattern.)\n   */\n  nodir?: boolean\n\n  /**\n   * Do not match \"extglob\" patterns such as `+(a|b)`.\n   */\n  noext?: boolean\n\n  /**\n   * Do not match `**` against multiple filenames. (Ie, treat it as a normal\n   * `*` instead.)\n   *\n   * Conflicts with {@link matchBase}\n   */\n  noglobstar?: boolean\n\n  /**\n   * Defaults to value of `process.platform` if available, or `'linux'` if\n   * not. Setting `platform:'win32'` on non-Windows systems may cause strange\n   * behavior.\n   */\n  platform?: NodeJS.Platform\n\n  /**\n   * Set to true to call `fs.realpath` on all of the\n   * results. In the case of an entry that cannot be resolved, the\n   * entry is omitted. This incurs a slight performance penalty, of\n   * course, because of the added system calls.\n   */\n  realpath?: boolean\n\n  /**\n   *\n   * A string path resolved against the `cwd` option, which\n   * is used as the starting point for absolute patterns that start\n   * with `/`, (but not drive letters or UNC paths on Windows).\n   *\n   * Note that this _doesn't_ necessarily limit the walk to the\n   * `root` directory, and doesn't affect the cwd starting point for\n   * non-absolute patterns. A pattern containing `..` will still be\n   * able to traverse out of the root directory, if it is not an\n   * actual root directory on the filesystem, and any non-absolute\n   * patterns will be matched in the `cwd`. For example, the\n   * pattern `/../*` with `{root:'/some/path'}` will return all\n   * files in `/some`, not all files in `/some/path`. The pattern\n   * `*` with `{root:'/some/path'}` will return all the entries in\n   * the cwd, not the entries in `/some/path`.\n   *\n   * To start absolute and non-absolute patterns in the same\n   * path, you can use `{root:''}`. However, be aware that on\n   * Windows systems, a pattern like `x:/*` or `//host/share/*` will\n   * _always_ start in the `x:/` or `//host/share` directory,\n   * regardless of the `root` setting.\n   */\n  root?: string\n\n  /**\n   * A [PathScurry](http://npm.im/path-scurry) object used\n   * to traverse the file system. If the `nocase` option is set\n   * explicitly, then any provided `scurry` object must match this\n   * setting.\n   */\n  scurry?: PathScurry\n\n  /**\n   * Call `lstat()` on all entries, whether required or not to determine\n   * if it's a valid match. When used with {@link withFileTypes}, this means\n   * that matches will include data such as modified time, permissions, and\n   * so on.  Note that this will incur a performance cost due to the added\n   * system calls.\n   */\n  stat?: boolean\n\n  /**\n   * An AbortSignal which will cancel the Glob walk when\n   * triggered.\n   */\n  signal?: AbortSignal\n\n  /**\n   * Use `\\\\` as a path separator _only_, and\n   *  _never_ as an escape character. If set, all `\\\\` characters are\n   *  replaced with `/` in the pattern.\n   *\n   *  Note that this makes it **impossible** to match against paths\n   *  containing literal glob pattern characters, but allows matching\n   *  with patterns constructed using `path.join()` and\n   *  `path.resolve()` on Windows platforms, mimicking the (buggy!)\n   *  behavior of Glob v7 and before on Windows. Please use with\n   *  caution, and be mindful of [the caveat below about Windows\n   *  paths](#windows). (For legacy reasons, this is also set if\n   *  `allowWindowsEscape` is set to the exact value `false`.)\n   */\n  windowsPathsNoEscape?: boolean\n\n  /**\n   * Return [PathScurry](http://npm.im/path-scurry)\n   * `Path` objects instead of strings. These are similar to a\n   * NodeJS `Dirent` object, but with additional methods and\n   * properties.\n   *\n   * Conflicts with {@link absolute}\n   */\n  withFileTypes?: boolean\n\n  /**\n   * An fs implementation to override some or all of the defaults.  See\n   * http://npm.im/path-scurry for details about what can be overridden.\n   */\n  fs?: FSOption\n\n  /**\n   * Just passed along to Minimatch.  Note that this makes all pattern\n   * matching operations slower and *extremely* noisy.\n   */\n  debug?: boolean\n\n  /**\n   * Return `/` delimited paths, even on Windows.\n   *\n   * On posix systems, this has no effect.  But, on Windows, it means that\n   * paths will be `/` delimited, and absolute paths will be their full\n   * resolved UNC forms, eg instead of `'C:\\\\foo\\\\bar'`, it would return\n   * `'//?/C:/foo/bar'`\n   */\n  posix?: boolean\n}\n\nexport type GlobOptionsWithFileTypesTrue = GlobOptions & {\n  withFileTypes: true\n  // string options not relevant if returning Path objects.\n  absolute?: undefined\n  mark?: undefined\n  posix?: undefined\n}\n\nexport type GlobOptionsWithFileTypesFalse = GlobOptions & {\n  withFileTypes?: false\n}\n\nexport type GlobOptionsWithFileTypesUnset = GlobOptions & {\n  withFileTypes?: undefined\n}\n\nexport type Result<Opts> = Opts extends GlobOptionsWithFileTypesTrue\n  ? Path\n  : Opts extends GlobOptionsWithFileTypesFalse\n  ? string\n  : Opts extends GlobOptionsWithFileTypesUnset\n  ? string\n  : string | Path\nexport type Results<Opts> = Result<Opts>[]\n\nexport type FileTypes<Opts> = Opts extends GlobOptionsWithFileTypesTrue\n  ? true\n  : Opts extends GlobOptionsWithFileTypesFalse\n  ? false\n  : Opts extends GlobOptionsWithFileTypesUnset\n  ? false\n  : boolean\n\n/**\n * An object that can perform glob pattern traversals.\n */\nexport class Glob<Opts extends GlobOptions> implements GlobOptions {\n  absolute?: boolean\n  cwd: string\n  root?: string\n  dot: boolean\n  dotRelative: boolean\n  follow: boolean\n  ignore?: string | string[] | IgnoreLike\n  magicalBraces: boolean\n  mark?: boolean\n  matchBase: boolean\n  maxDepth: number\n  nobrace: boolean\n  nocase: boolean\n  nodir: boolean\n  noext: boolean\n  noglobstar: boolean\n  pattern: string[]\n  platform: NodeJS.Platform\n  realpath: boolean\n  scurry: PathScurry\n  stat: boolean\n  signal?: AbortSignal\n  windowsPathsNoEscape: boolean\n  withFileTypes: FileTypes<Opts>\n\n  /**\n   * The options provided to the constructor.\n   */\n  opts: Opts\n\n  /**\n   * An array of parsed immutable {@link Pattern} objects.\n   */\n  patterns: Pattern[]\n\n  /**\n   * All options are stored as properties on the `Glob` object.\n   *\n   * See {@link GlobOptions} for full options descriptions.\n   *\n   * Note that a previous `Glob` object can be passed as the\n   * `GlobOptions` to another `Glob` instantiation to re-use settings\n   * and caches with a new pattern.\n   *\n   * Traversal functions can be called multiple times to run the walk\n   * again.\n   */\n  constructor(pattern: string | string[], opts: Opts) {\n    /* c8 ignore start */\n    if (!opts) throw new TypeError('glob options required')\n    /* c8 ignore stop */\n    this.withFileTypes = !!opts.withFileTypes as FileTypes<Opts>\n    this.signal = opts.signal\n    this.follow = !!opts.follow\n    this.dot = !!opts.dot\n    this.dotRelative = !!opts.dotRelative\n    this.nodir = !!opts.nodir\n    this.mark = !!opts.mark\n    if (!opts.cwd) {\n      this.cwd = ''\n    } else if (opts.cwd instanceof URL || opts.cwd.startsWith('file://')) {\n      opts.cwd = fileURLToPath(opts.cwd)\n    }\n    this.cwd = opts.cwd || ''\n    this.root = opts.root\n    this.magicalBraces = !!opts.magicalBraces\n    this.nobrace = !!opts.nobrace\n    this.noext = !!opts.noext\n    this.realpath = !!opts.realpath\n    this.absolute = opts.absolute\n\n    this.noglobstar = !!opts.noglobstar\n    this.matchBase = !!opts.matchBase\n    this.maxDepth =\n      typeof opts.maxDepth === 'number' ? opts.maxDepth : Infinity\n    this.stat = !!opts.stat\n    this.ignore = opts.ignore\n\n    if (this.withFileTypes && this.absolute !== undefined) {\n      throw new Error('cannot set absolute and withFileTypes:true')\n    }\n\n    if (typeof pattern === 'string') {\n      pattern = [pattern]\n    }\n\n    this.windowsPathsNoEscape =\n      !!opts.windowsPathsNoEscape ||\n      (opts as GlobOptions).allowWindowsEscape === false\n\n    if (this.windowsPathsNoEscape) {\n      pattern = pattern.map(p => p.replace(/\\\\/g, '/'))\n    }\n\n    if (this.matchBase) {\n      if (opts.noglobstar) {\n        throw new TypeError('base matching requires globstar')\n      }\n      pattern = pattern.map(p => (p.includes('/') ? p : `./**/${p}`))\n    }\n\n    this.pattern = pattern\n\n    this.platform = opts.platform || defaultPlatform\n    this.opts = { ...opts, platform: this.platform }\n    if (opts.scurry) {\n      this.scurry = opts.scurry\n      if (\n        opts.nocase !== undefined &&\n        opts.nocase !== opts.scurry.nocase\n      ) {\n        throw new Error('nocase option contradicts provided scurry option')\n      }\n    } else {\n      const Scurry =\n        opts.platform === 'win32'\n          ? PathScurryWin32\n          : opts.platform === 'darwin'\n          ? PathScurryDarwin\n          : opts.platform\n          ? PathScurryPosix\n          : PathScurry\n      this.scurry = new Scurry(this.cwd, {\n        nocase: opts.nocase,\n        fs: opts.fs,\n      })\n    }\n    this.nocase = this.scurry.nocase\n\n    // If you do nocase:true on a case-sensitive file system, then\n    // we need to use regexps instead of strings for non-magic\n    // path portions, because statting `aBc` won't return results\n    // for the file `AbC` for example.\n    const nocaseMagicOnly =\n      this.platform === 'darwin' || this.platform === 'win32'\n\n    const mmo: MinimatchOptions = {\n      // default nocase based on platform\n      ...opts,\n      dot: this.dot,\n      matchBase: this.matchBase,\n      nobrace: this.nobrace,\n      nocase: this.nocase,\n      nocaseMagicOnly,\n      nocomment: true,\n      noext: this.noext,\n      nonegate: true,\n      optimizationLevel: 2,\n      platform: this.platform,\n      windowsPathsNoEscape: this.windowsPathsNoEscape,\n      debug: !!this.opts.debug,\n    }\n\n    const mms = this.pattern.map(p => new Minimatch(p, mmo))\n    const [matchSet, globParts] = mms.reduce(\n      (set: [MatchSet, GlobParts], m) => {\n        set[0].push(...m.set)\n        set[1].push(...m.globParts)\n        return set\n      },\n      [[], []]\n    )\n    this.patterns = matchSet.map((set, i) => {\n      const g = globParts[i]\n      /* c8 ignore start */\n      if (!g) throw new Error('invalid pattern object')\n      /* c8 ignore stop */\n      return new Pattern(set, g, 0, this.platform)\n    })\n  }\n\n  /**\n   * Returns a Promise that resolves to the results array.\n   */\n  async walk(): Promise<Results<Opts>>\n  async walk(): Promise<(string | Path)[]> {\n    // Walkers always return array of Path objects, so we just have to\n    // coerce them into the right shape.  It will have already called\n    // realpath() if the option was set to do so, so we know that's cached.\n    // start out knowing the cwd, at least\n    return [\n      ...(await new GlobWalker(this.patterns, this.scurry.cwd, {\n        ...this.opts,\n        maxDepth:\n          this.maxDepth !== Infinity\n            ? this.maxDepth + this.scurry.cwd.depth()\n            : Infinity,\n        platform: this.platform,\n        nocase: this.nocase,\n      }).walk()),\n    ]\n  }\n\n  /**\n   * synchronous {@link Glob.walk}\n   */\n  walkSync(): Results<Opts>\n  walkSync(): (string | Path)[] {\n    return [\n      ...new GlobWalker(this.patterns, this.scurry.cwd, {\n        ...this.opts,\n        maxDepth:\n          this.maxDepth !== Infinity\n            ? this.maxDepth + this.scurry.cwd.depth()\n            : Infinity,\n        platform: this.platform,\n        nocase: this.nocase,\n      }).walkSync(),\n    ]\n  }\n\n  /**\n   * Stream results asynchronously.\n   */\n  stream(): Minipass<Result<Opts>, Result<Opts>>\n  stream(): Minipass<string | Path, string | Path> {\n    return new GlobStream(this.patterns, this.scurry.cwd, {\n      ...this.opts,\n      maxDepth:\n        this.maxDepth !== Infinity\n          ? this.maxDepth + this.scurry.cwd.depth()\n          : Infinity,\n      platform: this.platform,\n      nocase: this.nocase,\n    }).stream()\n  }\n\n  /**\n   * Stream results synchronously.\n   */\n  streamSync(): Minipass<Result<Opts>, Result<Opts>>\n  streamSync(): Minipass<string | Path, string | Path> {\n    return new GlobStream(this.patterns, this.scurry.cwd, {\n      ...this.opts,\n      maxDepth:\n        this.maxDepth !== Infinity\n          ? this.maxDepth + this.scurry.cwd.depth()\n          : Infinity,\n      platform: this.platform,\n      nocase: this.nocase,\n    }).streamSync()\n  }\n\n  /**\n   * Default sync iteration function. Returns a Generator that\n   * iterates over the results.\n   */\n  iterateSync(): Generator<Result<Opts>, void, void> {\n    return this.streamSync()[Symbol.iterator]()\n  }\n  [Symbol.iterator]() {\n    return this.iterateSync()\n  }\n\n  /**\n   * Default async iteration function. Returns an AsyncGenerator that\n   * iterates over the results.\n   */\n  iterate(): AsyncGenerator<Result<Opts>, void, void> {\n    return this.stream()[Symbol.asyncIterator]()\n  }\n  [Symbol.asyncIterator]() {\n    return this.iterate()\n  }\n}\n", "// this is just a very light wrapper around 2 arrays with an offset index\n\nimport { GLOBSTAR } from 'minimatch'\nexport type MMPattern = string | RegExp | typeof GLOBSTAR\n\n// an array of length >= 1\nexport type PatternList = [p: MMPattern, ...rest: MMPattern[]]\nexport type UNCPatternList = [\n  p0: '',\n  p1: '',\n  p2: string,\n  p3: string,\n  ...rest: MMPattern[]\n]\nexport type DrivePatternList = [p0: string, ...rest: MMPattern[]]\nexport type AbsolutePatternList = [p0: '', ...rest: MMPattern[]]\nexport type GlobList = [p: string, ...rest: string[]]\n\nconst isPatternList = (pl: MMPattern[]): pl is PatternList =>\n  pl.length >= 1\nconst isGlobList = (gl: string[]): gl is GlobList => gl.length >= 1\n\n/**\n * An immutable-ish view on an array of glob parts and their parsed\n * results\n */\nexport class Pattern {\n  readonly #patternList: PatternList\n  readonly #globList: GlobList\n  readonly #index: number\n  readonly length: number\n  readonly #platform: NodeJS.Platform\n  #rest?: Pattern | null\n  #globString?: string\n  #isDrive?: boolean\n  #isUNC?: boolean\n  #isAbsolute?: boolean\n  #followGlobstar: boolean = true\n\n  constructor(\n    patternList: MMPattern[],\n    globList: string[],\n    index: number,\n    platform: NodeJS.Platform\n  ) {\n    if (!isPatternList(patternList)) {\n      throw new TypeError('empty pattern list')\n    }\n    if (!isGlobList(globList)) {\n      throw new TypeError('empty glob list')\n    }\n    if (globList.length !== patternList.length) {\n      throw new TypeError('mismatched pattern list and glob list lengths')\n    }\n    this.length = patternList.length\n    if (index < 0 || index >= this.length) {\n      throw new TypeError('index out of range')\n    }\n    this.#patternList = patternList\n    this.#globList = globList\n    this.#index = index\n    this.#platform = platform\n\n    // normalize root entries of absolute patterns on initial creation.\n    if (this.#index === 0) {\n      // c: => ['c:/']\n      // C:/ => ['C:/']\n      // C:/x => ['C:/', 'x']\n      // //host/share => ['//host/share/']\n      // //host/share/ => ['//host/share/']\n      // //host/share/x => ['//host/share/', 'x']\n      // /etc => ['/', 'etc']\n      // / => ['/']\n      if (this.isUNC()) {\n        // '' / '' / 'host' / 'share'\n        const [p0, p1, p2, p3, ...prest] = this.#patternList\n        const [g0, g1, g2, g3, ...grest] = this.#globList\n        if (prest[0] === '') {\n          // ends in /\n          prest.shift()\n          grest.shift()\n        }\n        const p = [p0, p1, p2, p3, ''].join('/')\n        const g = [g0, g1, g2, g3, ''].join('/')\n        this.#patternList = [p, ...prest]\n        this.#globList = [g, ...grest]\n        this.length = this.#patternList.length\n      } else if (this.isDrive() || this.isAbsolute()) {\n        const [p1, ...prest] = this.#patternList\n        const [g1, ...grest] = this.#globList\n        if (prest[0] === '') {\n          // ends in /\n          prest.shift()\n          grest.shift()\n        }\n        const p = (p1 as string) + '/'\n        const g = g1 + '/'\n        this.#patternList = [p, ...prest]\n        this.#globList = [g, ...grest]\n        this.length = this.#patternList.length\n      }\n    }\n  }\n\n  /**\n   * The first entry in the parsed list of patterns\n   */\n  pattern(): MMPattern {\n    return this.#patternList[this.#index] as MMPattern\n  }\n\n  /**\n   * true of if pattern() returns a string\n   */\n  isString(): boolean {\n    return typeof this.#patternList[this.#index] === 'string'\n  }\n  /**\n   * true of if pattern() returns GLOBSTAR\n   */\n  isGlobstar(): boolean {\n    return this.#patternList[this.#index] === GLOBSTAR\n  }\n  /**\n   * true if pattern() returns a regexp\n   */\n  isRegExp(): boolean {\n    return this.#patternList[this.#index] instanceof RegExp\n  }\n\n  /**\n   * The /-joined set of glob parts that make up this pattern\n   */\n  globString(): string {\n    return (this.#globString =\n      this.#globString ||\n      (this.#index === 0\n        ? this.isAbsolute()\n          ? this.#globList[0] + this.#globList.slice(1).join('/')\n          : this.#globList.join('/')\n        : this.#globList.slice(this.#index).join('/')))\n  }\n\n  /**\n   * true if there are more pattern parts after this one\n   */\n  hasMore(): boolean {\n    return this.length > this.#index + 1\n  }\n\n  /**\n   * The rest of the pattern after this part, or null if this is the end\n   */\n  rest(): Pattern | null {\n    if (this.#rest !== undefined) return this.#rest\n    if (!this.hasMore()) return (this.#rest = null)\n    this.#rest = new Pattern(\n      this.#patternList,\n      this.#globList,\n      this.#index + 1,\n      this.#platform\n    )\n    this.#rest.#isAbsolute = this.#isAbsolute\n    this.#rest.#isUNC = this.#isUNC\n    this.#rest.#isDrive = this.#isDrive\n    return this.#rest\n  }\n\n  /**\n   * true if the pattern represents a //unc/path/ on windows\n   */\n  isUNC(): boolean {\n    const pl = this.#patternList\n    return this.#isUNC !== undefined\n      ? this.#isUNC\n      : (this.#isUNC =\n          this.#platform === 'win32' &&\n          this.#index === 0 &&\n          pl[0] === '' &&\n          pl[1] === '' &&\n          typeof pl[2] === 'string' &&\n          !!pl[2] &&\n          typeof pl[3] === 'string' &&\n          !!pl[3])\n  }\n\n  // pattern like C:/...\n  // split = ['C:', ...]\n  // XXX: would be nice to handle patterns like `c:*` to test the cwd\n  // in c: for *, but I don't know of a way to even figure out what that\n  // cwd is without actually chdir'ing into it?\n  /**\n   * True if the pattern starts with a drive letter on Windows\n   */\n  isDrive(): boolean {\n    const pl = this.#patternList\n    return this.#isDrive !== undefined\n      ? this.#isDrive\n      : (this.#isDrive =\n          this.#platform === 'win32' &&\n          this.#index === 0 &&\n          this.length > 1 &&\n          typeof pl[0] === 'string' &&\n          /^[a-z]:$/i.test(pl[0]))\n  }\n\n  // pattern = '/' or '/...' or '/x/...'\n  // split = ['', ''] or ['', ...] or ['', 'x', ...]\n  // Drive and UNC both considered absolute on windows\n  /**\n   * True if the pattern is rooted on an absolute path\n   */\n  isAbsolute(): boolean {\n    const pl = this.#patternList\n    return this.#isAbsolute !== undefined\n      ? this.#isAbsolute\n      : (this.#isAbsolute =\n          (pl[0] === '' && pl.length > 1) ||\n          this.isDrive() ||\n          this.isUNC())\n  }\n\n  /**\n   * consume the root of the pattern, and return it\n   */\n  root(): string {\n    const p = this.#patternList[0]\n    return typeof p === 'string' && this.isAbsolute() && this.#index === 0\n      ? p\n      : ''\n  }\n\n  /**\n   * Check to see if the current globstar pattern is allowed to follow\n   * a symbolic link.\n   */\n  checkFollowGlobstar(): boolean {\n    return !(\n      this.#index === 0 ||\n      !this.isGlobstar() ||\n      !this.#followGlobstar\n    )\n  }\n\n  /**\n   * Mark that the current globstar pattern is following a symbolic link\n   */\n  markFollowGlobstar(): boolean {\n    if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar)\n      return false\n    this.#followGlobstar = false\n    return true\n  }\n}\n", "// give it a pattern, and it'll be able to tell you if\n// a given path should be ignored.\n// Ignoring a path ignores its children if the pattern ends in /**\n// Ignores are always parsed in dot:true mode\n\nimport { Minimatch } from 'minimatch'\nimport { Path } from 'path-scurry'\nimport { Pattern } from './pattern.js'\nimport { GlobWalkerOpts } from './walker.js'\n\nexport interface IgnoreLike {\n  ignored?: (p: Path) => boolean\n  childrenIgnored?: (p: Path) => boolean\n}\n\nconst defaultPlatform: NodeJS.Platform =\n  typeof process === 'object' &&\n  process &&\n  typeof process.platform === 'string'\n    ? process.platform\n    : 'linux'\n\n/**\n * Class used to process ignored patterns\n */\nexport class Ignore implements IgnoreLike {\n  relative: Minimatch[]\n  relativeChildren: Minimatch[]\n  absolute: Minimatch[]\n  absoluteChildren: Minimatch[]\n\n  constructor(\n    ignored: string[],\n    {\n      nobrace,\n      nocase,\n      noext,\n      noglobstar,\n      platform = defaultPlatform,\n    }: GlobWalkerOpts\n  ) {\n    this.relative = []\n    this.absolute = []\n    this.relativeChildren = []\n    this.absoluteChildren = []\n    const mmopts = {\n      dot: true,\n      nobrace,\n      nocase,\n      noext,\n      noglobstar,\n      optimizationLevel: 2,\n      platform,\n      nocomment: true,\n      nonegate: true,\n    }\n\n    // this is a little weird, but it gives us a clean set of optimized\n    // minimatch matchers, without getting tripped up if one of them\n    // ends in /** inside a brace section, and it's only inefficient at\n    // the start of the walk, not along it.\n    // It'd be nice if the Pattern class just had a .test() method, but\n    // handling globstars is a bit of a pita, and that code already lives\n    // in minimatch anyway.\n    // Another way would be if maybe Minimatch could take its set/globParts\n    // as an option, and then we could at least just use Pattern to test\n    // for absolute-ness.\n    // Yet another way, Minimatch could take an array of glob strings, and\n    // a cwd option, and do the right thing.\n    for (const ign of ignored) {\n      const mm = new Minimatch(ign, mmopts)\n      for (let i = 0; i < mm.set.length; i++) {\n        const parsed = mm.set[i]\n        const globParts = mm.globParts[i]\n        /* c8 ignore start */\n        if (!parsed || !globParts) {\n          throw new Error('invalid pattern object')\n        }\n        /* c8 ignore stop */\n        const p = new Pattern(parsed, globParts, 0, platform)\n        const m = new Minimatch(p.globString(), mmopts)\n        const children = globParts[globParts.length - 1] === '**'\n        const absolute = p.isAbsolute()\n        if (absolute) this.absolute.push(m)\n        else this.relative.push(m)\n        if (children) {\n          if (absolute) this.absoluteChildren.push(m)\n          else this.relativeChildren.push(m)\n        }\n      }\n    }\n  }\n\n  ignored(p: Path): boolean {\n    const fullpath = p.fullpath()\n    const fullpaths = `${fullpath}/`\n    const relative = p.relative() || '.'\n    const relatives = `${relative}/`\n    for (const m of this.relative) {\n      if (m.match(relative) || m.match(relatives)) return true\n    }\n    for (const m of this.absolute) {\n      if (m.match(fullpath) || m.match(fullpaths)) return true\n    }\n    return false\n  }\n\n  childrenIgnored(p: Path): boolean {\n    const fullpath = p.fullpath() + '/'\n    const relative = (p.relative() || '.') + '/'\n    for (const m of this.relativeChildren) {\n      if (m.match(relative)) return true\n    }\n    for (const m of this.absoluteChildren) {\n      if (m.match(fullpath)) return true\n    }\n    return false\n  }\n}\n", "// synchronous utility for filtering entries and calculating subwalks\n\nimport { GLOBSTAR, MMRegExp } from 'minimatch'\nimport { Path } from 'path-scurry'\nimport { MMPattern, Pattern } from './pattern.js'\nimport { GlobWalkerOpts } from './walker.js'\n\n/**\n * A cache of which patterns have been processed for a given Path\n */\nexport class HasWalkedCache {\n  store: Map<string, Set<string>>\n  constructor(store: Map<string, Set<string>> = new Map()) {\n    this.store = store\n  }\n  copy() {\n    return new HasWalkedCache(new Map(this.store))\n  }\n  hasWalked(target: Path, pattern: Pattern) {\n    return this.store.get(target.fullpath())?.has(pattern.globString())\n  }\n  storeWalked(target: Path, pattern: Pattern) {\n    const fullpath = target.fullpath()\n    const cached = this.store.get(fullpath)\n    if (cached) cached.add(pattern.globString())\n    else this.store.set(fullpath, new Set([pattern.globString()]))\n  }\n}\n\n/**\n * A record of which paths have been matched in a given walk step,\n * and whether they only are considered a match if they are a directory,\n * and whether their absolute or relative path should be returned.\n */\nexport class MatchRecord {\n  store: Map<Path, number> = new Map()\n  add(target: Path, absolute: boolean, ifDir: boolean) {\n    const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0)\n    const current = this.store.get(target)\n    this.store.set(target, current === undefined ? n : n & current)\n  }\n  // match, absolute, ifdir\n  entries(): [Path, boolean, boolean][] {\n    return [...this.store.entries()].map(([path, n]) => [\n      path,\n      !!(n & 2),\n      !!(n & 1),\n    ])\n  }\n}\n\n/**\n * A collection of patterns that must be processed in a subsequent step\n * for a given path.\n */\nexport class SubWalks {\n  store: Map<Path, Pattern[]> = new Map()\n  add(target: Path, pattern: Pattern) {\n    if (!target.canReaddir()) {\n      return\n    }\n    const subs = this.store.get(target)\n    if (subs) {\n      if (!subs.find(p => p.globString() === pattern.globString())) {\n        subs.push(pattern)\n      }\n    } else this.store.set(target, [pattern])\n  }\n  get(target: Path): Pattern[] {\n    const subs = this.store.get(target)\n    /* c8 ignore start */\n    if (!subs) {\n      throw new Error('attempting to walk unknown path')\n    }\n    /* c8 ignore stop */\n    return subs\n  }\n  entries(): [Path, Pattern[]][] {\n    return this.keys().map(k => [k, this.store.get(k) as Pattern[]])\n  }\n  keys(): Path[] {\n    return [...this.store.keys()].filter(t => t.canReaddir())\n  }\n}\n\n/**\n * The class that processes patterns for a given path.\n *\n * Handles child entry filtering, and determining whether a path's\n * directory contents must be read.\n */\nexport class Processor {\n  hasWalkedCache: HasWalkedCache\n  matches = new MatchRecord()\n  subwalks = new SubWalks()\n  patterns?: Pattern[]\n  follow: boolean\n  dot: boolean\n  opts: GlobWalkerOpts\n\n  constructor(opts: GlobWalkerOpts, hasWalkedCache?: HasWalkedCache) {\n    this.opts = opts\n    this.follow = !!opts.follow\n    this.dot = !!opts.dot\n    this.hasWalkedCache = hasWalkedCache\n      ? hasWalkedCache.copy()\n      : new HasWalkedCache()\n  }\n\n  processPatterns(target: Path, patterns: Pattern[]) {\n    this.patterns = patterns\n    const processingSet: [Path, Pattern][] = patterns.map(p => [target, p])\n\n    // map of paths to the magic-starting subwalks they need to walk\n    // first item in patterns is the filter\n\n    for (let [t, pattern] of processingSet) {\n      this.hasWalkedCache.storeWalked(t, pattern)\n\n      const root = pattern.root()\n      const absolute = pattern.isAbsolute() && this.opts.absolute !== false\n\n      // start absolute patterns at root\n      if (root) {\n        t = t.resolve(\n          root === '/' && this.opts.root !== undefined\n            ? this.opts.root\n            : root\n        )\n        const rest = pattern.rest()\n        if (!rest) {\n          this.matches.add(t, true, false)\n          continue\n        } else {\n          pattern = rest\n        }\n      }\n\n      if (t.isENOENT()) continue\n\n      let p: MMPattern\n      let rest: Pattern | null\n      let changed = false\n      while (\n        typeof (p = pattern.pattern()) === 'string' &&\n        (rest = pattern.rest())\n      ) {\n        const c = t.resolve(p)\n        t = c\n        pattern = rest\n        changed = true\n      }\n      p = pattern.pattern()\n      rest = pattern.rest()\n      if (changed) {\n        if (this.hasWalkedCache.hasWalked(t, pattern)) continue\n        this.hasWalkedCache.storeWalked(t, pattern)\n      }\n\n      // now we have either a final string for a known entry,\n      // more strings for an unknown entry,\n      // or a pattern starting with magic, mounted on t.\n      if (typeof p === 'string') {\n        // must not be final entry, otherwise we would have\n        // concatenated it earlier.\n        const ifDir = p === '..' || p === '' || p === '.'\n        this.matches.add(t.resolve(p), absolute, ifDir)\n        continue\n      } else if (p === GLOBSTAR) {\n        // if no rest, match and subwalk pattern\n        // if rest, process rest and subwalk pattern\n        // if it's a symlink, but we didn't get here by way of a\n        // globstar match (meaning it's the first time THIS globstar\n        // has traversed a symlink), then we follow it. Otherwise, stop.\n        if (\n          !t.isSymbolicLink() ||\n          this.follow ||\n          pattern.checkFollowGlobstar()\n        ) {\n          this.subwalks.add(t, pattern)\n        }\n        const rp = rest?.pattern()\n        const rrest = rest?.rest()\n        if (!rest || ((rp === '' || rp === '.') && !rrest)) {\n          // only HAS to be a dir if it ends in **/ or **/.\n          // but ending in ** will match files as well.\n          this.matches.add(t, absolute, rp === '' || rp === '.')\n        } else {\n          if (rp === '..') {\n            // this would mean you're matching **/.. at the fs root,\n            // and no thanks, I'm not gonna test that specific case.\n            /* c8 ignore start */\n            const tp = t.parent || t\n            /* c8 ignore stop */\n            if (!rrest) this.matches.add(tp, absolute, true)\n            else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {\n              this.subwalks.add(tp, rrest)\n            }\n          }\n        }\n      } else if (p instanceof RegExp) {\n        this.subwalks.add(t, pattern)\n      }\n    }\n\n    return this\n  }\n\n  subwalkTargets(): Path[] {\n    return this.subwalks.keys()\n  }\n\n  child() {\n    return new Processor(this.opts, this.hasWalkedCache)\n  }\n\n  // return a new Processor containing the subwalks for each\n  // child entry, and a set of matches, and\n  // a hasWalkedCache that's a copy of this one\n  // then we're going to call\n  filterEntries(parent: Path, entries: Path[]): Processor {\n    const patterns = this.subwalks.get(parent)\n    // put matches and entry walks into the results processor\n    const results = this.child()\n    for (const e of entries) {\n      for (const pattern of patterns) {\n        const absolute = pattern.isAbsolute()\n        const p = pattern.pattern()\n        const rest = pattern.rest()\n        if (p === GLOBSTAR) {\n          results.testGlobstar(e, pattern, rest, absolute)\n        } else if (p instanceof RegExp) {\n          results.testRegExp(e, p, rest, absolute)\n        } else {\n          results.testString(e, p, rest, absolute)\n        }\n      }\n    }\n    return results\n  }\n\n  testGlobstar(\n    e: Path,\n    pattern: Pattern,\n    rest: Pattern | null,\n    absolute: boolean\n  ) {\n    if (this.dot || !e.name.startsWith('.')) {\n      if (!pattern.hasMore()) {\n        this.matches.add(e, absolute, false)\n      }\n      if (e.canReaddir()) {\n        // if we're in follow mode or it's not a symlink, just keep\n        // testing the same pattern. If there's more after the globstar,\n        // then this symlink consumes the globstar. If not, then we can\n        // follow at most ONE symlink along the way, so we mark it, which\n        // also checks to ensure that it wasn't already marked.\n        if (this.follow || !e.isSymbolicLink()) {\n          this.subwalks.add(e, pattern)\n        } else if (e.isSymbolicLink()) {\n          if (rest && pattern.checkFollowGlobstar()) {\n            this.subwalks.add(e, rest)\n          } else if (pattern.markFollowGlobstar()) {\n            this.subwalks.add(e, pattern)\n          }\n        }\n      }\n    }\n    // if the NEXT thing matches this entry, then also add\n    // the rest.\n    if (rest) {\n      const rp = rest.pattern()\n      if (\n        typeof rp === 'string' &&\n        // dots and empty were handled already\n        rp !== '..' &&\n        rp !== '' &&\n        rp !== '.'\n      ) {\n        this.testString(e, rp, rest.rest(), absolute)\n      } else if (rp === '..') {\n        /* c8 ignore start */\n        const ep = e.parent || e\n        /* c8 ignore stop */\n        this.subwalks.add(ep, rest)\n      } else if (rp instanceof RegExp) {\n        this.testRegExp(e, rp, rest.rest(), absolute)\n      }\n    }\n  }\n\n  testRegExp(\n    e: Path,\n    p: MMRegExp,\n    rest: Pattern | null,\n    absolute: boolean\n  ) {\n    if (!p.test(e.name)) return\n    if (!rest) {\n      this.matches.add(e, absolute, false)\n    } else {\n      this.subwalks.add(e, rest)\n    }\n  }\n\n  testString(e: Path, p: string, rest: Pattern | null, absolute: boolean) {\n    // should never happen?\n    if (!e.isNamed(p)) return\n    if (!rest) {\n      this.matches.add(e, absolute, false)\n    } else {\n      this.subwalks.add(e, rest)\n    }\n  }\n}\n", "/**\n * Single-use utility classes to provide functionality to the {@link Glob}\n * methods.\n *\n * @module\n */\nimport { Minipass } from 'minipass'\nimport { Path } from 'path-scurry'\nimport { Ignore, IgnoreLike } from './ignore.js'\n\n// XXX can we somehow make it so that it NEVER processes a given path more than\n// once, enough that the match set tracking is no longer needed?  that'd speed\n// things up a lot.  Or maybe bring back nounique, and skip it in that case?\n\n// a single minimatch set entry with 1 or more parts\nimport { Pattern } from './pattern.js'\nimport { Processor } from './processor.js'\n\nexport interface GlobWalkerOpts {\n  absolute?: boolean\n  allowWindowsEscape?: boolean\n  cwd?: string | URL\n  dot?: boolean\n  dotRelative?: boolean\n  follow?: boolean\n  ignore?: string | string[] | IgnoreLike\n  mark?: boolean\n  matchBase?: boolean\n  // Note: maxDepth here means \"maximum actual Path.depth()\",\n  // not \"maximum depth beyond cwd\"\n  maxDepth?: number\n  nobrace?: boolean\n  nocase?: boolean\n  nodir?: boolean\n  noext?: boolean\n  noglobstar?: boolean\n  platform?: NodeJS.Platform\n  posix?: boolean\n  realpath?: boolean\n  root?: string\n  stat?: boolean\n  signal?: AbortSignal\n  windowsPathsNoEscape?: boolean\n  withFileTypes?: boolean\n}\n\nexport type GWOFileTypesTrue = GlobWalkerOpts & {\n  withFileTypes: true\n}\nexport type GWOFileTypesFalse = GlobWalkerOpts & {\n  withFileTypes: false\n}\nexport type GWOFileTypesUnset = GlobWalkerOpts & {\n  withFileTypes?: undefined\n}\n\nexport type Result<O extends GlobWalkerOpts> = O extends GWOFileTypesTrue\n  ? Path\n  : O extends GWOFileTypesFalse\n  ? string\n  : O extends GWOFileTypesUnset\n  ? string\n  : Path | string\n\nexport type Matches<O extends GlobWalkerOpts> = O extends GWOFileTypesTrue\n  ? Set<Path>\n  : O extends GWOFileTypesFalse\n  ? Set<string>\n  : O extends GWOFileTypesUnset\n  ? Set<string>\n  : Set<Path | string>\n\nexport type MatchStream<O extends GlobWalkerOpts> =\n  O extends GWOFileTypesTrue\n    ? Minipass<Path, Path>\n    : O extends GWOFileTypesFalse\n    ? Minipass<string, string>\n    : O extends GWOFileTypesUnset\n    ? Minipass<string, string>\n    : Minipass<Path | string, Path | string>\n\nconst makeIgnore = (\n  ignore: string | string[] | IgnoreLike,\n  opts: GlobWalkerOpts\n): IgnoreLike =>\n  typeof ignore === 'string'\n    ? new Ignore([ignore], opts)\n    : Array.isArray(ignore)\n    ? new Ignore(ignore, opts)\n    : ignore\n\n/**\n * basic walking utilities that all the glob walker types use\n */\nexport abstract class GlobUtil<O extends GlobWalkerOpts = GlobWalkerOpts> {\n  path: Path\n  patterns: Pattern[]\n  opts: O\n  seen: Set<Path> = new Set<Path>()\n  paused: boolean = false\n  aborted: boolean = false\n  #onResume: (() => any)[] = []\n  #ignore?: IgnoreLike\n  #sep: '\\\\' | '/'\n  signal?: AbortSignal\n  maxDepth: number\n\n  constructor(patterns: Pattern[], path: Path, opts: O)\n  constructor(patterns: Pattern[], path: Path, opts: O) {\n    this.patterns = patterns\n    this.path = path\n    this.opts = opts\n    this.#sep = !opts.posix && opts.platform === 'win32' ? '\\\\' : '/'\n    if (opts.ignore) {\n      this.#ignore = makeIgnore(opts.ignore, opts)\n    }\n    // ignore, always set with maxDepth, but it's optional on the\n    // GlobOptions type\n    /* c8 ignore start */\n    this.maxDepth = opts.maxDepth || Infinity\n    /* c8 ignore stop */\n    if (opts.signal) {\n      this.signal = opts.signal\n      this.signal.addEventListener('abort', () => {\n        this.#onResume.length = 0\n      })\n    }\n  }\n\n  #ignored(path: Path): boolean {\n    return this.seen.has(path) || !!this.#ignore?.ignored?.(path)\n  }\n  #childrenIgnored(path: Path): boolean {\n    return !!this.#ignore?.childrenIgnored?.(path)\n  }\n\n  // backpressure mechanism\n  pause() {\n    this.paused = true\n  }\n  resume() {\n    /* c8 ignore start */\n    if (this.signal?.aborted) return\n    /* c8 ignore stop */\n    this.paused = false\n    let fn: (() => any) | undefined = undefined\n    while (!this.paused && (fn = this.#onResume.shift())) {\n      fn()\n    }\n  }\n  onResume(fn: () => any) {\n    if (this.signal?.aborted) return\n    /* c8 ignore start */\n    if (!this.paused) {\n      fn()\n    } else {\n      /* c8 ignore stop */\n      this.#onResume.push(fn)\n    }\n  }\n\n  // do the requisite realpath/stat checking, and return the path\n  // to add or undefined to filter it out.\n  async matchCheck(e: Path, ifDir: boolean): Promise<Path | undefined> {\n    if (ifDir && this.opts.nodir) return undefined\n    let rpc: Path | undefined\n    if (this.opts.realpath) {\n      rpc = e.realpathCached() || (await e.realpath())\n      if (!rpc) return undefined\n      e = rpc\n    }\n    const needStat = e.isUnknown() || this.opts.stat\n    return this.matchCheckTest(needStat ? await e.lstat() : e, ifDir)\n  }\n\n  matchCheckTest(e: Path | undefined, ifDir: boolean): Path | undefined {\n    return e &&\n      (this.maxDepth === Infinity || e.depth() <= this.maxDepth) &&\n      (!ifDir || e.canReaddir()) &&\n      (!this.opts.nodir || !e.isDirectory()) &&\n      !this.#ignored(e)\n      ? e\n      : undefined\n  }\n\n  matchCheckSync(e: Path, ifDir: boolean): Path | undefined {\n    if (ifDir && this.opts.nodir) return undefined\n    let rpc: Path | undefined\n    if (this.opts.realpath) {\n      rpc = e.realpathCached() || e.realpathSync()\n      if (!rpc) return undefined\n      e = rpc\n    }\n    const needStat = e.isUnknown() || this.opts.stat\n    return this.matchCheckTest(needStat ? e.lstatSync() : e, ifDir)\n  }\n\n  abstract matchEmit(p: Result<O>): void\n  abstract matchEmit(p: string | Path): void\n\n  matchFinish(e: Path, absolute: boolean) {\n    if (this.#ignored(e)) return\n    const abs =\n      this.opts.absolute === undefined ? absolute : this.opts.absolute\n    this.seen.add(e)\n    const mark = this.opts.mark && e.isDirectory() ? this.#sep : ''\n    // ok, we have what we need!\n    if (this.opts.withFileTypes) {\n      this.matchEmit(e)\n    } else if (abs) {\n      const abs = this.opts.posix ? e.fullpathPosix() : e.fullpath()\n      this.matchEmit(abs + mark)\n    } else {\n      const rel = this.opts.posix ? e.relativePosix() : e.relative()\n      const pre =\n        this.opts.dotRelative && !rel.startsWith('..' + this.#sep)\n          ? '.' + this.#sep\n          : ''\n      this.matchEmit(!rel ? '.' + mark : pre + rel + mark)\n    }\n  }\n\n  async match(e: Path, absolute: boolean, ifDir: boolean): Promise<void> {\n    const p = await this.matchCheck(e, ifDir)\n    if (p) this.matchFinish(p, absolute)\n  }\n\n  matchSync(e: Path, absolute: boolean, ifDir: boolean): void {\n    const p = this.matchCheckSync(e, ifDir)\n    if (p) this.matchFinish(p, absolute)\n  }\n\n  walkCB(target: Path, patterns: Pattern[], cb: () => any) {\n    /* c8 ignore start */\n    if (this.signal?.aborted) cb()\n    /* c8 ignore stop */\n    this.walkCB2(target, patterns, new Processor(this.opts), cb)\n  }\n\n  walkCB2(\n    target: Path,\n    patterns: Pattern[],\n    processor: Processor,\n    cb: () => any\n  ) {\n    if (this.#childrenIgnored(target)) return cb()\n    if (this.signal?.aborted) cb()\n    if (this.paused) {\n      this.onResume(() => this.walkCB2(target, patterns, processor, cb))\n      return\n    }\n    processor.processPatterns(target, patterns)\n\n    // done processing.  all of the above is sync, can be abstracted out.\n    // subwalks is a map of paths to the entry filters they need\n    // matches is a map of paths to [absolute, ifDir] tuples.\n    let tasks = 1\n    const next = () => {\n      if (--tasks === 0) cb()\n    }\n\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (this.#ignored(m)) continue\n      tasks++\n      this.match(m, absolute, ifDir).then(() => next())\n    }\n\n    for (const t of processor.subwalkTargets()) {\n      if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {\n        continue\n      }\n      tasks++\n      const childrenCached = t.readdirCached()\n      if (t.calledReaddir())\n        this.walkCB3(t, childrenCached, processor, next)\n      else {\n        t.readdirCB(\n          (_, entries) => this.walkCB3(t, entries, processor, next),\n          true\n        )\n      }\n    }\n\n    next()\n  }\n\n  walkCB3(\n    target: Path,\n    entries: Path[],\n    processor: Processor,\n    cb: () => any\n  ) {\n    processor = processor.filterEntries(target, entries)\n\n    let tasks = 1\n    const next = () => {\n      if (--tasks === 0) cb()\n    }\n\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (this.#ignored(m)) continue\n      tasks++\n      this.match(m, absolute, ifDir).then(() => next())\n    }\n    for (const [target, patterns] of processor.subwalks.entries()) {\n      tasks++\n      this.walkCB2(target, patterns, processor.child(), next)\n    }\n\n    next()\n  }\n\n  walkCBSync(target: Path, patterns: Pattern[], cb: () => any) {\n    /* c8 ignore start */\n    if (this.signal?.aborted) cb()\n    /* c8 ignore stop */\n    this.walkCB2Sync(target, patterns, new Processor(this.opts), cb)\n  }\n\n  walkCB2Sync(\n    target: Path,\n    patterns: Pattern[],\n    processor: Processor,\n    cb: () => any\n  ) {\n    if (this.#childrenIgnored(target)) return cb()\n    if (this.signal?.aborted) cb()\n    if (this.paused) {\n      this.onResume(() =>\n        this.walkCB2Sync(target, patterns, processor, cb)\n      )\n      return\n    }\n    processor.processPatterns(target, patterns)\n\n    // done processing.  all of the above is sync, can be abstracted out.\n    // subwalks is a map of paths to the entry filters they need\n    // matches is a map of paths to [absolute, ifDir] tuples.\n    let tasks = 1\n    const next = () => {\n      if (--tasks === 0) cb()\n    }\n\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (this.#ignored(m)) continue\n      this.matchSync(m, absolute, ifDir)\n    }\n\n    for (const t of processor.subwalkTargets()) {\n      if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {\n        continue\n      }\n      tasks++\n      const children = t.readdirSync()\n      this.walkCB3Sync(t, children, processor, next)\n    }\n\n    next()\n  }\n\n  walkCB3Sync(\n    target: Path,\n    entries: Path[],\n    processor: Processor,\n    cb: () => any\n  ) {\n    processor = processor.filterEntries(target, entries)\n\n    let tasks = 1\n    const next = () => {\n      if (--tasks === 0) cb()\n    }\n\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (this.#ignored(m)) continue\n      this.matchSync(m, absolute, ifDir)\n    }\n    for (const [target, patterns] of processor.subwalks.entries()) {\n      tasks++\n      this.walkCB2Sync(target, patterns, processor.child(), next)\n    }\n\n    next()\n  }\n}\n\nexport class GlobWalker<\n  O extends GlobWalkerOpts = GlobWalkerOpts\n> extends GlobUtil<O> {\n  matches: O extends GWOFileTypesTrue\n    ? Set<Path>\n    : O extends GWOFileTypesFalse\n    ? Set<string>\n    : O extends GWOFileTypesUnset\n    ? Set<string>\n    : Set<Path | string>\n\n  constructor(patterns: Pattern[], path: Path, opts: O) {\n    super(patterns, path, opts)\n    this.matches = new Set() as Matches<O>\n  }\n\n  matchEmit(e: Result<O>): void\n  matchEmit(e: Path | string): void {\n    this.matches.add(e)\n  }\n\n  async walk(): Promise<Matches<O>> {\n    if (this.signal?.aborted) throw this.signal.reason\n    if (this.path.isUnknown()) {\n      await this.path.lstat()\n    }\n    await new Promise((res, rej) => {\n      this.walkCB(this.path, this.patterns, () => {\n        if (this.signal?.aborted) {\n          rej(this.signal.reason)\n        } else {\n          res(this.matches)\n        }\n      })\n    })\n    return this.matches\n  }\n\n  walkSync(): Matches<O> {\n    if (this.signal?.aborted) throw this.signal.reason\n    if (this.path.isUnknown()) {\n      this.path.lstatSync()\n    }\n    // nothing for the callback to do, because this never pauses\n    this.walkCBSync(this.path, this.patterns, () => {\n      if (this.signal?.aborted) throw this.signal.reason\n    })\n    return this.matches\n  }\n}\n\nexport class GlobStream<\n  O extends GlobWalkerOpts = GlobWalkerOpts\n> extends GlobUtil<O> {\n  results: O extends GWOFileTypesTrue\n    ? Minipass<Path, Path>\n    : O extends GWOFileTypesFalse\n    ? Minipass<string, string>\n    : O extends GWOFileTypesUnset\n    ? Minipass<string, string>\n    : Minipass<Path | string, Path | string>\n\n  constructor(patterns: Pattern[], path: Path, opts: O) {\n    super(patterns, path, opts)\n    this.results = new Minipass({\n      signal: this.signal,\n      objectMode: true,\n    }) as MatchStream<O>\n    this.results.on('drain', () => this.resume())\n    this.results.on('resume', () => this.resume())\n  }\n\n  matchEmit(e: Result<O>): void\n  matchEmit(e: Path | string): void {\n    this.results.write(e)\n    if (!this.results.flowing) this.pause()\n  }\n\n  stream(): MatchStream<O> {\n    const target = this.path\n    if (target.isUnknown()) {\n      target.lstat().then(() => {\n        this.walkCB(target, this.patterns, () => this.results.end())\n      })\n    } else {\n      this.walkCB(target, this.patterns, () => this.results.end())\n    }\n    return this.results\n  }\n\n  streamSync(): MatchStream<O> {\n    if (this.path.isUnknown()) {\n      this.path.lstatSync()\n    }\n    this.walkCBSync(this.path, this.patterns, () => this.results.end())\n    return this.results\n  }\n}\n", "import { Minimatch } from 'minimatch'\nimport { GlobOptions } from './glob.js'\n\n/**\n * Return true if the patterns provided contain any magic glob characters,\n * given the options provided.\n *\n * Brace expansion is not considered \"magic\" unless the `magicalBraces` option\n * is set, as brace expansion just turns one string into an array of strings.\n * So a pattern like `'x{a,b}y'` would return `false`, because `'xay'` and\n * `'xby'` both do not contain any magic glob characters, and it's treated the\n * same as if you had called it on `['xay', 'xby']`. When `magicalBraces:true`\n * is in the options, brace expansion _is_ treated as a pattern having magic.\n */\nexport const hasMagic = (\n  pattern: string | string[],\n  options: GlobOptions = {}\n): boolean => {\n  if (!Array.isArray(pattern)) {\n    pattern = [pattern]\n  }\n  for (const p of pattern) {\n    if (new Minimatch(p, options).hasMagic()) return true\n  }\n  return false\n}\n", "import { escape, unescape } from 'minimatch'\nimport { Minipass } from 'minipass'\nimport { Path } from 'path-scurry'\nimport type {\n  GlobOptions,\n  GlobOptionsWithFileTypesFalse,\n  GlobOptionsWithFileTypesTrue,\n  GlobOptionsWithFileTypesUnset,\n} from './glob.js'\nimport { Glob } from './glob.js'\nimport { hasMagic } from './has-magic.js'\n\n/**\n * Syncronous form of {@link globStream}. Will read all the matches as fast as\n * you consume them, even all in a single tick if you consume them immediately,\n * but will still respond to backpressure if they're not consumed immediately.\n */\nexport function globStreamSync(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesTrue\n): Minipass<Path, Path>\nexport function globStreamSync(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesFalse\n): Minipass<string, string>\nexport function globStreamSync(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesUnset\n): Minipass<string, string>\nexport function globStreamSync(\n  pattern: string | string[],\n  options: GlobOptions\n): Minipass<Path, Path> | Minipass<string, string>\nexport function globStreamSync(\n  pattern: string | string[],\n  options: GlobOptions = {}\n) {\n  return new Glob(pattern, options).streamSync()\n}\n\n/**\n * Return a stream that emits all the strings or `Path` objects and\n * then emits `end` when completed.\n */\nexport function globStream(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesFalse\n): Minipass<string, string>\nexport function globStream(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesTrue\n): Minipass<Path, Path>\nexport function globStream(\n  pattern: string | string[],\n  options?: GlobOptionsWithFileTypesUnset | undefined\n): Minipass<string, string>\nexport function globStream(\n  pattern: string | string[],\n  options: GlobOptions\n): Minipass<Path, Path> | Minipass<string, string>\nexport function globStream(\n  pattern: string | string[],\n  options: GlobOptions = {}\n) {\n  return new Glob(pattern, options).stream()\n}\n\n/**\n * Synchronous form of {@link glob}\n */\nexport function globSync(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesFalse\n): string[]\nexport function globSync(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesTrue\n): Path[]\nexport function globSync(\n  pattern: string | string[],\n  options?: GlobOptionsWithFileTypesUnset | undefined\n): string[]\nexport function globSync(\n  pattern: string | string[],\n  options: GlobOptions\n): Path[] | string[]\nexport function globSync(\n  pattern: string | string[],\n  options: GlobOptions = {}\n) {\n  return new Glob(pattern, options).walkSync()\n}\n\n/**\n * Perform an asynchronous glob search for the pattern(s) specified. Returns\n * [Path](https://isaacs.github.io/path-scurry/classes/PathBase) objects if the\n * {@link withFileTypes} option is set to `true`. See {@link GlobOptions} for\n * full option descriptions.\n */\nasync function glob_(\n  pattern: string | string[],\n  options?: GlobOptionsWithFileTypesUnset | undefined\n): Promise<string[]>\nasync function glob_(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesTrue\n): Promise<Path[]>\nasync function glob_(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesFalse\n): Promise<string[]>\nasync function glob_(\n  pattern: string | string[],\n  options: GlobOptions\n): Promise<Path[] | string[]>\nasync function glob_(\n  pattern: string | string[],\n  options: GlobOptions = {}\n) {\n  return new Glob(pattern, options).walk()\n}\n\n/**\n * Return a sync iterator for walking glob pattern matches.\n */\nexport function globIterateSync(\n  pattern: string | string[],\n  options?: GlobOptionsWithFileTypesUnset | undefined\n): Generator<string, void, void>\nexport function globIterateSync(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesTrue\n): Generator<Path, void, void>\nexport function globIterateSync(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesFalse\n): Generator<string, void, void>\nexport function globIterateSync(\n  pattern: string | string[],\n  options: GlobOptions\n): Generator<Path, void, void> | Generator<string, void, void>\nexport function globIterateSync(\n  pattern: string | string[],\n  options: GlobOptions = {}\n) {\n  return new Glob(pattern, options).iterateSync()\n}\n\n/**\n * Return an async iterator for walking glob pattern matches.\n */\nexport function globIterate(\n  pattern: string | string[],\n  options?: GlobOptionsWithFileTypesUnset | undefined\n): AsyncGenerator<string, void, void>\nexport function globIterate(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesTrue\n): AsyncGenerator<Path, void, void>\nexport function globIterate(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesFalse\n): AsyncGenerator<string, void, void>\nexport function globIterate(\n  pattern: string | string[],\n  options: GlobOptions\n): AsyncGenerator<Path, void, void> | AsyncGenerator<string, void, void>\nexport function globIterate(\n  pattern: string | string[],\n  options: GlobOptions = {}\n) {\n  return new Glob(pattern, options).iterate()\n}\n\n// aliases: glob.sync.stream() glob.stream.sync() glob.sync() etc\nexport const streamSync = globStreamSync\nexport const stream = Object.assign(globStream, { sync: globStreamSync })\nexport const iterateSync = globIterateSync\nexport const iterate = Object.assign(globIterate, {\n  sync: globIterateSync,\n})\nexport const sync = Object.assign(globSync, {\n  stream: globStreamSync,\n  iterate: globIterateSync,\n})\n\n/* c8 ignore start */\nexport { escape, unescape } from 'minimatch'\nexport { Glob } from './glob.js'\nexport type {\n  GlobOptions,\n  GlobOptionsWithFileTypesFalse,\n  GlobOptionsWithFileTypesTrue,\n  GlobOptionsWithFileTypesUnset,\n} from './glob.js'\nexport { hasMagic } from './has-magic.js'\nexport type { IgnoreLike } from './ignore.js'\nexport type { MatchStream } from './walker.js'\nexport type {\n  Path,\n  WalkOptionsWithFileTypesTrue,\n  WalkOptionsWithFileTypesUnset,\n  WalkOptions,\n  FSOption,\n} from 'path-scurry'\n\n/* c8 ignore stop */\n\nexport const glob = Object.assign(glob_, {\n  glob: glob_,\n  globSync,\n  sync,\n  globStream,\n  stream,\n  globStreamSync,\n  streamSync,\n  globIterate,\n  iterate,\n  globIterateSync,\n  iterateSync,\n  Glob,\n  hasMagic,\n  escape,\n  unescape,\n})\nglob.glob = glob\n", "/*\n * Copyright (c) 2024 Elide Technologies, Inc.\n *\n * Licensed under the MIT license (the \"License\"); you may not use this file except in compliance\n *  with the License. You may obtain a copy of the License at\n *\n *     https://opensource.org/license/mit/\n *\n *  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n *  License for the specific language governing permissions and limitations under the License.\n */\n\nimport { VerifyHashFileInfo, VerifyFailedInfo } from './model'\n\n/**\n * Results Interface\n *\n * Generalized results receiver interface used to communicate results to GitHub Actions or the CLI.\n */\nexport interface HashVerifierResultsReceiver {\n  /**\n   * Report a result.\n   *\n   * @param result Result to report\n   */\n  result(result: VerifyHashFileInfo): void\n\n  /**\n   * Report a check failure.\n   *\n   * @param result Failure to report\n   */\n  failure(result: VerifyFailedInfo): void\n\n  /**\n   * Reports all eligible files after verification.\n   *\n   * @param files All eligible files seen during the operation\n   */\n  eligible(files: string[]): void\n}\n\n/**\n * Logger Interface\n *\n * Generalized logger interface used to communicate logs to GitHub Actions or the CLI.\n */\nexport interface HashVerifierLogger {\n  /**\n   * Log a debug-level message.\n   *\n   * @param message Message to log\n   */\n  debug(message: string): void\n\n  /**\n   * Log an info-level message.\n   *\n   * @param message Message to log\n   */\n  info(message: string): void\n\n  /**\n   * Log a warning-level message.\n   *\n   * @param message Message to log\n   */\n  warning(message: string): void\n\n  /**\n   * Log an error-level message.\n   *\n   * @param message Message to log\n   */\n  error(message: string): void\n\n  /**\n   * Set the exit failure reason\n   *\n   * @param message Failure reason\n   */\n  setFailed(message: Error | string): void\n}\n\n/**\n * Create a default logger which uses the console\n *\n * @returns Default hash verifier logger\n */\nexport function createDefaultLogger(): HashVerifierLogger {\n  return {\n    debug: (message: string) => console.debug(message),\n    info: (message: string) => console.info(message),\n    warning: (message: string) => console.warn(message),\n    error: (message: string) => console.error(message),\n    setFailed: (message: string) => {\n      console.error(message)\n      process.exit(1)\n    }\n  }\n}\n\n/**\n * Create a default hash verifier results receiver which logs results.\n *\n * @returns Default hash verifier results receiver\n */\nexport function createDefaultReporter(): HashVerifierResultsReceiver {\n  return {\n    eligible: () => {\n      /* nothing at this time @TODO */\n    },\n    result: () => {\n      /* nothing at this time @TODO */\n    },\n    failure: (result: VerifyFailedInfo) => {\n      /* c8 ignore next */\n      console.error(`Hash check failed: ${result.reason}; ${result.message}`)\n      /* c8 ignore next */\n    }\n  }\n}\n", "/*\n * Copyright (c) 2024 Elide Technologies, Inc.\n *\n * Licensed under the MIT license (the \"License\"); you may not use this file except in compliance\n *  with the License. You may obtain a copy of the License at\n *\n *     https://opensource.org/license/mit/\n *\n *  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n *  License for the specific language governing permissions and limitations under the License.\n */\n\nimport { entrypoint } from './cli'\n\n// Run the CLI tool.\nentrypoint()\n"],
  "mappings": "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",
  "names": ["require_error", "__commonJSMin", "exports", "CommanderError", "exitCode", "code", "message", "InvalidArgumentError", "require_argument", "__commonJSMin", "exports", "InvalidArgumentError", "Argument", "name", "description", "value", "previous", "fn", "values", "arg", "humanReadableArgName", "nameOutput", "require_help", "__commonJSMin", "exports", "humanReadableArgName", "Help", "cmd", "visibleCommands", "helpCommand", "a", "b", "getSortKey", "option", "visibleOptions", "helpOption", "removeShort", "removeLong", "globalOptions", "ancestorCmd", "argument", "args", "arg", "helper", "max", "command", "cmdName", "ancestorCmdNames", "extraInfo", "choice", "extraDescripton", "termWidth", "helpWidth", "itemIndentWidth", "itemSeparatorWidth", "formatItem", "term", "description", "fullText", "formatList", "textArray", "output", "commandDescription", "argumentList", "optionList", "globalOptionList", "commandList", "str", "width", "indent", "minColumnWidth", "indents", "manualIndent", "columnWidth", "leadingStr", "columnText", "indentString", "breaks", "regex", "lines", "line", "i", "require_option", "__commonJSMin", "exports", "InvalidArgumentError", "Option", "flags", "description", "optionFlags", "splitOptionFlags", "value", "arg", "names", "impliedOptionValues", "newImplied", "name", "fn", "mandatory", "hide", "previous", "values", "camelcase", "DualOptions", "options", "option", "key", "optionKey", "preset", "negativeValue", "str", "word", "shortFlag", "longFlag", "flagParts", "require_suggestSimilar", "__commonJSMin", "exports", "editDistance", "a", "b", "d", "i", "j", "cost", "suggestSimilar", "word", "candidates", "searchingOptions", "candidate", "similar", "bestDistance", "minSimilarity", "distance", "length", "require_command", "__commonJSMin", "exports", "EventEmitter", "childProcess", "path", "fs", "process", "Argument", "humanReadableArgName", "CommanderError", "Help", "Option", "DualOptions", "suggestSimilar", "Command", "_Command", "name", "str", "write", "sourceCommand", "result", "command", "nameAndArgs", "actionOptsOrExecDesc", "execOpts", "desc", "opts", "args", "cmd", "configuration", "displayHelp", "displaySuggestion", "description", "fn", "defaultValue", "argument", "names", "detail", "previousArgument", "enableOrNameAndArgs", "helpName", "helpArgs", "helpDescription", "helpCommand", "deprecatedDescription", "event", "listener", "allowedValues", "err", "exitCode", "code", "message", "expectedArgsCount", "actionArgs", "flags", "target", "value", "previous", "invalidArgumentMessage", "option", "matchingOption", "matchingFlag", "knownBy", "alreadyUsed", "existingCmd", "newCmd", "oname", "positiveLongFlag", "handleOptionValue", "val", "invalidValueMessage", "valueSource", "oldValue", "config", "regex", "def", "m", "parseArg", "combine", "allowUnknown", "allowExcess", "positional", "passThrough", "storeAsProperties", "key", "source", "argv", "parseOptions", "userArgs", "subcommand", "launchWithNode", "sourceExt", "findFile", "baseDir", "baseName", "localBin", "foundExt", "ext", "executableFile", "executableDir", "resolvedScriptPath", "localFile", "legacyName", "proc", "incrementNodeInspectorPort", "signal", "exitCallback", "_signal", "executableDirMessage", "executableMissing", "wrappedError", "commandName", "operands", "unknown", "subCommand", "promiseChain", "subcommandName", "arg", "i", "myParseArg", "parsedValue", "processedArgs", "declaredArg", "index", "processed", "v", "promise", "hooks", "hookedCommand", "callback", "hookDetail", "hook", "parsed", "checkForUnknownOptions", "commandEvent", "anOption", "definedNonDefaultOptions", "optionKey", "conflictingAndDefined", "defined", "dest", "maybeOption", "activeVariadicOption", "len", "combinedOptions", "errorOptions", "dualHelper", "hasCustomOptionValue", "impliedKey", "conflictingOption", "findBestOptionFromValue", "optionValue", "negativeOption", "positiveOption", "getErrorMessage", "bestOption", "flag", "suggestion", "candidateFlags", "moreFlags", "receivedArgs", "expected", "unknownName", "candidateNames", "versionOption", "argsDescription", "alias", "matchingCommand", "aliases", "filename", "contextOptions", "helper", "context", "deprecatedCallback", "helpInformation", "position", "text", "helpEvent", "helpStr", "helpOption", "debugOption", "debugHost", "debugPort", "match", "require_commander", "__commonJSMin", "exports", "Argument", "Command", "CommanderError", "InvalidArgumentError", "Help", "Option", "name", "flags", "description", "require_balanced_match", "__commonJSMin", "exports", "module", "balanced", "a", "b", "str", "maybeMatch", "r", "range", "reg", "m", "begs", "beg", "left", "right", "result", "ai", "bi", "i", "require_brace_expansion", "__commonJSMin", "exports", "module", "balanced", "expandTop", "escSlash", "escOpen", "escClose", "escComma", "escPeriod", "numeric", "str", "escapeBraces", "unescapeBraces", "parseCommaParts", "parts", "m", "pre", "body", "post", "p", "postParts", "expand", "embrace", "isPadded", "el", "lte", "i", "y", "gte", "isTop", "expansions", "k", "expansion", "isNumericSequence", "isAlphaSequence", "isSequence", "isOptions", "n", "N", "x", "width", "incr", "test", "reverse", "pad", "c", "need", "z", "j", "process", "import_index", "program", "createCommand", "createArgument", "createOption", "CommanderError", "InvalidArgumentError", "InvalidOptionArgumentError", "Command", "Argument", "Option", "Help", "commander", "createCliLogger", "cli", "message", "createCliReporter", "result", "msg", "expectedHexHashSize", "encodedHashSizeHex", "expectedBase64HashSize", "encodedHashSizeBase64", "expectedHexCharactersRegex", "expectedBase64CharactersRegex", "extensionMap", "allAlgorithms", "import_node_path", "import_node_fs", "import_promises", "import_node_crypto", "generateHash", "algo", "encoding", "content", "import_brace_expansion", "assertValidPattern", "pattern", "posixClasses", "braceEscape", "s", "regexpEscape", "rangesToString", "ranges", "parseClass", "glob", "position", "pos", "negs", "i", "sawStart", "uflag", "escaping", "negate", "endPos", "rangeStart", "WHILE", "c", "cls", "unip", "u", "neg", "r", "sranges", "snegs", "unescape", "s", "windowsPathsNoEscape", "types", "isExtglobType", "c", "startNoTraversal", "startNoDot", "addPatternStart", "justDots", "reSpecials", "regExpEscape", "s", "qmark", "star", "starNoEmpty", "AST", "_AST", "#root", "#hasMagic", "#uflag", "#parts", "#parent", "#parentIndex", "#negs", "#filledNegs", "#options", "#toString", "#emptyExt", "type", "parent", "options", "p", "#fillNegs", "n", "pp", "part", "parts", "ret", "i", "pl", "#parseAST", "str", "ast", "pos", "opt", "escaping", "inBrace", "braceStart", "braceNeg", "acc", "ext", "pattern", "glob", "re", "body", "hasMagic", "uflag", "flags", "allowDot", "dot", "noEmpty", "src", "_", "#parseGlob", "start", "aps", "needNoTrav", "needNoDot", "end", "unescape", "repeated", "#partsToRegExp", "bodyDotAllowed", "final", "close", "_hasMagic", "needUflag", "consumed", "magic", "parseClass", "escape", "s", "windowsPathsNoEscape", "minimatch", "p", "pattern", "options", "assertValidPattern", "Minimatch", "starDotExtRE", "starDotExtTest", "ext", "f", "starDotExtTestDot", "starDotExtTestNocase", "starDotExtTestNocaseDot", "starDotStarRE", "starDotStarTest", "starDotStarTestDot", "dotStarRE", "dotStarTest", "starRE", "starTest", "starTestDot", "qmarksRE", "qmarksTestNocase", "$0", "noext", "qmarksTestNoExt", "qmarksTestNocaseDot", "qmarksTestNoExtDot", "qmarksTestDot", "qmarksTest", "len", "defaultPlatform", "path", "sep", "GLOBSTAR", "qmark", "star", "twoStarDot", "twoStarNoDot", "filter", "a", "b", "defaults", "def", "orig", "type", "parent", "list", "braceExpand", "expand", "makeRe", "match", "mm", "globMagic", "regExpEscape", "s", "part", "_", "args", "rawGlobParts", "set", "__", "isUNC", "isDrive", "ss", "i", "globParts", "j", "optimizationLevel", "parts", "gs", "prev", "didSomething", "dd", "gss", "next", "p2", "other", "splin", "matched", "emptyGSMatch", "ai", "bi", "result", "which", "negate", "negateOffset", "file", "partial", "fileDrive", "fileUNC", "patternDrive", "patternUNC", "fdi", "pdi", "fd", "pd", "fi", "pi", "fl", "pl", "fr", "pr", "swallowee", "hit", "m", "fastTest", "re", "AST", "twoStar", "flags", "pp", "open", "close", "ff", "filename", "escape", "unescape", "perf", "warned", "PROCESS", "emitWarning", "msg", "type", "code", "fn", "AC", "AS", "_", "warnACPolyfill", "reason", "printACPolyfillWarning", "shouldWarn", "TYPE", "isPosInt", "n", "getUintArray", "max", "ZeroArray", "size", "Stack", "_Stack", "#constructing", "HeapCls", "LRUCache", "_LRUCache", "#max", "#maxSize", "#dispose", "#disposeAfter", "#fetchMethod", "#size", "#calculatedSize", "#keyMap", "#keyList", "#valList", "#next", "#prev", "#head", "#tail", "#free", "#disposed", "#sizes", "#starts", "#ttls", "#hasDispose", "#hasFetchMethod", "#hasDisposeAfter", "c", "p", "#isBackgroundFetch", "k", "index", "options", "context", "#backgroundFetch", "#moveToTail", "#indexes", "#rindexes", "#isStale", "ttl", "ttlResolution", "ttlAutopurge", "updateAgeOnGet", "updateAgeOnHas", "allowStale", "dispose", "disposeAfter", "noDisposeOnSet", "noUpdateTTL", "maxSize", "maxEntrySize", "sizeCalculation", "fetchMethod", "noDeleteOnFetchRejection", "noDeleteOnStaleGet", "allowStaleOnFetchRejection", "allowStaleOnFetchAbort", "ignoreFetchAbort", "UintArray", "#initializeSizeTracking", "#initializeTTLTracking", "key", "ttls", "starts", "#setItemTTL", "start", "t", "#updateItemAge", "#statusTTL", "status", "cachedNow", "getNow", "age", "s", "sizes", "#removeItemSize", "#requireSize", "v", "#addItemSize", "#evict", "_i", "_s", "_st", "_k", "_v", "i", "#isValidIndex", "getOptions", "value", "thisp", "deleted", "entry", "remain", "arr", "setOptions", "oldVal", "oldValue", "dt", "task", "val", "free", "head", "hasOptions", "peekOptions", "ac", "signal", "fetchOpts", "cb", "updateCache", "aborted", "ignoreAbort", "fetchFail", "bf", "eb", "er", "allowStaleAborted", "noDelete", "pcall", "res", "rej", "fmp", "b", "fetchOptions", "forceRefresh", "stale", "isStale", "staleVal", "fetching", "#connect", "pi", "ni", "import_path", "import_url", "actualFS", "import_fs", "import_promises", "import_events", "import_stream", "import_string_decoder", "proc", "isStream", "s", "Minipass", "Stream", "isReadable", "isWritable", "EOF", "MAYBE_EMIT_END", "EMITTED_END", "EMITTING_END", "EMITTED_ERROR", "CLOSED", "READ", "FLUSH", "FLUSHCHUNK", "ENCODING", "DECODER", "FLOWING", "PAUSED", "RESUME", "BUFFER", "PIPES", "BUFFERLENGTH", "BUFFERPUSH", "BUFFERSHIFT", "OBJECTMODE", "DESTROYED", "ERROR", "EMITDATA", "EMITEND", "EMITEND2", "ASYNC", "ABORT", "ABORTED", "SIGNAL", "DATALISTENERS", "DISCARDED", "defer", "fn", "nodefer", "isEndish", "ev", "isArrayBufferLike", "b", "isArrayBufferView", "Pipe", "src", "dest", "opts", "_er", "PipeProxyErrors", "er", "isObjectModeOptions", "o", "isEncodingOptions", "args", "options", "signal", "_enc", "_om", "a", "_", "chunk", "encoding", "cb", "n", "ret", "c", "noDrain", "ended", "p", "handler", "h", "data", "buf", "resolve", "reject", "stopped", "stop", "res", "onerr", "ondata", "onend", "ondestroy", "value", "rej", "next", "wc", "realpathSync", "rps", "defaultFS", "readdirCB", "fsFromOption", "fsOption", "actualFS", "uncDriveRegexp", "uncToDrive", "rootPath", "eitherSep", "UNKNOWN", "IFIFO", "IFCHR", "IFDIR", "IFBLK", "IFREG", "IFLNK", "IFSOCK", "IFMT", "IFMT_UNKNOWN", "READDIR_CALLED", "LSTAT_CALLED", "ENOTDIR", "ENOENT", "ENOREADLINK", "ENOREALPATH", "ENOCHILD", "TYPEMASK", "entToType", "s", "normalizeCache", "normalize", "c", "n", "normalizeNocaseCache", "normalizeNocase", "ResolveCache", "LRUCache", "ChildrenCache", "maxSize", "a", "setAsCwd", "PathBase", "#fs", "#dev", "#mode", "#nlink", "#uid", "#gid", "#rdev", "#blksize", "#ino", "#size", "#blocks", "#atimeMs", "#mtimeMs", "#ctimeMs", "#birthtimeMs", "#atime", "#mtime", "#ctime", "#birthtime", "#matchName", "#depth", "#fullpath", "#fullpathPosix", "#relative", "#relativePosix", "#type", "#children", "#linkTarget", "#realpath", "name", "type", "root", "roots", "nocase", "children", "opts", "path", "dirParts", "#resolveParts", "p", "part", "cached", "pathPart", "fullpath", "pchild", "pv", "fp", "pfpp", "fpp", "ifmt", "target", "read", "linkTarget", "er", "#readlinkFail", "#readdirSuccess", "#markENOENT", "#markChildrenENOENT", "#markENOREALPATH", "#markENOTDIR", "#readdirFail", "code", "#lstatFail", "ter", "#readdirAddChild", "e", "#readdirMaybePromoteChild", "#readdirAddNewChild", "child", "#readdirPromoteChild", "index", "v", "#applyStat", "st", "atime", "atimeMs", "birthtime", "birthtimeMs", "blksize", "blocks", "ctime", "ctimeMs", "dev", "gid", "ino", "mode", "mtime", "mtimeMs", "nlink", "rdev", "size", "uid", "#onReaddirCB", "#readdirCBInFlight", "#callOnReaddirCB", "cbs", "cb", "allowZalgo", "entries", "#asyncReaddirInFlight", "resolve", "res", "dirs", "walkFilter", "rp", "oldCwd", "changed", "PathWin32", "_PathWin32", "compare", "PathScurryWin32", "PathPosix", "_PathPosix", "_rootPath", "PathScurryBase", "#resolveCache", "#resolvePosixCache", "cwd", "pathImpl", "sep", "childrenCacheSize", "fs", "cwdPath", "split", "prev", "len", "joinSep", "abs", "sawFirst", "l", "paths", "r", "i", "result", "entry", "withFileTypes", "follow", "filter", "results", "walk", "dir", "next", "start", "rej", "options", "Minipass", "queue", "processing", "process", "paused", "onReaddir", "didRealpaths", "promises", "sync", "PathScurryPosix", "_dir", "PathScurryDarwin", "Path", "PathScurry", "import_url", "isPatternList", "pl", "isGlobList", "gl", "Pattern", "_Pattern", "#patternList", "#globList", "#index", "#platform", "#rest", "#globString", "#isDrive", "#isUNC", "#isAbsolute", "#followGlobstar", "patternList", "globList", "index", "platform", "p0", "p1", "p2", "p3", "prest", "g0", "g1", "g2", "g3", "grest", "g", "p", "GLOBSTAR", "defaultPlatform", "Ignore", "ignored", "nobrace", "nocase", "noext", "noglobstar", "platform", "mmopts", "ign", "mm", "Minimatch", "i", "parsed", "globParts", "p", "Pattern", "children", "absolute", "fullpath", "fullpaths", "relative", "relatives", "m", "HasWalkedCache", "_HasWalkedCache", "store", "target", "pattern", "fullpath", "cached", "MatchRecord", "absolute", "ifDir", "n", "current", "path", "SubWalks", "subs", "p", "k", "Processor", "_Processor", "opts", "hasWalkedCache", "patterns", "processingSet", "t", "root", "rest", "changed", "GLOBSTAR", "rp", "rrest", "tp", "parent", "entries", "results", "e", "ep", "makeIgnore", "ignore", "opts", "Ignore", "GlobUtil", "#onResume", "#ignore", "#sep", "patterns", "path", "#ignored", "#childrenIgnored", "fn", "e", "ifDir", "rpc", "needStat", "absolute", "abs", "mark", "rel", "pre", "p", "target", "cb", "Processor", "processor", "tasks", "next", "m", "t", "childrenCached", "_", "entries", "children", "GlobWalker", "res", "rej", "GlobStream", "Minipass", "defaultPlatform", "Glob", "pattern", "opts", "p", "Scurry", "PathScurryWin32", "PathScurryDarwin", "PathScurryPosix", "PathScurry", "nocaseMagicOnly", "mmo", "mms", "Minimatch", "matchSet", "globParts", "set", "m", "i", "g", "Pattern", "GlobWalker", "GlobStream", "hasMagic", "pattern", "options", "p", "Minimatch", "globStreamSync", "pattern", "options", "Glob", "globStream", "globSync", "glob_", "globIterateSync", "globIterate", "streamSync", "stream", "iterateSync", "iterate", "sync", "glob", "hasMagic", "escape", "unescape", "createDefaultLogger", "message", "createDefaultReporter", "result", "logging", "createDefaultLogger", "HashVerifyErr", "_HashVerifyErr", "reason", "cause", "message", "detectAlgorithm", "file", "split", "ext", "algo", "extensionMap", "detectEncodingForHash", "hash", "expectedBase64CharactersRegex", "encodedHashSizeBase64", "expectedHexCharactersRegex", "encodedHashSizeHex", "findSubject", "file", "parent", "split", "readSubject", "expected", "logging", "HashVerifyErr", "readHashFile", "content", "algorithm", "detectAlgorithm", "lines", "it", "assertions", "line", "detectEncodingForHash", "assertion", "expectedHexHashSize", "expectedBase64HashSize", "compareHashWithSubject", "hash", "subject", "encoding", "actual", "generateHash", "valid", "verifyHashFile", "abs", "err", "reportResults", "eligible", "verified", "failures", "reporter", "result", "error", "checkHashes", "paths", "strict", "ignored", "globs", "logger", "reportTo", "createDefaultReporter", "files", "algorithmExts", "allAlgorithms", "patterns", "path", "entry", "glob", "msg", "promises", "results", "errors", "promise", "verifiedFiles", "failedVerifications", "CLI_NAME", "CLI_VERSION", "outdatedAlgorithms", "defaultAlgorithms", "allAlgorithms", "i", "setupCli", "program", "entry", "CLI_VERSION", "globJoiner", "value", "previous", "entrySplitter", "defaultAlgorithms", "allAlgorithms", "CLI_NAME", "initializeAndRunCli", "args", "processBlobOrPathList", "list", "defaultValue", "checkAction", "cli", "logger", "reporter", "opts", "paths", "ignore", "strict", "results", "checkHashes", "generateAction", "freshenAction", "entrypoint", "Command", "action", "createCliLogger", "createCliReporter", "entrypoint"]
}
